<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultP2PNetwork.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.p2p.network</a> &gt; <span class="el_source">DefaultP2PNetwork.java</span></div><h1>DefaultP2PNetwork.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.p2p.network;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

import org.hyperledger.besu.cryptoservices.NodeKey;
import org.hyperledger.besu.ethereum.chain.Blockchain;
import org.hyperledger.besu.ethereum.chain.MutableBlockchain;
import org.hyperledger.besu.ethereum.core.Util;
import org.hyperledger.besu.ethereum.forkid.ForkIdManager;
import org.hyperledger.besu.ethereum.p2p.config.NetworkingConfiguration;
import org.hyperledger.besu.ethereum.p2p.discovery.DiscoveryPeer;
import org.hyperledger.besu.ethereum.p2p.discovery.PeerDiscoveryAgent;
import org.hyperledger.besu.ethereum.p2p.discovery.PeerDiscoveryStatus;
import org.hyperledger.besu.ethereum.p2p.discovery.VertxPeerDiscoveryAgent;
import org.hyperledger.besu.ethereum.p2p.discovery.internal.PeerTable;
import org.hyperledger.besu.ethereum.p2p.peers.DefaultPeerPrivileges;
import org.hyperledger.besu.ethereum.p2p.peers.EnodeURLImpl;
import org.hyperledger.besu.ethereum.p2p.peers.LocalNode;
import org.hyperledger.besu.ethereum.p2p.peers.MaintainedPeers;
import org.hyperledger.besu.ethereum.p2p.peers.MutableLocalNode;
import org.hyperledger.besu.ethereum.p2p.peers.Peer;
import org.hyperledger.besu.ethereum.p2p.peers.PeerPrivileges;
import org.hyperledger.besu.ethereum.p2p.permissions.PeerPermissions;
import org.hyperledger.besu.ethereum.p2p.permissions.PeerPermissionsDenylist;
import org.hyperledger.besu.ethereum.p2p.rlpx.ConnectCallback;
import org.hyperledger.besu.ethereum.p2p.rlpx.DisconnectCallback;
import org.hyperledger.besu.ethereum.p2p.rlpx.MessageCallback;
import org.hyperledger.besu.ethereum.p2p.rlpx.RlpxAgent;
import org.hyperledger.besu.ethereum.p2p.rlpx.connections.PeerConnection;
import org.hyperledger.besu.ethereum.p2p.rlpx.connections.netty.TLSConfiguration;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.ShouldConnectCallback;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.messages.DisconnectMessage.DisconnectReason;
import org.hyperledger.besu.ethereum.storage.StorageProvider;
import org.hyperledger.besu.nat.NatMethod;
import org.hyperledger.besu.nat.NatService;
import org.hyperledger.besu.nat.core.NatManager;
import org.hyperledger.besu.nat.core.domain.NatServiceType;
import org.hyperledger.besu.nat.core.domain.NetworkProtocol;
import org.hyperledger.besu.nat.upnp.UpnpNatManager;
import org.hyperledger.besu.plugin.data.EnodeURL;
import org.hyperledger.besu.plugin.services.MetricsSystem;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import io.vertx.core.Vertx;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.devp2p.EthereumNodeRecord;
import org.apache.tuweni.discovery.DNSDaemon;
import org.apache.tuweni.discovery.DNSDaemonListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The peer network service (defunct PeerNetworkingService) is the entrypoint to the peer-to-peer
 * components of the Ethereum client. It implements the devp2p framework from the Ethereum
 * specifications.
 *
 * &lt;p&gt;This component manages the peer discovery layer, the RLPx wire protocol and the subprotocols
 * supported by this client.
 *
 * &lt;h2&gt;Peer Discovery&lt;/h2&gt;
 *
 * Ethereum nodes discover one another via a simple UDP protocol that follows some of the techniques
 * described in the Kademlia DHT paper. Particularly nodes are classified in a k-bucket table
 * composed of 256 buckets, where each bucket contains at most 16 peers whose &lt;i&gt;XOR(SHA3(x))&lt;/i&gt;
 * distance from us is equal to the index of the bucket. The value &lt;i&gt;x&lt;/i&gt; in the distance function
 * corresponds to our node ID (public key).
 *
 * &lt;p&gt;Upper layers in the stack subscribe to events from the peer discovery layer and initiate/drop
 * connections accordingly.
 *
 * &lt;h2&gt;RLPx Wire Protocol&lt;/h2&gt;
 *
 * The RLPx wire protocol is responsible for selecting peers to engage with, authenticating and
 * encrypting communications with peers, multiplexing subprotocols, framing messages, controlling
 * legality of messages, keeping connections alive, and keeping track of peer reputation.
 *
 * &lt;h2&gt;Subprotocols&lt;/h2&gt;
 *
 * Subprotocols are pluggable elements on top of the RLPx framework, which can handle a specific set
 * of messages. Each subprotocol has a 3-char ASCII denominator and a version number, and statically
 * defines a count of messages it can handle.
 *
 * &lt;p&gt;The RLPx wire protocol dispatches messages to subprotocols based on the capabilities agreed by
 * each of the two peers during the protocol handshake.
 *
 * @see &lt;a href=&quot;https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf&quot;&gt;Kademlia DHT
 *     paper&lt;/a&gt;
 * @see &lt;a href=&quot;https://github.com/ethereum/wiki/wiki/Kademlia-Peer-Selection&quot;&gt;Kademlia Peer
 *     Selection&lt;/a&gt;
 * @see &lt;a href=&quot;https://github.com/ethereum/devp2p/blob/master/rlpx.md&quot;&gt;devp2p RLPx&lt;/a&gt;
 */
public class DefaultP2PNetwork implements P2PNetwork {

<span class="fc" id="L128">  private static final Logger LOG = LoggerFactory.getLogger(DefaultP2PNetwork.class);</span>

<span class="fc" id="L130">  private final ScheduledExecutorService peerConnectionScheduler =</span>
<span class="fc" id="L131">      Executors.newSingleThreadScheduledExecutor();</span>
  private final PeerDiscoveryAgent peerDiscoveryAgent;
  private final RlpxAgent rlpxAgent;

  private final NetworkingConfiguration config;

  private final Bytes nodeId;
  private final MutableLocalNode localNode;

  private final PeerPermissions peerPermissions;
  private final MaintainedPeers maintainedPeers;

  private final NatService natService;

<span class="fc" id="L145">  private final AtomicBoolean started = new AtomicBoolean(false);</span>
<span class="fc" id="L146">  private final AtomicBoolean stopped = new AtomicBoolean(false);</span>
<span class="fc" id="L147">  private final CountDownLatch shutdownLatch = new CountDownLatch(2);</span>
<span class="fc" id="L148">  private final Duration shutdownTimeout = Duration.ofSeconds(15);</span>
  private final Vertx vertx;
  private DNSDaemon dnsDaemon;

  /**
   * Creates a peer networking service for production purposes.
   *
   * &lt;p&gt;The caller is expected to provide the IP address to be advertised (normally this node's
   * public IP address), as well as TCP and UDP port numbers for the RLPx agent and the discovery
   * agent, respectively.
   *
   * @param localNode A representation of the local node
   * @param peerDiscoveryAgent The agent responsible for discovering peers on the network.
   * @param nodeKey The node key through which cryptographic operations can be performed
   * @param config The network configuration to use.
   * @param peerPermissions An object that determines whether peers are allowed to connect
   * @param natService The NAT environment manager.
   * @param maintainedPeers A collection of peers for which we are expected to maintain connections
   * @param reputationManager An object that inspect disconnections for misbehaving peers that can
   *     then be blacklisted.
   * @param vertx the Vert.x instance managing network resources
   */
  DefaultP2PNetwork(
      final MutableLocalNode localNode,
      final PeerDiscoveryAgent peerDiscoveryAgent,
      final RlpxAgent rlpxAgent,
      final NodeKey nodeKey,
      final NetworkingConfiguration config,
      final PeerPermissions peerPermissions,
      final NatService natService,
      final MaintainedPeers maintainedPeers,
      final PeerDenylistManager reputationManager,
<span class="fc" id="L180">      final Vertx vertx) {</span>
<span class="fc" id="L181">    this.localNode = localNode;</span>
<span class="fc" id="L182">    this.peerDiscoveryAgent = peerDiscoveryAgent;</span>
<span class="fc" id="L183">    this.rlpxAgent = rlpxAgent;</span>
<span class="fc" id="L184">    this.config = config;</span>
<span class="fc" id="L185">    this.natService = natService;</span>
<span class="fc" id="L186">    this.maintainedPeers = maintainedPeers;</span>

<span class="fc" id="L188">    this.nodeId = nodeKey.getPublicKey().getEncodedBytes();</span>
<span class="fc" id="L189">    this.peerPermissions = peerPermissions;</span>
<span class="fc" id="L190">    this.vertx = vertx;</span>

<span class="fc" id="L192">    final int maxPeers = rlpxAgent.getMaxPeers();</span>
<span class="fc" id="L193">    LOG.debug(&quot;setting maxPeers {}&quot;, maxPeers);</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">    peerDiscoveryAgent.addPeerRequirement(() -&gt; rlpxAgent.getConnectionCount() &gt;= maxPeers);</span>
<span class="fc" id="L195">    subscribeDisconnect(reputationManager);</span>
<span class="fc" id="L196">  }</span>

  public static Builder builder() {
<span class="fc" id="L199">    return new Builder();</span>
  }

  @Override
  public void start() {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (!started.compareAndSet(false, true)) {</span>
<span class="nc" id="L205">      LOG.warn(&quot;Attempted to start an already started &quot; + getClass().getSimpleName());</span>
<span class="nc" id="L206">      return;</span>
    }

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    if (config.getDiscovery().isDiscoveryV5Enabled()) {</span>
<span class="nc" id="L210">      LOG.warn(&quot;Discovery Protocol v5 is not available&quot;);</span>
    }

<span class="fc" id="L213">    final String address = config.getDiscovery().getAdvertisedHost();</span>
<span class="fc" id="L214">    final int configuredDiscoveryPort = config.getDiscovery().getBindPort();</span>
<span class="fc" id="L215">    final int configuredRlpxPort = config.getRlpx().getBindPort();</span>

<span class="fc" id="L217">    Optional.ofNullable(config.getDiscovery().getDNSDiscoveryURL())</span>
<span class="fc" id="L218">        .ifPresent(</span>
            disco -&gt; {
              // These lists are updated every 12h
              // We retrieve the list every 10 minutes (600000 msec)
<span class="fc" id="L222">              LOG.info(&quot;Starting DNS discovery with URL {}&quot;, disco);</span>
<span class="fc" id="L223">              config</span>
<span class="fc" id="L224">                  .getDnsDiscoveryServerOverride()</span>
<span class="fc" id="L225">                  .ifPresent(</span>
                      dnsServer -&gt;
<span class="fc" id="L227">                          LOG.info(</span>
                              &quot;Starting DNS discovery with DNS Server override {}&quot;, dnsServer));

<span class="fc" id="L230">              dnsDaemon =</span>
                  new DNSDaemon(
                      disco,
<span class="fc" id="L233">                      createDaemonListener(),</span>
                      0L,
                      600000L,
<span class="fc" id="L236">                      config.getDnsDiscoveryServerOverride().orElse(null),</span>
                      vertx);
<span class="fc" id="L238">              dnsDaemon.start();</span>
<span class="fc" id="L239">            });</span>

<span class="fc" id="L241">    final int listeningPort = rlpxAgent.start().join();</span>
<span class="fc" id="L242">    final int discoveryPort =</span>
        peerDiscoveryAgent
<span class="fc" id="L244">            .start(</span>
<span class="pc bpc" id="L245" title="1 of 4 branches missed.">                (configuredDiscoveryPort == 0 &amp;&amp; configuredRlpxPort == 0)</span>
<span class="fc" id="L246">                    ? listeningPort</span>
<span class="fc" id="L247">                    : configuredDiscoveryPort)</span>
<span class="fc" id="L248">            .join();</span>

<span class="fc" id="L250">    final Consumer&lt;? super NatManager&gt; natAction =</span>
        natManager -&gt; {
<span class="fc" id="L252">          final UpnpNatManager upnpNatManager = (UpnpNatManager) natManager;</span>
<span class="fc" id="L253">          upnpNatManager.requestPortForward(</span>
              discoveryPort, NetworkProtocol.UDP, NatServiceType.DISCOVERY);
<span class="fc" id="L255">          upnpNatManager.requestPortForward(</span>
              listeningPort, NetworkProtocol.TCP, NatServiceType.RLPX);
<span class="fc" id="L257">        };</span>

<span class="fc" id="L259">    natService.ifNatEnvironment(NatMethod.UPNP, natAction);</span>
<span class="fc" id="L260">    natService.ifNatEnvironment(NatMethod.UPNPP2PONLY, natAction);</span>

<span class="fc" id="L262">    setLocalNode(address, listeningPort, discoveryPort);</span>

    // Call checkMaintainedConnectionPeers() now that the local node is up, for immediate peer
    // additions
<span class="fc" id="L266">    checkMaintainedConnectionPeers();</span>

    // Periodically check maintained connections
<span class="fc" id="L269">    final int checkMaintainedConnectionsSec = config.getCheckMaintainedConnectionsFrequencySec();</span>
<span class="fc" id="L270">    peerConnectionScheduler.scheduleWithFixedDelay(</span>
        this::checkMaintainedConnectionPeers, 2, checkMaintainedConnectionsSec, TimeUnit.SECONDS);
    // Periodically initiate outgoing connections to discovered peers
<span class="fc" id="L273">    final int checkConnectionsSec = config.getInitiateConnectionsFrequencySec();</span>
<span class="fc" id="L274">    peerConnectionScheduler.scheduleWithFixedDelay(</span>
        this::attemptPeerConnections, checkConnectionsSec, checkConnectionsSec, TimeUnit.SECONDS);
<span class="fc" id="L276">  }</span>

  @Override
  public void stop() {
<span class="fc bfc" id="L280" title="All 4 branches covered.">    if (!this.started.get() || !stopped.compareAndSet(false, true)) {</span>
      // We haven't started, or we've started and stopped already
<span class="fc" id="L282">      return;</span>
    }

<span class="fc" id="L285">    getDnsDaemon().ifPresent(DNSDaemon::close);</span>

<span class="fc" id="L287">    peerConnectionScheduler.shutdownNow();</span>
<span class="fc" id="L288">    peerDiscoveryAgent.stop().whenComplete((res, err) -&gt; shutdownLatch.countDown());</span>
<span class="fc" id="L289">    rlpxAgent.stop().whenComplete((res, err) -&gt; shutdownLatch.countDown());</span>
<span class="fc" id="L290">    peerPermissions.close();</span>
<span class="fc" id="L291">  }</span>

  @Override
  public void awaitStop() {
    try {
<span class="fc bfc" id="L296" title="All 2 branches covered.">      if (!peerConnectionScheduler.awaitTermination(</span>
<span class="fc" id="L297">          shutdownTimeout.getSeconds(), TimeUnit.SECONDS)) {</span>
<span class="fc" id="L298">        LOG.error(</span>
            &quot;{} did not shutdown cleanly: peerConnectionScheduler executor did not fully terminate.&quot;,
<span class="fc" id="L300">            this.getClass().getSimpleName());</span>
      }
<span class="fc bfc" id="L302" title="All 2 branches covered.">      if (!shutdownLatch.await(shutdownTimeout.getSeconds(), TimeUnit.SECONDS)) {</span>
<span class="fc" id="L303">        LOG.error(</span>
            &quot;{} did not shutdown cleanly: some internal services failed to fully terminate.&quot;,
<span class="fc" id="L305">            this.getClass().getSimpleName());</span>
      }
<span class="nc" id="L307">    } catch (final InterruptedException ex) {</span>
<span class="nc" id="L308">      throw new IllegalStateException(ex);</span>
<span class="fc" id="L309">    }</span>
<span class="fc" id="L310">  }</span>

  @Override
  public RlpxAgent getRlpxAgent() {
<span class="fc" id="L314">    return rlpxAgent;</span>
  }

  @Override
  public boolean addMaintainedConnectionPeer(final Peer peer) {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    if (localNode.isReady()</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        &amp;&amp; localNode.getPeer() != null</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        &amp;&amp; localNode.getPeer().getEnodeURL() != null</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        &amp;&amp; peer.getEnodeURL().getNodeId().equals(localNode.getPeer().getEnodeURL().getNodeId())) {</span>
<span class="fc" id="L323">      return false;</span>
    }
<span class="fc" id="L325">    final boolean wasAdded = maintainedPeers.add(peer);</span>
<span class="fc" id="L326">    peerDiscoveryAgent.bond(peer);</span>
<span class="fc" id="L327">    rlpxAgent.connect(peer);</span>
<span class="fc" id="L328">    return wasAdded;</span>
  }

  @Override
  public boolean removeMaintainedConnectionPeer(final Peer peer) {
<span class="fc" id="L333">    final boolean wasRemoved = maintainedPeers.remove(peer);</span>
<span class="fc" id="L334">    peerDiscoveryAgent.dropPeer(peer);</span>
<span class="fc" id="L335">    LOG.debug(&quot;Disconnect requested for peer {}.&quot;, peer);</span>
<span class="fc" id="L336">    rlpxAgent.disconnect(peer.getId(), DisconnectReason.REQUESTED);</span>
<span class="fc" id="L337">    return wasRemoved;</span>
  }

  @VisibleForTesting
  Optional&lt;DNSDaemon&gt; getDnsDaemon() {
<span class="fc" id="L342">    return Optional.ofNullable(dnsDaemon);</span>
  }

  @VisibleForTesting
  DNSDaemonListener createDaemonListener() {
<span class="fc" id="L347">    return (seq, records) -&gt; {</span>
<span class="nc" id="L348">      final List&lt;DiscoveryPeer&gt; peers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">      for (final EthereumNodeRecord enr : records) {</span>
        final EnodeURL enodeURL =
<span class="nc" id="L351">            EnodeURLImpl.builder()</span>
<span class="nc" id="L352">                .ipAddress(enr.ip())</span>
<span class="nc" id="L353">                .nodeId(enr.publicKey().bytes())</span>
<span class="nc" id="L354">                .discoveryPort(Optional.ofNullable(enr.udp()))</span>
<span class="nc" id="L355">                .listeningPort(Optional.ofNullable(enr.tcp()))</span>
<span class="nc" id="L356">                .build();</span>
<span class="nc" id="L357">        final DiscoveryPeer peer = DiscoveryPeer.fromEnode(enodeURL);</span>
<span class="nc" id="L358">        peers.add(peer);</span>
<span class="nc" id="L359">      }</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">      if (!peers.isEmpty()) {</span>
<span class="nc" id="L361">        peers.stream().forEach(peerDiscoveryAgent::bond);</span>
      }
<span class="nc" id="L363">    };</span>
  }

  @VisibleForTesting
  void checkMaintainedConnectionPeers() {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">    if (!localNode.isReady()) {</span>
<span class="nc" id="L369">      return;</span>
    }
<span class="fc" id="L371">    final List&lt;Bytes&gt; doNotConnectTo =</span>
        rlpxAgent
<span class="fc" id="L373">            .streamActiveConnections()</span>
<span class="fc" id="L374">            .map(c -&gt; c.getPeer().getId())</span>
<span class="fc" id="L375">            .collect(Collectors.toList());</span>
<span class="fc" id="L376">    doNotConnectTo.add(localNode.getPeer().getEnodeURL().getNodeId());</span>
<span class="fc" id="L377">    maintainedPeers</span>
<span class="fc" id="L378">        .streamPeers()</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">        .filter(p -&gt; !doNotConnectTo.contains(p.getId()))</span>
<span class="fc" id="L380">        .forEach(rlpxAgent::connect);</span>
<span class="fc" id="L381">  }</span>

  @VisibleForTesting
  void attemptPeerConnections() {
<span class="fc" id="L385">    LOG.trace(&quot;Initiating connections to discovered peers.&quot;);</span>
<span class="fc" id="L386">    final Stream&lt;DiscoveryPeer&gt; toTry =</span>
<span class="fc" id="L387">        streamDiscoveredPeers()</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            .filter(peer -&gt; peer.getStatus() == PeerDiscoveryStatus.BONDED)</span>
<span class="fc" id="L389">            .filter(peerDiscoveryAgent::checkForkId)</span>
<span class="fc" id="L390">            .sorted(Comparator.comparing(DiscoveryPeer::getLastAttemptedConnection));</span>
<span class="fc" id="L391">    toTry.forEach(rlpxAgent::connect);</span>
<span class="fc" id="L392">  }</span>

  @Override
  public Collection&lt;PeerConnection&gt; getPeers() {
<span class="fc" id="L396">    return rlpxAgent.streamConnections().collect(Collectors.toList());</span>
  }

  @Override
  public int getPeerCount() {
<span class="fc" id="L401">    return getRlpxAgent().getConnectionCount();</span>
  }

  @Override
  public Stream&lt;DiscoveryPeer&gt; streamDiscoveredPeers() {
<span class="fc" id="L406">    return peerDiscoveryAgent.streamDiscoveredPeers();</span>
  }

  @Override
  public CompletableFuture&lt;PeerConnection&gt; connect(final Peer peer) {
<span class="fc" id="L411">    return rlpxAgent.connect(peer);</span>
  }

  @Override
  public void subscribe(final Capability capability, final MessageCallback callback) {
<span class="fc" id="L416">    rlpxAgent.subscribeMessage(capability, callback);</span>
<span class="fc" id="L417">  }</span>

  @Override
  public void subscribeConnect(final ConnectCallback callback) {
<span class="fc" id="L421">    rlpxAgent.subscribeConnect(callback);</span>
<span class="fc" id="L422">  }</span>

  @Override
  public void subscribeConnectRequest(final ShouldConnectCallback callback) {
<span class="fc" id="L426">    rlpxAgent.subscribeConnectRequest(callback);</span>
<span class="fc" id="L427">  }</span>

  @Override
  public void subscribeDisconnect(final DisconnectCallback callback) {
<span class="fc" id="L431">    rlpxAgent.subscribeDisconnect(callback);</span>
<span class="fc" id="L432">  }</span>

  @Override
  public void close() {
<span class="fc" id="L436">    stop();</span>
<span class="fc" id="L437">  }</span>

  @Override
  public boolean isListening() {
<span class="nc" id="L441">    return localNode.isReady();</span>
  }

  @Override
  public boolean isP2pEnabled() {
<span class="fc" id="L446">    return true;</span>
  }

  @Override
  public boolean isDiscoveryEnabled() {
<span class="nc" id="L451">    return peerDiscoveryAgent.isActive();</span>
  }

  @Override
  public Optional&lt;EnodeURL&gt; getLocalEnode() {
<span class="fc bfc" id="L456" title="All 2 branches covered.">    if (!localNode.isReady()) {</span>
<span class="fc" id="L457">      return Optional.empty();</span>
    }
<span class="fc" id="L459">    return Optional.of(localNode.getPeer().getEnodeURL());</span>
  }

  private void setLocalNode(
      final String address, final int listeningPort, final int discoveryPort) {
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">    if (localNode.isReady()) {</span>
      // Already set
<span class="nc" id="L466">      return;</span>
    }

    // override advertised host if we detect an external IP address via NAT manager
<span class="fc" id="L470">    final String advertisedAddress = natService.queryExternalIPAddress(address);</span>

    final EnodeURL localEnode =
<span class="fc" id="L473">        EnodeURLImpl.builder()</span>
<span class="fc" id="L474">            .nodeId(nodeId)</span>
<span class="fc" id="L475">            .ipAddress(advertisedAddress)</span>
<span class="fc" id="L476">            .listeningPort(listeningPort)</span>
<span class="fc" id="L477">            .discoveryPort(discoveryPort)</span>
<span class="fc" id="L478">            .build();</span>

<span class="fc" id="L480">    LOG.info(&quot;Enode URL {}&quot;, localEnode.toString());</span>
<span class="fc" id="L481">    LOG.info(&quot;Node address {}&quot;, Util.publicKeyToAddress(localEnode.getNodeId()));</span>
<span class="fc" id="L482">    localNode.setEnode(localEnode);</span>
<span class="fc" id="L483">  }</span>

  @Override
  public void updateNodeRecord() {
<span class="fc" id="L487">    peerDiscoveryAgent.updateNodeRecord();</span>
<span class="fc" id="L488">  }</span>

<span class="fc" id="L490">  public static class Builder {</span>

    private Vertx vertx;
    private PeerDiscoveryAgent peerDiscoveryAgent;
    private RlpxAgent rlpxAgent;

<span class="fc" id="L496">    private NetworkingConfiguration config = NetworkingConfiguration.create();</span>
    private List&lt;Capability&gt; supportedCapabilities;
    private NodeKey nodeKey;

<span class="fc" id="L500">    private MaintainedPeers maintainedPeers = new MaintainedPeers();</span>
<span class="fc" id="L501">    private PeerPermissions peerPermissions = PeerPermissions.noop();</span>

<span class="fc" id="L503">    private NatService natService = new NatService(Optional.empty());</span>
    private MetricsSystem metricsSystem;
    private StorageProvider storageProvider;
<span class="fc" id="L506">    private Optional&lt;TLSConfiguration&gt; p2pTLSConfiguration = Optional.empty();</span>
    private Blockchain blockchain;
    private List&lt;Long&gt; blockNumberForks;
    private List&lt;Long&gt; timestampForks;
<span class="fc" id="L510">    private boolean legacyForkIdEnabled = false;</span>
    private Supplier&lt;Stream&lt;PeerConnection&gt;&gt; allConnectionsSupplier;
    private Supplier&lt;Stream&lt;PeerConnection&gt;&gt; allActiveConnectionsSupplier;
    private int maxPeers;
    private PeerTable peerTable;

    public P2PNetwork build() {
<span class="fc" id="L517">      validate();</span>
<span class="fc" id="L518">      return doBuild();</span>
    }

    private P2PNetwork doBuild() {
      // Set up permissions
      // Fold peer reputation into permissions
<span class="fc" id="L524">      final PeerPermissionsDenylist misbehavingPeers = PeerPermissionsDenylist.create(500);</span>
<span class="fc" id="L525">      final PeerDenylistManager reputationManager =</span>
          new PeerDenylistManager(misbehavingPeers, maintainedPeers);
<span class="fc" id="L527">      peerPermissions = PeerPermissions.combine(peerPermissions, misbehavingPeers);</span>

<span class="fc" id="L529">      final MutableLocalNode localNode =</span>
<span class="fc" id="L530">          MutableLocalNode.create(config.getRlpx().getClientId(), 5, supportedCapabilities);</span>
<span class="fc" id="L531">      final PeerPrivileges peerPrivileges = new DefaultPeerPrivileges(maintainedPeers);</span>
<span class="fc" id="L532">      peerTable = new PeerTable(nodeKey.getPublicKey().getEncodedBytes());</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">      rlpxAgent = rlpxAgent == null ? createRlpxAgent(localNode, peerPrivileges) : rlpxAgent;</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">      peerDiscoveryAgent = peerDiscoveryAgent == null ? createDiscoveryAgent() : peerDiscoveryAgent;</span>

<span class="fc" id="L536">      return new DefaultP2PNetwork(</span>
          localNode,
          peerDiscoveryAgent,
          rlpxAgent,
          nodeKey,
          config,
          peerPermissions,
          natService,
          maintainedPeers,
          reputationManager,
          vertx);
    }

    private void validate() {
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">      checkState(nodeKey != null, &quot;NodeKey must be set.&quot;);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">      checkState(config != null, &quot;NetworkingConfiguration must be set.&quot;);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">      checkState(</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">          supportedCapabilities != null &amp;&amp; supportedCapabilities.size() &gt; 0,</span>
          &quot;Supported capabilities must be set and non-empty.&quot;);
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">      checkState(metricsSystem != null, &quot;MetricsSystem must be set.&quot;);</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">      checkState(storageProvider != null, &quot;StorageProvider must be set.&quot;);</span>
<span class="pc bpc" id="L557" title="1 of 4 branches missed.">      checkState(peerDiscoveryAgent != null || vertx != null, &quot;Vertx must be set.&quot;);</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">      checkState(blockNumberForks != null, &quot;BlockNumberForks must be set.&quot;);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">      checkState(timestampForks != null, &quot;TimestampForks must be set.&quot;);</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">      checkState(allConnectionsSupplier != null, &quot;Supplier must be set.&quot;);</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">      checkState(allActiveConnectionsSupplier != null, &quot;Supplier must be set.&quot;);</span>
<span class="fc" id="L562">    }</span>

    private PeerDiscoveryAgent createDiscoveryAgent() {
<span class="fc" id="L565">      final ForkIdManager forkIdManager =</span>
          new ForkIdManager(blockchain, blockNumberForks, timestampForks, this.legacyForkIdEnabled);

<span class="fc" id="L568">      return new VertxPeerDiscoveryAgent(</span>
          vertx,
          nodeKey,
<span class="fc" id="L571">          config.getDiscovery(),</span>
          peerPermissions,
          natService,
          metricsSystem,
          storageProvider,
          forkIdManager,
          rlpxAgent,
          peerTable);
    }

    private RlpxAgent createRlpxAgent(
        final LocalNode localNode, final PeerPrivileges peerPrivileges) {

<span class="fc" id="L584">      return RlpxAgent.builder()</span>
<span class="fc" id="L585">          .nodeKey(nodeKey)</span>
<span class="fc" id="L586">          .config(config.getRlpx())</span>
<span class="fc" id="L587">          .peerPermissions(peerPermissions)</span>
<span class="fc" id="L588">          .peerPrivileges(peerPrivileges)</span>
<span class="fc" id="L589">          .localNode(localNode)</span>
<span class="fc" id="L590">          .metricsSystem(metricsSystem)</span>
<span class="fc" id="L591">          .p2pTLSConfiguration(p2pTLSConfiguration)</span>
<span class="fc" id="L592">          .allConnectionsSupplier(allConnectionsSupplier)</span>
<span class="fc" id="L593">          .allActiveConnectionsSupplier(allActiveConnectionsSupplier)</span>
<span class="fc" id="L594">          .maxPeers(maxPeers)</span>
<span class="fc" id="L595">          .peerTable(peerTable)</span>
<span class="fc" id="L596">          .build();</span>
    }

    public Builder peerDiscoveryAgent(final PeerDiscoveryAgent peerDiscoveryAgent) {
<span class="fc" id="L600">      checkNotNull(peerDiscoveryAgent);</span>
<span class="fc" id="L601">      this.peerDiscoveryAgent = peerDiscoveryAgent;</span>
<span class="fc" id="L602">      return this;</span>
    }

    public Builder rlpxAgent(final RlpxAgent rlpxAgent) {
<span class="fc" id="L606">      checkNotNull(rlpxAgent);</span>
<span class="fc" id="L607">      this.rlpxAgent = rlpxAgent;</span>
<span class="fc" id="L608">      return this;</span>
    }

    public Builder vertx(final Vertx vertx) {
<span class="fc" id="L612">      checkNotNull(vertx);</span>
<span class="fc" id="L613">      this.vertx = vertx;</span>
<span class="fc" id="L614">      return this;</span>
    }

    public Builder nodeKey(final NodeKey nodeKey) {
<span class="fc" id="L618">      checkNotNull(nodeKey);</span>
<span class="fc" id="L619">      this.nodeKey = nodeKey;</span>
<span class="fc" id="L620">      return this;</span>
    }

    public Builder config(final NetworkingConfiguration config) {
<span class="fc" id="L624">      checkNotNull(config);</span>
<span class="fc" id="L625">      this.config = config;</span>
<span class="fc" id="L626">      return this;</span>
    }

    public Builder supportedCapabilities(final List&lt;Capability&gt; supportedCapabilities) {
<span class="fc" id="L630">      checkNotNull(supportedCapabilities);</span>
<span class="fc" id="L631">      this.supportedCapabilities = supportedCapabilities;</span>
<span class="fc" id="L632">      return this;</span>
    }

    public Builder supportedCapabilities(final Capability... supportedCapabilities) {
<span class="fc" id="L636">      this.supportedCapabilities = Arrays.asList(supportedCapabilities);</span>
<span class="fc" id="L637">      return this;</span>
    }

    public Builder peerPermissions(final PeerPermissions peerPermissions) {
<span class="fc" id="L641">      checkNotNull(peerPermissions);</span>
<span class="fc" id="L642">      this.peerPermissions = peerPermissions;</span>
<span class="fc" id="L643">      return this;</span>
    }

    public Builder metricsSystem(final MetricsSystem metricsSystem) {
<span class="fc" id="L647">      checkNotNull(metricsSystem);</span>
<span class="fc" id="L648">      this.metricsSystem = metricsSystem;</span>
<span class="fc" id="L649">      return this;</span>
    }

    public Builder natService(final NatService natService) {
<span class="fc" id="L653">      checkNotNull(natService);</span>
<span class="fc" id="L654">      this.natService = natService;</span>
<span class="fc" id="L655">      return this;</span>
    }

    public Builder maintainedPeers(final MaintainedPeers maintainedPeers) {
<span class="fc" id="L659">      checkNotNull(maintainedPeers);</span>
<span class="fc" id="L660">      this.maintainedPeers = maintainedPeers;</span>
<span class="fc" id="L661">      return this;</span>
    }

    public Builder storageProvider(final StorageProvider storageProvider) {
<span class="fc" id="L665">      checkNotNull(storageProvider);</span>
<span class="fc" id="L666">      this.storageProvider = storageProvider;</span>
<span class="fc" id="L667">      return this;</span>
    }

    public Builder p2pTLSConfiguration(final Optional&lt;TLSConfiguration&gt; p2pTLSConfiguration) {
<span class="fc" id="L671">      checkNotNull(p2pTLSConfiguration);</span>
<span class="fc" id="L672">      this.p2pTLSConfiguration = p2pTLSConfiguration;</span>
<span class="fc" id="L673">      return this;</span>
    }

    public Builder blockchain(final MutableBlockchain blockchain) {
<span class="fc" id="L677">      checkNotNull(blockchain);</span>
<span class="fc" id="L678">      this.blockchain = blockchain;</span>
<span class="fc" id="L679">      return this;</span>
    }

    public Builder blockNumberForks(final List&lt;Long&gt; forks) {
<span class="fc" id="L683">      checkNotNull(forks);</span>
<span class="fc" id="L684">      this.blockNumberForks = forks;</span>
<span class="fc" id="L685">      return this;</span>
    }

    public Builder timestampForks(final List&lt;Long&gt; forks) {
<span class="fc" id="L689">      checkNotNull(forks);</span>
<span class="fc" id="L690">      this.timestampForks = forks;</span>
<span class="fc" id="L691">      return this;</span>
    }

    public Builder legacyForkIdEnabled(final boolean legacyForkIdEnabled) {
<span class="fc" id="L695">      this.legacyForkIdEnabled = legacyForkIdEnabled;</span>
<span class="fc" id="L696">      return this;</span>
    }

    public Builder allConnectionsSupplier(
        final Supplier&lt;Stream&lt;PeerConnection&gt;&gt; allConnectionsSupplier) {
<span class="fc" id="L701">      this.allConnectionsSupplier = allConnectionsSupplier;</span>
<span class="fc" id="L702">      return this;</span>
    }

    public Builder allActiveConnectionsSupplier(
        final Supplier&lt;Stream&lt;PeerConnection&gt;&gt; allActiveConnectionsSupplier) {
<span class="fc" id="L707">      this.allActiveConnectionsSupplier = allActiveConnectionsSupplier;</span>
<span class="fc" id="L708">      return this;</span>
    }

    public Builder maxPeers(final int maxPeers) {
<span class="fc" id="L712">      this.maxPeers = maxPeers;</span>
<span class="fc" id="L713">      return this;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>