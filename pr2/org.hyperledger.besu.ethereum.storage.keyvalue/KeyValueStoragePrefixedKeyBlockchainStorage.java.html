<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyValueStoragePrefixedKeyBlockchainStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.storage.keyvalue</a> &gt; <span class="el_source">KeyValueStoragePrefixedKeyBlockchainStorage.java</span></div><h1>KeyValueStoragePrefixedKeyBlockchainStorage.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.storage.keyvalue;

import static org.hyperledger.besu.ethereum.chain.VariablesStorage.Keys.CHAIN_HEAD_HASH;
import static org.hyperledger.besu.ethereum.chain.VariablesStorage.Keys.FINALIZED_BLOCK_HASH;
import static org.hyperledger.besu.ethereum.chain.VariablesStorage.Keys.FORK_HEADS;
import static org.hyperledger.besu.ethereum.chain.VariablesStorage.Keys.SAFE_BLOCK_HASH;
import static org.hyperledger.besu.ethereum.chain.VariablesStorage.Keys.SEQ_NO_STORE;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.chain.BlockchainStorage;
import org.hyperledger.besu.ethereum.chain.TransactionLocation;
import org.hyperledger.besu.ethereum.chain.VariablesStorage;
import org.hyperledger.besu.ethereum.core.BlockBody;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockHeaderFunctions;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.core.TransactionReceipt;
import org.hyperledger.besu.ethereum.rlp.RLP;
import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.KeyValueStorageTransaction;

import java.util.Collection;
import java.util.List;
import java.util.Optional;

import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.apache.tuweni.units.bigints.UInt256;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class KeyValueStoragePrefixedKeyBlockchainStorage implements BlockchainStorage {
<span class="fc" id="L47">  private static final Logger LOG =</span>
<span class="fc" id="L48">      LoggerFactory.getLogger(KeyValueStoragePrefixedKeyBlockchainStorage.class);</span>

  @Deprecated(since = &quot;23.4.2&quot;, forRemoval = true)
<span class="fc" id="L51">  private static final Bytes VARIABLES_PREFIX = Bytes.of(1);</span>

<span class="fc" id="L53">  private static final Bytes BLOCK_HEADER_PREFIX = Bytes.of(2);</span>
<span class="fc" id="L54">  private static final Bytes BLOCK_BODY_PREFIX = Bytes.of(3);</span>
<span class="fc" id="L55">  private static final Bytes TRANSACTION_RECEIPTS_PREFIX = Bytes.of(4);</span>
<span class="fc" id="L56">  private static final Bytes BLOCK_HASH_PREFIX = Bytes.of(5);</span>
<span class="fc" id="L57">  private static final Bytes TOTAL_DIFFICULTY_PREFIX = Bytes.of(6);</span>
<span class="fc" id="L58">  private static final Bytes TRANSACTION_LOCATION_PREFIX = Bytes.of(7);</span>
  final KeyValueStorage blockchainStorage;
  final VariablesStorage variablesStorage;
  final BlockHeaderFunctions blockHeaderFunctions;
  final boolean receiptCompaction;

  public KeyValueStoragePrefixedKeyBlockchainStorage(
      final KeyValueStorage blockchainStorage,
      final VariablesStorage variablesStorage,
      final BlockHeaderFunctions blockHeaderFunctions,
<span class="fc" id="L68">      final boolean receiptCompaction) {</span>
<span class="fc" id="L69">    this.blockchainStorage = blockchainStorage;</span>
<span class="fc" id="L70">    this.variablesStorage = variablesStorage;</span>
<span class="fc" id="L71">    this.blockHeaderFunctions = blockHeaderFunctions;</span>
<span class="fc" id="L72">    this.receiptCompaction = receiptCompaction;</span>
<span class="fc" id="L73">    migrateVariables();</span>
<span class="fc" id="L74">  }</span>

  @Override
  public Optional&lt;Hash&gt; getChainHead() {
<span class="fc" id="L78">    return variablesStorage.getChainHead();</span>
  }

  @Override
  public Collection&lt;Hash&gt; getForkHeads() {
<span class="fc" id="L83">    return variablesStorage.getForkHeads();</span>
  }

  @Override
  public Optional&lt;Hash&gt; getFinalized() {
<span class="fc" id="L88">    return variablesStorage.getFinalized();</span>
  }

  @Override
  public Optional&lt;Hash&gt; getSafeBlock() {
<span class="fc" id="L93">    return variablesStorage.getSafeBlock();</span>
  }

  @Override
  public Optional&lt;BlockHeader&gt; getBlockHeader(final Hash blockHash) {
<span class="fc" id="L98">    return get(BLOCK_HEADER_PREFIX, blockHash)</span>
<span class="fc" id="L99">        .map(b -&gt; BlockHeader.readFrom(RLP.input(b), blockHeaderFunctions));</span>
  }

  @Override
  public Optional&lt;BlockBody&gt; getBlockBody(final Hash blockHash) {
<span class="fc" id="L104">    return get(BLOCK_BODY_PREFIX, blockHash)</span>
<span class="fc" id="L105">        .map(bytes -&gt; BlockBody.readWrappedBodyFrom(RLP.input(bytes), blockHeaderFunctions));</span>
  }

  @Override
  public Optional&lt;List&lt;TransactionReceipt&gt;&gt; getTransactionReceipts(final Hash blockHash) {
<span class="fc" id="L110">    return get(TRANSACTION_RECEIPTS_PREFIX, blockHash).map(this::rlpDecodeTransactionReceipts);</span>
  }

  @Override
  public Optional&lt;Hash&gt; getBlockHash(final long blockNumber) {
<span class="fc" id="L115">    return get(BLOCK_HASH_PREFIX, UInt256.valueOf(blockNumber)).map(this::bytesToHash);</span>
  }

  @Override
  public Optional&lt;Difficulty&gt; getTotalDifficulty(final Hash blockHash) {
<span class="fc" id="L120">    return get(TOTAL_DIFFICULTY_PREFIX, blockHash).map(b -&gt; Difficulty.wrap(Bytes32.wrap(b, 0)));</span>
  }

  @Override
  public Optional&lt;TransactionLocation&gt; getTransactionLocation(final Hash transactionHash) {
<span class="fc" id="L125">    return get(TRANSACTION_LOCATION_PREFIX, transactionHash)</span>
<span class="fc" id="L126">        .map(bytes -&gt; TransactionLocation.readFrom(RLP.input(bytes)));</span>
  }

  @Override
  public Updater updater() {
<span class="fc" id="L131">    return new Updater(</span>
<span class="fc" id="L132">        blockchainStorage.startTransaction(), variablesStorage.updater(), receiptCompaction);</span>
  }

  private List&lt;TransactionReceipt&gt; rlpDecodeTransactionReceipts(final Bytes bytes) {
<span class="fc" id="L136">    return RLP.input(bytes).readList(TransactionReceipt::readFrom);</span>
  }

  private Hash bytesToHash(final Bytes bytes) {
<span class="fc" id="L140">    return Hash.wrap(Bytes32.wrap(bytes, 0));</span>
  }

  Optional&lt;Bytes&gt; get(final Bytes prefix, final Bytes key) {
<span class="fc" id="L144">    return blockchainStorage.get(Bytes.concatenate(prefix, key).toArrayUnsafe()).map(Bytes::wrap);</span>
  }

  /**
   * One time migration of variables from the blockchain storage to the dedicated variable storage.
   * To avoid state inconsistency in case of a downgrade done without running the storage
   * revert-variables subcommand it fails giving the possibility to retry the downgrade procedure.
   */
  private void migrateVariables() {
<span class="fc" id="L153">    final var blockchainUpdater = updater();</span>
<span class="fc" id="L154">    final var variablesUpdater = variablesStorage.updater();</span>

<span class="fc" id="L156">    get(VARIABLES_PREFIX, CHAIN_HEAD_HASH.getBytes())</span>
<span class="fc" id="L157">        .map(this::bytesToHash)</span>
<span class="fc" id="L158">        .ifPresent(</span>
            bch -&gt;
<span class="fc" id="L160">                variablesStorage</span>
<span class="fc" id="L161">                    .getChainHead()</span>
<span class="fc" id="L162">                    .ifPresentOrElse(</span>
                        vch -&gt; {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                          if (!vch.equals(bch)) {</span>
<span class="nc" id="L165">                            logInconsistencyAndFail(CHAIN_HEAD_HASH, bch, vch);</span>
                          }
<span class="nc" id="L167">                        },</span>
                        () -&gt; {
<span class="fc" id="L169">                          variablesUpdater.setChainHead(bch);</span>
<span class="fc" id="L170">                          LOG.info(&quot;Migrated key {} to variables storage&quot;, CHAIN_HEAD_HASH);</span>
<span class="fc" id="L171">                        }));</span>

<span class="fc" id="L173">    get(VARIABLES_PREFIX, FINALIZED_BLOCK_HASH.getBytes())</span>
<span class="fc" id="L174">        .map(this::bytesToHash)</span>
<span class="fc" id="L175">        .ifPresent(</span>
            bfh -&gt; {
<span class="fc" id="L177">              variablesStorage</span>
<span class="fc" id="L178">                  .getFinalized()</span>
<span class="fc" id="L179">                  .ifPresentOrElse(</span>
                      vfh -&gt; {
<span class="nc bnc" id="L181" title="All 2 branches missed.">                        if (!vfh.equals(bfh)) {</span>
<span class="nc" id="L182">                          logInconsistencyAndFail(FINALIZED_BLOCK_HASH, bfh, vfh);</span>
                        }
<span class="nc" id="L184">                      },</span>
                      () -&gt; {
<span class="fc" id="L186">                        variablesUpdater.setFinalized(bfh);</span>
<span class="fc" id="L187">                        LOG.info(&quot;Migrated key {} to variables storage&quot;, FINALIZED_BLOCK_HASH);</span>
<span class="fc" id="L188">                      });</span>
<span class="fc" id="L189">            });</span>

<span class="fc" id="L191">    get(VARIABLES_PREFIX, SAFE_BLOCK_HASH.getBytes())</span>
<span class="fc" id="L192">        .map(this::bytesToHash)</span>
<span class="fc" id="L193">        .ifPresent(</span>
            bsh -&gt; {
<span class="fc" id="L195">              variablesStorage</span>
<span class="fc" id="L196">                  .getSafeBlock()</span>
<span class="fc" id="L197">                  .ifPresentOrElse(</span>
                      vsh -&gt; {
<span class="nc bnc" id="L199" title="All 2 branches missed.">                        if (!vsh.equals(bsh)) {</span>
<span class="nc" id="L200">                          logInconsistencyAndFail(SAFE_BLOCK_HASH, bsh, vsh);</span>
                        }
<span class="nc" id="L202">                      },</span>
                      () -&gt; {
<span class="fc" id="L204">                        variablesUpdater.setSafeBlock(bsh);</span>
<span class="fc" id="L205">                        LOG.info(&quot;Migrated key {} to variables storage&quot;, SAFE_BLOCK_HASH);</span>
<span class="fc" id="L206">                      });</span>
<span class="fc" id="L207">            });</span>

<span class="fc" id="L209">    get(VARIABLES_PREFIX, FORK_HEADS.getBytes())</span>
<span class="fc" id="L210">        .map(bytes -&gt; RLP.input(bytes).readList(in -&gt; this.bytesToHash(in.readBytes32())))</span>
<span class="fc" id="L211">        .ifPresent(</span>
            bfh -&gt; {
<span class="fc" id="L213">              final var vfh = variablesStorage.getForkHeads();</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">              if (vfh.isEmpty()) {</span>
<span class="fc" id="L215">                variablesUpdater.setForkHeads(bfh);</span>
<span class="fc" id="L216">                LOG.info(&quot;Migrated key {} to variables storage&quot;, FORK_HEADS);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">              } else if (!List.copyOf(vfh).equals(bfh)) {</span>
<span class="nc" id="L218">                logInconsistencyAndFail(FORK_HEADS, bfh, vfh);</span>
              }
<span class="fc" id="L220">            });</span>

<span class="fc" id="L222">    get(Bytes.EMPTY, SEQ_NO_STORE.getBytes())</span>
<span class="fc" id="L223">        .ifPresent(</span>
            bsns -&gt; {
<span class="fc" id="L225">              variablesStorage</span>
<span class="fc" id="L226">                  .getLocalEnrSeqno()</span>
<span class="fc" id="L227">                  .ifPresentOrElse(</span>
                      vsns -&gt; {
<span class="nc bnc" id="L229" title="All 2 branches missed.">                        if (!vsns.equals(bsns)) {</span>
<span class="nc" id="L230">                          logInconsistencyAndFail(SEQ_NO_STORE, bsns, vsns);</span>
                        }
<span class="nc" id="L232">                      },</span>
                      () -&gt; {
<span class="fc" id="L234">                        variablesUpdater.setLocalEnrSeqno(bsns);</span>
<span class="fc" id="L235">                        LOG.info(&quot;Migrated key {} to variables storage&quot;, SEQ_NO_STORE);</span>
<span class="fc" id="L236">                      });</span>
<span class="fc" id="L237">            });</span>

<span class="fc" id="L239">    blockchainUpdater.removeVariables();</span>

<span class="fc" id="L241">    variablesUpdater.commit();</span>
<span class="fc" id="L242">    blockchainUpdater.commit();</span>
<span class="fc" id="L243">  }</span>

  private static void logInconsistencyAndFail(
      final VariablesStorage.Keys key, final Object bch, final Object vch) {
<span class="fc" id="L247">    LOG.error(</span>
        &quot;Inconsistency found when migrating {} to variables storage,&quot;
            + &quot; probably this is due to a downgrade done without running the `storage revert-variables`&quot;
            + &quot; subcommand first, see https://github.com/hyperledger/besu/pull/5471&quot;,
        key);
<span class="fc" id="L252">    throw new IllegalStateException(</span>
        key + &quot; mismatch: blockchain storage value=&quot; + bch + &quot;, variables storage value=&quot; + vch);
  }

  public static class Updater implements BlockchainStorage.Updater {

    private final KeyValueStorageTransaction blockchainTransaction;
    private final VariablesStorage.Updater variablesUpdater;
    private final boolean receiptCompaction;

    Updater(
        final KeyValueStorageTransaction blockchainTransaction,
        final VariablesStorage.Updater variablesUpdater,
<span class="fc" id="L265">        final boolean receiptCompaction) {</span>
<span class="fc" id="L266">      this.blockchainTransaction = blockchainTransaction;</span>
<span class="fc" id="L267">      this.variablesUpdater = variablesUpdater;</span>
<span class="fc" id="L268">      this.receiptCompaction = receiptCompaction;</span>
<span class="fc" id="L269">    }</span>

    @Override
    public void putBlockHeader(final Hash blockHash, final BlockHeader blockHeader) {
<span class="fc" id="L273">      set(BLOCK_HEADER_PREFIX, blockHash, RLP.encode(blockHeader::writeTo));</span>
<span class="fc" id="L274">    }</span>

    @Override
    public void putBlockBody(final Hash blockHash, final BlockBody blockBody) {
<span class="fc" id="L278">      set(BLOCK_BODY_PREFIX, blockHash, RLP.encode(blockBody::writeWrappedBodyTo));</span>
<span class="fc" id="L279">    }</span>

    @Override
    public void putTransactionLocation(
        final Hash transactionHash, final TransactionLocation transactionLocation) {
<span class="fc" id="L284">      set(TRANSACTION_LOCATION_PREFIX, transactionHash, RLP.encode(transactionLocation::writeTo));</span>
<span class="fc" id="L285">    }</span>

    @Override
    public void putTransactionReceipts(
        final Hash blockHash, final List&lt;TransactionReceipt&gt; transactionReceipts) {
<span class="fc" id="L290">      set(TRANSACTION_RECEIPTS_PREFIX, blockHash, rlpEncode(transactionReceipts));</span>
<span class="fc" id="L291">    }</span>

    @Override
    public void putBlockHash(final long blockNumber, final Hash blockHash) {
<span class="fc" id="L295">      set(BLOCK_HASH_PREFIX, UInt256.valueOf(blockNumber), blockHash);</span>
<span class="fc" id="L296">    }</span>

    @Override
    public void putTotalDifficulty(final Hash blockHash, final Difficulty totalDifficulty) {
<span class="fc" id="L300">      set(TOTAL_DIFFICULTY_PREFIX, blockHash, totalDifficulty);</span>
<span class="fc" id="L301">    }</span>

    @Override
    public void setChainHead(final Hash blockHash) {
<span class="fc" id="L305">      variablesUpdater.setChainHead(blockHash);</span>
<span class="fc" id="L306">    }</span>

    @Override
    public void setForkHeads(final Collection&lt;Hash&gt; forkHeadHashes) {
<span class="fc" id="L310">      variablesUpdater.setForkHeads(forkHeadHashes);</span>
<span class="fc" id="L311">    }</span>

    @Override
    public void setFinalized(final Hash blockHash) {
<span class="fc" id="L315">      variablesUpdater.setFinalized(blockHash);</span>
<span class="fc" id="L316">    }</span>

    @Override
    public void setSafeBlock(final Hash blockHash) {
<span class="fc" id="L320">      variablesUpdater.setSafeBlock(blockHash);</span>
<span class="fc" id="L321">    }</span>

    @Override
    public void removeBlockHash(final long blockNumber) {
<span class="fc" id="L325">      remove(BLOCK_HASH_PREFIX, UInt256.valueOf(blockNumber));</span>
<span class="fc" id="L326">    }</span>

    @Override
    public void removeBlockHeader(final Hash blockHash) {
<span class="fc" id="L330">      remove(BLOCK_HEADER_PREFIX, blockHash);</span>
<span class="fc" id="L331">    }</span>

    @Override
    public void removeBlockBody(final Hash blockHash) {
<span class="fc" id="L335">      remove(BLOCK_BODY_PREFIX, blockHash);</span>
<span class="fc" id="L336">    }</span>

    @Override
    public void removeTransactionReceipts(final Hash blockHash) {
<span class="fc" id="L340">      remove(TRANSACTION_RECEIPTS_PREFIX, blockHash);</span>
<span class="fc" id="L341">    }</span>

    @Override
    public void removeTransactionLocation(final Hash transactionHash) {
<span class="fc" id="L345">      remove(TRANSACTION_LOCATION_PREFIX, transactionHash);</span>
<span class="fc" id="L346">    }</span>

    @Override
    public void removeTotalDifficulty(final Hash blockHash) {
<span class="fc" id="L350">      remove(TOTAL_DIFFICULTY_PREFIX, blockHash);</span>
<span class="fc" id="L351">    }</span>

    @Override
    public void commit() {
<span class="fc" id="L355">      blockchainTransaction.commit();</span>
<span class="fc" id="L356">      variablesUpdater.commit();</span>
<span class="fc" id="L357">    }</span>

    @Override
    public void rollback() {
<span class="nc" id="L361">      variablesUpdater.rollback();</span>
<span class="nc" id="L362">      blockchainTransaction.rollback();</span>
<span class="nc" id="L363">    }</span>

    void set(final Bytes prefix, final Bytes key, final Bytes value) {
<span class="fc" id="L366">      blockchainTransaction.put(</span>
<span class="fc" id="L367">          Bytes.concatenate(prefix, key).toArrayUnsafe(), value.toArrayUnsafe());</span>
<span class="fc" id="L368">    }</span>

    private void remove(final Bytes prefix, final Bytes key) {
<span class="fc" id="L371">      blockchainTransaction.remove(Bytes.concatenate(prefix, key).toArrayUnsafe());</span>
<span class="fc" id="L372">    }</span>

    private Bytes rlpEncode(final List&lt;TransactionReceipt&gt; receipts) {
<span class="fc" id="L375">      return RLP.encode(</span>
          o -&gt;
<span class="fc" id="L377">              o.writeList(</span>
<span class="fc" id="L378">                  receipts, (r, rlpOutput) -&gt; r.writeToForStorage(rlpOutput, receiptCompaction)));</span>
    }

    private void removeVariables() {
<span class="fc" id="L382">      remove(VARIABLES_PREFIX, CHAIN_HEAD_HASH.getBytes());</span>
<span class="fc" id="L383">      remove(VARIABLES_PREFIX, FINALIZED_BLOCK_HASH.getBytes());</span>
<span class="fc" id="L384">      remove(VARIABLES_PREFIX, SAFE_BLOCK_HASH.getBytes());</span>
<span class="fc" id="L385">      remove(VARIABLES_PREFIX, FORK_HEADS.getBytes());</span>
<span class="fc" id="L386">      remove(Bytes.EMPTY, SEQ_NO_STORE.getBytes());</span>
<span class="fc" id="L387">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>