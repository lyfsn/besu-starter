<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockPropagationManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.sync</a> &gt; <span class="el_source">BlockPropagationManager.java</span></div><h1>BlockPropagationManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.sync;

import static org.hyperledger.besu.util.FutureUtils.exceptionallyCompose;

import org.hyperledger.besu.consensus.merge.ForkchoiceEvent;
import org.hyperledger.besu.consensus.merge.UnverifiedForkchoiceListener;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.chain.BadBlockCause;
import org.hyperledger.besu.ethereum.chain.BadBlockManager;
import org.hyperledger.besu.ethereum.chain.BlockAddedEvent;
import org.hyperledger.besu.ethereum.chain.BlockAddedEvent.EventType;
import org.hyperledger.besu.ethereum.chain.Blockchain;
import org.hyperledger.besu.ethereum.chain.MutableBlockchain;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;
import org.hyperledger.besu.ethereum.eth.manager.EthContext;
import org.hyperledger.besu.ethereum.eth.manager.EthMessage;
import org.hyperledger.besu.ethereum.eth.manager.EthPeer;
import org.hyperledger.besu.ethereum.eth.manager.task.RetryingGetBlockFromPeersTask;
import org.hyperledger.besu.ethereum.eth.messages.EthPV62;
import org.hyperledger.besu.ethereum.eth.messages.NewBlockHashesMessage;
import org.hyperledger.besu.ethereum.eth.messages.NewBlockHashesMessage.NewBlockHash;
import org.hyperledger.besu.ethereum.eth.messages.NewBlockMessage;
import org.hyperledger.besu.ethereum.eth.sync.state.PendingBlocksManager;
import org.hyperledger.besu.ethereum.eth.sync.state.SyncState;
import org.hyperledger.besu.ethereum.eth.sync.tasks.PersistBlockTask;
import org.hyperledger.besu.ethereum.mainnet.BlockHeaderValidator;
import org.hyperledger.besu.ethereum.mainnet.HeaderValidationMode;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.messages.DisconnectMessage.DisconnectReason;
import org.hyperledger.besu.ethereum.rlp.RLPException;
import org.hyperledger.besu.plugin.services.MetricsSystem;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import com.google.common.collect.Range;
import org.apache.tuweni.bytes.Bytes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class BlockPropagationManager implements UnverifiedForkchoiceListener {
<span class="fc" id="L75">  private static final Logger LOG = LoggerFactory.getLogger(BlockPropagationManager.class);</span>
  private final SynchronizerConfiguration config;
  private final ProtocolSchedule protocolSchedule;
  private final ProtocolContext protocolContext;
  private final EthContext ethContext;
  private final SyncState syncState;
  private final MetricsSystem metricsSystem;
  private final BlockBroadcaster blockBroadcaster;

<span class="fc" id="L84">  private final AtomicBoolean started = new AtomicBoolean(false);</span>
  private final ProcessingBlocksManager processingBlocksManager;
  private final PendingBlocksManager pendingBlocksManager;
  private final Duration getBlockTimeoutMillis;
<span class="fc" id="L88">  private Optional&lt;Long&gt; onBlockAddedSId = Optional.empty();</span>
  private Optional&lt;Long&gt; newBlockSId;
  private Optional&lt;Long&gt; newBlockHashesSId;

  BlockPropagationManager(
      final SynchronizerConfiguration config,
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final EthContext ethContext,
      final SyncState syncState,
      final PendingBlocksManager pendingBlocksManager,
      final MetricsSystem metricsSystem,
      final BlockBroadcaster blockBroadcaster) {
<span class="fc" id="L101">    this(</span>
        config,
        protocolSchedule,
        protocolContext,
        ethContext,
        syncState,
        pendingBlocksManager,
        metricsSystem,
        blockBroadcaster,
        new ProcessingBlocksManager());
<span class="fc" id="L111">  }</span>

  BlockPropagationManager(
      final SynchronizerConfiguration config,
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final EthContext ethContext,
      final SyncState syncState,
      final PendingBlocksManager pendingBlocksManager,
      final MetricsSystem metricsSystem,
      final BlockBroadcaster blockBroadcaster,
<span class="fc" id="L122">      final ProcessingBlocksManager processingBlocksManager) {</span>
<span class="fc" id="L123">    this.config = config;</span>
<span class="fc" id="L124">    this.protocolSchedule = protocolSchedule;</span>
<span class="fc" id="L125">    this.protocolContext = protocolContext;</span>
<span class="fc" id="L126">    this.ethContext = ethContext;</span>
<span class="fc" id="L127">    this.metricsSystem = metricsSystem;</span>
<span class="fc" id="L128">    this.blockBroadcaster = blockBroadcaster;</span>
<span class="fc" id="L129">    this.syncState = syncState;</span>
<span class="fc" id="L130">    this.pendingBlocksManager = pendingBlocksManager;</span>
<span class="fc" id="L131">    this.syncState.subscribeTTDReached(this::reactToTTDReachedEvent);</span>
<span class="fc" id="L132">    this.getBlockTimeoutMillis =</span>
<span class="fc" id="L133">        Duration.ofMillis(config.getPropagationManagerGetBlockTimeoutMillis());</span>
<span class="fc" id="L134">    this.processingBlocksManager = processingBlocksManager;</span>
<span class="fc" id="L135">  }</span>

  public void start() {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    if (started.compareAndSet(false, true)) {</span>
<span class="fc" id="L139">      setupListeners();</span>
    } else {
<span class="nc" id="L141">      throw new IllegalStateException(</span>
<span class="nc" id="L142">          &quot;Attempt to start an already started &quot; + this.getClass().getSimpleName() + &quot;.&quot;);</span>
    }
<span class="fc" id="L144">  }</span>

  public void stop() {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">    if (started.get()) {</span>
<span class="fc" id="L148">      clearListeners();</span>
<span class="fc" id="L149">      started.set(false);</span>
    } else {
<span class="nc" id="L151">      LOG.debug(&quot;Attempted to stop when we are not even running...&quot;);</span>
    }
<span class="fc" id="L153">  }</span>

  public boolean isRunning() {
<span class="fc" id="L156">    return started.get();</span>
  }

  private void setupListeners() {
<span class="fc" id="L160">    onBlockAddedSId =</span>
<span class="fc" id="L161">        Optional.of(protocolContext.getBlockchain().observeBlockAdded(this::onBlockAdded));</span>
<span class="fc" id="L162">    newBlockSId =</span>
<span class="fc" id="L163">        Optional.of(</span>
<span class="fc" id="L164">            ethContext</span>
<span class="fc" id="L165">                .getEthMessages()</span>
<span class="fc" id="L166">                .subscribe(EthPV62.NEW_BLOCK, this::handleNewBlockFromNetwork));</span>
<span class="fc" id="L167">    newBlockHashesSId =</span>
<span class="fc" id="L168">        Optional.of(</span>
<span class="fc" id="L169">            ethContext</span>
<span class="fc" id="L170">                .getEthMessages()</span>
<span class="fc" id="L171">                .subscribe(EthPV62.NEW_BLOCK_HASHES, this::handleNewBlockHashesFromNetwork));</span>
<span class="fc" id="L172">  }</span>

  private void clearListeners() {
<span class="fc" id="L175">    onBlockAddedSId.ifPresent(id -&gt; protocolContext.getBlockchain().removeObserver(id));</span>
<span class="fc" id="L176">    newBlockSId.ifPresent(id -&gt; ethContext.getEthMessages().unsubscribe(id, EthPV62.NEW_BLOCK));</span>
<span class="fc" id="L177">    newBlockHashesSId.ifPresent(</span>
<span class="fc" id="L178">        id -&gt; ethContext.getEthMessages().unsubscribe(id, EthPV62.NEW_BLOCK_HASHES));</span>
<span class="fc" id="L179">    onBlockAddedSId = Optional.empty();</span>
<span class="fc" id="L180">    newBlockSId = Optional.empty();</span>
<span class="fc" id="L181">    newBlockHashesSId = Optional.empty();</span>
<span class="fc" id="L182">  }</span>

  private void onBlockAdded(final BlockAddedEvent blockAddedEvent) {
    // Check to see if any of our pending blocks are now ready for import
<span class="fc" id="L186">    final Block newBlock = blockAddedEvent.getBlock();</span>
<span class="fc" id="L187">    LOG.atTrace()</span>
<span class="fc" id="L188">        .setMessage(&quot;Block added event type {} for block {}. Current status {}&quot;)</span>
<span class="fc" id="L189">        .addArgument(blockAddedEvent::getEventType)</span>
<span class="fc" id="L190">        .addArgument(newBlock::toLogString)</span>
<span class="fc" id="L191">        .addArgument(this)</span>
<span class="fc" id="L192">        .log();</span>

    // If there is no children to process, maybe try non announced blocks
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (!maybeProcessPendingChildrenBlocks(newBlock)) {</span>
<span class="fc" id="L196">      LOG.atTrace()</span>
<span class="fc" id="L197">          .setMessage(&quot;There are no pending blocks ready to import for block {}&quot;)</span>
<span class="fc" id="L198">          .addArgument(newBlock::toLogString)</span>
<span class="fc" id="L199">          .log();</span>
<span class="fc" id="L200">      maybeProcessNonAnnouncedBlocks(newBlock);</span>
    }

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    if (blockAddedEvent.getEventType().equals(EventType.HEAD_ADVANCED)) {</span>
<span class="fc" id="L204">      final long head = protocolContext.getBlockchain().getChainHeadBlockNumber();</span>
<span class="fc" id="L205">      final long cutoff = head + config.getBlockPropagationRange().lowerEndpoint();</span>
<span class="fc" id="L206">      pendingBlocksManager.purgeBlocksOlderThan(cutoff);</span>
    }
<span class="fc" id="L208">  }</span>

  /**
   * Process pending Children if any
   *
   * @param block the block to process the children
   * @return true if block has any pending child
   */
  private boolean maybeProcessPendingChildrenBlocks(final Block block) {
    final List&lt;Block&gt; readyForImport;
<span class="fc" id="L218">    synchronized (pendingBlocksManager) {</span>
      // Remove block from pendingBlocks list
<span class="fc" id="L220">      pendingBlocksManager.deregisterPendingBlock(block);</span>

      // Import any pending blocks that are children of the newly added block
<span class="fc" id="L223">      readyForImport = pendingBlocksManager.childrenOf(block.getHash());</span>
<span class="fc" id="L224">    }</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">    if (!readyForImport.isEmpty()) {</span>

<span class="fc" id="L228">      LOG.atTrace()</span>
<span class="fc" id="L229">          .setMessage(&quot;Ready to import pending blocks found [{}] for block {}&quot;)</span>
<span class="fc" id="L230">          .addArgument(</span>
              () -&gt;
<span class="nc" id="L232">                  readyForImport.stream().map(Block::toLogString).collect(Collectors.joining(&quot;, &quot;)))</span>
<span class="fc" id="L233">          .addArgument(block::toLogString)</span>
<span class="fc" id="L234">          .log();</span>

<span class="fc" id="L236">      final Supplier&lt;CompletableFuture&lt;List&lt;Block&gt;&gt;&gt; importBlocksTask =</span>
<span class="fc" id="L237">          PersistBlockTask.forUnorderedBlocks(</span>
              protocolSchedule,
              protocolContext,
              ethContext,
              readyForImport,
              HeaderValidationMode.FULL,
              metricsSystem);
<span class="fc" id="L244">      ethContext</span>
<span class="fc" id="L245">          .getScheduler()</span>
<span class="fc" id="L246">          .scheduleSyncWorkerTask(importBlocksTask)</span>
<span class="fc" id="L247">          .whenComplete(</span>
              (r, t) -&gt; {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                if (r != null) {</span>
<span class="fc" id="L250">                  LOG.info(</span>
                      &quot;Imported {} pending blocks: {}&quot;,
<span class="fc" id="L252">                      r.size(),</span>
<span class="fc" id="L253">                      r.stream().map(b -&gt; b.getHeader().getNumber()).collect(Collectors.toList()));</span>
                }
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">                if (t != null) {</span>
<span class="nc" id="L256">                  LOG.error(&quot;Error importing pending blocks&quot;, t);</span>
                }
<span class="fc" id="L258">              });</span>
    }
<span class="fc bfc" id="L260" title="All 2 branches covered.">    return !readyForImport.isEmpty();</span>
  }

  private void maybeProcessNonAnnouncedBlocks(final Block newBlock) {
<span class="fc" id="L264">    final long localHeadBlockNumber = protocolContext.getBlockchain().getChainHeadBlockNumber();</span>

<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (newBlock.getHeader().getNumber() &gt; localHeadBlockNumber) {</span>
<span class="nc" id="L267">      pendingBlocksManager</span>
<span class="nc" id="L268">          .lowestAnnouncedBlock()</span>
<span class="nc" id="L269">          .map(ProcessableBlockHeader::getNumber)</span>
<span class="nc" id="L270">          .ifPresent(</span>
              minAnnouncedBlockNumber -&gt; {
<span class="nc" id="L272">                final long distance = minAnnouncedBlockNumber - localHeadBlockNumber;</span>
<span class="nc" id="L273">                LOG.trace(</span>
                    &quot;Found lowest announced block {} with distance {}&quot;,
                    minAnnouncedBlockNumber,
<span class="nc" id="L276">                    distance);</span>

<span class="nc" id="L278">                final long firstNonAnnouncedBlockNumber = newBlock.getHeader().getNumber() + 1;</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">                if (distance &lt; config.getBlockPropagationRange().upperEndpoint()</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                    &amp;&amp; minAnnouncedBlockNumber &gt; firstNonAnnouncedBlockNumber) {</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">                  if (processingBlocksManager.addNonAnnouncedBlocks(firstNonAnnouncedBlockNumber)) {</span>
<span class="nc" id="L284">                    retrieveNonAnnouncedBlock(firstNonAnnouncedBlockNumber);</span>
                  }
                }
<span class="nc" id="L287">              });</span>
    }
<span class="fc" id="L289">  }</span>

  private void handleNewBlockFromNetwork(final EthMessage message) {
<span class="fc" id="L292">    final Blockchain blockchain = protocolContext.getBlockchain();</span>
<span class="fc" id="L293">    final NewBlockMessage newBlockMessage = NewBlockMessage.readFrom(message.getData());</span>
    try {
<span class="fc" id="L295">      final Block block = newBlockMessage.block(protocolSchedule);</span>
<span class="fc" id="L296">      LOG.atTrace()</span>
<span class="fc" id="L297">          .setMessage(&quot;New block from network {} from peer {}. Current status {}&quot;)</span>
<span class="fc" id="L298">          .addArgument(block::toLogString)</span>
<span class="fc" id="L299">          .addArgument(message::getPeer)</span>
<span class="fc" id="L300">          .addArgument(this)</span>
<span class="fc" id="L301">          .log();</span>

<span class="fc" id="L303">      final Difficulty totalDifficulty = newBlockMessage.totalDifficulty(protocolSchedule);</span>

<span class="fc" id="L305">      message.getPeer().chainState().updateForAnnouncedBlock(block.getHeader(), totalDifficulty);</span>

      // Return early if we don't care about this block
<span class="fc" id="L308">      final long localChainHeight = protocolContext.getBlockchain().getChainHeadBlockNumber();</span>
<span class="fc" id="L309">      final long bestChainHeight = syncState.bestChainHeight(localChainHeight);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">      if (!shouldImportBlockAtHeight(</span>
<span class="fc" id="L311">          block.getHeader().getNumber(), localChainHeight, bestChainHeight)) {</span>
<span class="fc" id="L312">        LOG.atTrace()</span>
<span class="fc" id="L313">            .setMessage(</span>
                &quot;Do not import new block from network {}, current chain heights are: local {}, best {}&quot;)
<span class="fc" id="L315">            .addArgument(block::toLogString)</span>
<span class="fc" id="L316">            .addArgument(localChainHeight)</span>
<span class="fc" id="L317">            .addArgument(bestChainHeight)</span>
<span class="fc" id="L318">            .log();</span>
<span class="fc" id="L319">        return;</span>
      }
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      if (pendingBlocksManager.contains(block.getHash())) {</span>
<span class="nc" id="L322">        LOG.atTrace()</span>
<span class="nc" id="L323">            .setMessage(&quot;New block from network {} is already pending&quot;)</span>
<span class="nc" id="L324">            .addArgument(block::toLogString)</span>
<span class="nc" id="L325">            .log();</span>
<span class="nc" id="L326">        return;</span>
      }
<span class="fc bfc" id="L328" title="All 2 branches covered.">      if (blockchain.contains(block.getHash())) {</span>
<span class="fc" id="L329">        LOG.atTrace()</span>
<span class="fc" id="L330">            .setMessage(&quot;New block from network {} is already present&quot;)</span>
<span class="fc" id="L331">            .addArgument(block::toLogString)</span>
<span class="fc" id="L332">            .log();</span>
<span class="fc" id="L333">        return;</span>
      }

<span class="fc" id="L336">      importOrSavePendingBlock(block, message.getPeer().nodeId());</span>
<span class="nc" id="L337">    } catch (final RLPException e) {</span>
<span class="nc" id="L338">      LOG.debug(</span>
          &quot;Malformed NEW_BLOCK message received from peer (BREACH_OF_PROTOCOL), disconnecting: {}&quot;,
<span class="nc" id="L340">          message.getPeer(),</span>
          e);
<span class="nc" id="L342">      message.getPeer().disconnect(DisconnectReason.BREACH_OF_PROTOCOL_MALFORMED_MESSAGE_RECEIVED);</span>
<span class="fc" id="L343">    }</span>
<span class="fc" id="L344">  }</span>

  private void handleNewBlockHashesFromNetwork(final EthMessage message) {
<span class="fc" id="L347">    final Blockchain blockchain = protocolContext.getBlockchain();</span>
<span class="fc" id="L348">    final NewBlockHashesMessage newBlockHashesMessage =</span>
<span class="fc" id="L349">        NewBlockHashesMessage.readFrom(message.getData());</span>
    try {
      // Register announced blocks
<span class="fc" id="L352">      final List&lt;NewBlockHash&gt; announcedBlocks =</span>
<span class="fc" id="L353">          Lists.newArrayList(newBlockHashesMessage.getNewHashes());</span>
<span class="fc" id="L354">      LOG.atTrace()</span>
<span class="fc" id="L355">          .setMessage(&quot;New block hashes from network {} from peer {}. Current status {}&quot;)</span>
<span class="pc" id="L356">          .addArgument(() -&gt; toLogString(announcedBlocks))</span>
<span class="fc" id="L357">          .addArgument(message::getPeer)</span>
<span class="fc" id="L358">          .addArgument(this)</span>
<span class="fc" id="L359">          .log();</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">      for (final NewBlockHash announcedBlock : announcedBlocks) {</span>
<span class="fc" id="L362">        message.getPeer().registerKnownBlock(announcedBlock.hash());</span>
<span class="fc" id="L363">        message.getPeer().registerHeight(announcedBlock.hash(), announcedBlock.number());</span>
<span class="fc" id="L364">      }</span>

      // Filter announced blocks for blocks we care to import
<span class="fc" id="L367">      final long localChainHeight = protocolContext.getBlockchain().getChainHeadBlockNumber();</span>
<span class="fc" id="L368">      final long bestChainHeight = syncState.bestChainHeight(localChainHeight);</span>
<span class="fc" id="L369">      final List&lt;NewBlockHash&gt; relevantAnnouncements =</span>
<span class="fc" id="L370">          announcedBlocks.stream()</span>
<span class="fc" id="L371">              .filter(a -&gt; shouldImportBlockAtHeight(a.number(), localChainHeight, bestChainHeight))</span>
<span class="fc" id="L372">              .collect(Collectors.toList());</span>

      // Filter for blocks we don't yet know about
<span class="fc" id="L375">      final List&lt;NewBlockHash&gt; newBlocks = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">      for (final NewBlockHash announcedBlock : relevantAnnouncements) {</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (pendingBlocksManager.contains(announcedBlock.hash())) {</span>
<span class="nc" id="L378">          LOG.trace(&quot;New block hash from network {} is already pending&quot;, announcedBlock);</span>
<span class="nc" id="L379">          continue;</span>
        }
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (processingBlocksManager.alreadyImporting(announcedBlock.hash())) {</span>
<span class="nc" id="L382">          LOG.trace(&quot;New block hash from network {} is already importing&quot;, announcedBlock);</span>
<span class="nc" id="L383">          continue;</span>
        }
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (blockchain.contains(announcedBlock.hash())) {</span>
<span class="fc" id="L386">          LOG.trace(&quot;New block hash from network {} was already imported&quot;, announcedBlock);</span>
<span class="fc" id="L387">          continue;</span>
        }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (processingBlocksManager.addRequestedBlock(announcedBlock.hash())) {</span>
<span class="fc" id="L390">          newBlocks.add(announcedBlock);</span>
        } else {
<span class="nc" id="L392">          LOG.trace(&quot;New block hash from network {} was already requested&quot;, announcedBlock);</span>
        }
<span class="fc" id="L394">      }</span>

      // Process known blocks we care about
<span class="fc bfc" id="L397" title="All 2 branches covered.">      for (final NewBlockHash newBlock : newBlocks) {</span>
<span class="fc" id="L398">        processAnnouncedBlock(message.getPeer(), newBlock);</span>
<span class="fc" id="L399">      }</span>
<span class="nc" id="L400">    } catch (final RLPException e) {</span>
<span class="nc" id="L401">      LOG.debug(</span>
          &quot;Malformed NEW_BLOCK_HASHES message received from peer (BREACH_OF_PROTOCOL), disconnecting: {}&quot;,
<span class="nc" id="L403">          message.getPeer(),</span>
          e);
<span class="nc" id="L405">      message.getPeer().disconnect(DisconnectReason.BREACH_OF_PROTOCOL_MALFORMED_MESSAGE_RECEIVED);</span>
<span class="fc" id="L406">    }</span>
<span class="fc" id="L407">  }</span>

  private CompletableFuture&lt;Block&gt; retrieveNonAnnouncedBlock(final long blockNumber) {
<span class="nc" id="L410">    LOG.trace(&quot;Retrieve non announced block {} from peers&quot;, blockNumber);</span>
<span class="nc" id="L411">    return getBlockFromPeers(Optional.empty(), blockNumber, Optional.empty());</span>
  }

  private CompletableFuture&lt;Block&gt; processAnnouncedBlock(
      final EthPeer peer, final NewBlockHash blockHash) {
<span class="fc" id="L416">    LOG.trace(&quot;Retrieve announced block by header {} from peers&quot;, blockHash);</span>
<span class="fc" id="L417">    return getBlockFromPeers(Optional.of(peer), blockHash.number(), Optional.of(blockHash.hash()));</span>
  }

  private void requestParentBlock(final Block block) {
<span class="fc" id="L421">    final BlockHeader blockHeader = block.getHeader();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">    if (processingBlocksManager.addRequestedBlock(blockHeader.getParentHash())) {</span>
<span class="fc" id="L423">      retrieveParentBlock(blockHeader);</span>
    } else {
<span class="fc" id="L425">      LOG.debug(&quot;Parent block with hash {} is already requested&quot;, blockHeader.getParentHash());</span>
    }
<span class="fc" id="L427">  }</span>

  private CompletableFuture&lt;Block&gt; retrieveParentBlock(final BlockHeader blockHeader) {
<span class="fc" id="L430">    final long targetParentBlockNumber = blockHeader.getNumber() - 1L;</span>
<span class="fc" id="L431">    final Hash targetParentBlockHash = blockHeader.getParentHash();</span>
<span class="fc" id="L432">    LOG.info(&quot;Retrieving parent {} of block {}&quot;, targetParentBlockHash, blockHeader.toLogString());</span>
<span class="fc" id="L433">    return getBlockFromPeers(</span>
<span class="fc" id="L434">        Optional.empty(), targetParentBlockNumber, Optional.of(targetParentBlockHash));</span>
  }

  private CompletableFuture&lt;Block&gt; getBlockFromPeers(
      final Optional&lt;EthPeer&gt; preferredPeer,
      final long blockNumber,
      final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="fc" id="L441">    return repeatableGetBlockFromPeer(preferredPeer, blockNumber, maybeBlockHash)</span>
<span class="fc" id="L442">        .whenComplete(</span>
            (block, throwable) -&gt; {
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">              if (block != null) {</span>
<span class="fc" id="L445">                LOG.atDebug()</span>
<span class="fc" id="L446">                    .setMessage(&quot;Successfully retrieved block {}&quot;)</span>
<span class="fc" id="L447">                    .addArgument(block::toLogString)</span>
<span class="fc" id="L448">                    .log();</span>
<span class="fc" id="L449">                processingBlocksManager.registerReceivedBlock(block);</span>
              } else {
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if (throwable != null) {</span>
<span class="nc" id="L452">                  LOG.warn(</span>
                      &quot;Failed to retrieve block &quot;
<span class="nc" id="L454">                          + logBlockNumberMaybeHash(blockNumber, maybeBlockHash),</span>
                      throwable);
                } else {
                  // this could happen if we give up at some point since we find that it make no
                  // sense to retry
<span class="nc" id="L459">                  LOG.atDebug()</span>
<span class="nc" id="L460">                      .setMessage(&quot;Block {} not retrieved&quot;)</span>
<span class="nc" id="L461">                      .addArgument(() -&gt; logBlockNumberMaybeHash(blockNumber, maybeBlockHash))</span>
<span class="nc" id="L462">                      .log();</span>
                }
<span class="nc" id="L464">                processingBlocksManager.registerFailedGetBlock(blockNumber, maybeBlockHash);</span>
              }
<span class="fc" id="L466">            });</span>
  }

  private CompletableFuture&lt;Block&gt; repeatableGetBlockFromPeer(
      final Optional&lt;EthPeer&gt; preferredPeer,
      final long blockNumber,
      final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="fc" id="L473">    return exceptionallyCompose(</span>
<span class="fc" id="L474">            scheduleGetBlockFromPeers(preferredPeer, blockNumber, maybeBlockHash),</span>
<span class="fc" id="L475">            handleGetBlockErrors(blockNumber, maybeBlockHash))</span>
<span class="fc" id="L476">        .thenCompose(r -&gt; maybeRepeatGetBlock(blockNumber, maybeBlockHash));</span>
  }

  private Function&lt;Throwable, CompletionStage&lt;Block&gt;&gt; handleGetBlockErrors(
      final long blockNumber, final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="fc" id="L481">    return throwable -&gt; {</span>
<span class="fc" id="L482">      LOG.atDebug()</span>
<span class="fc" id="L483">          .setMessage(&quot;Temporary failure retrieving block {} from peers with error {}&quot;)</span>
<span class="pc" id="L484">          .addArgument(() -&gt; logBlockNumberMaybeHash(blockNumber, maybeBlockHash))</span>
<span class="fc" id="L485">          .addArgument(throwable)</span>
<span class="fc" id="L486">          .log();</span>
<span class="fc" id="L487">      return CompletableFuture.completedFuture(null);</span>
    };
  }

  private CompletableFuture&lt;Block&gt; maybeRepeatGetBlock(
      final long blockNumber, final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="fc" id="L493">    final MutableBlockchain blockchain = protocolContext.getBlockchain();</span>
<span class="fc" id="L494">    final Optional&lt;Block&gt; maybeBlock =</span>
        maybeBlockHash
<span class="fc" id="L496">            .map(hash -&gt; blockchain.getBlockByHash(hash))</span>
<span class="pc" id="L497">            .orElseGet(() -&gt; blockchain.getBlockByNumber(blockNumber));</span>

    // check if we got this block by other means
<span class="fc bfc" id="L500" title="All 2 branches covered.">    if (maybeBlock.isPresent()) {</span>
<span class="fc" id="L501">      final Block block = maybeBlock.get();</span>
<span class="fc" id="L502">      LOG.atDebug()</span>
<span class="fc" id="L503">          .setMessage(&quot;No need to retry to get block {} since it is already present&quot;)</span>
<span class="fc" id="L504">          .addArgument(block::toLogString)</span>
<span class="fc" id="L505">          .log();</span>
<span class="fc" id="L506">      return CompletableFuture.completedFuture(block);</span>
    }

<span class="fc" id="L509">    final long localChainHeight = blockchain.getChainHeadBlockNumber();</span>
<span class="fc" id="L510">    final long bestChainHeight = syncState.bestChainHeight(localChainHeight);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (!shouldImportBlockAtHeight(blockNumber, localChainHeight, bestChainHeight)) {</span>
<span class="nc" id="L512">      LOG.atDebug()</span>
<span class="nc" id="L513">          .setMessage(&quot;Not retrying to get block {} since we are too far from local chain head {}&quot;)</span>
<span class="nc" id="L514">          .addArgument(() -&gt; logBlockNumberMaybeHash(blockNumber, maybeBlockHash))</span>
<span class="nc" id="L515">          .addArgument(blockchain.getChainHead()::toLogString)</span>
<span class="nc" id="L516">          .log();</span>
<span class="nc" id="L517">      return CompletableFuture.completedFuture(null);</span>
    }

<span class="fc" id="L520">    LOG.atDebug()</span>
<span class="fc" id="L521">        .setMessage(&quot;Retrying to get block {}&quot;)</span>
<span class="pc" id="L522">        .addArgument(() -&gt; logBlockNumberMaybeHash(blockNumber, maybeBlockHash))</span>
<span class="fc" id="L523">        .log();</span>

<span class="fc" id="L525">    return ethContext</span>
<span class="fc" id="L526">        .getScheduler()</span>
<span class="fc" id="L527">        .scheduleSyncWorkerTask(</span>
<span class="fc" id="L528">            () -&gt; repeatableGetBlockFromPeer(Optional.empty(), blockNumber, maybeBlockHash));</span>
  }

  private CompletableFuture&lt;Block&gt; scheduleGetBlockFromPeers(
      final Optional&lt;EthPeer&gt; maybePreferredPeer,
      final long blockNumber,
      final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="fc" id="L535">    final RetryingGetBlockFromPeersTask getBlockTask =</span>
<span class="fc" id="L536">        RetryingGetBlockFromPeersTask.create(</span>
            protocolSchedule,
            ethContext,
            metricsSystem,
<span class="fc" id="L540">            Math.max(1, ethContext.getEthPeers().peerCount()),</span>
            maybeBlockHash,
            blockNumber);
<span class="fc" id="L543">    maybePreferredPeer.ifPresent(getBlockTask::assignPeer);</span>

<span class="fc" id="L545">    var future =</span>
        ethContext
<span class="fc" id="L547">            .getScheduler()</span>
<span class="fc" id="L548">            .scheduleSyncWorkerTask(getBlockTask::run)</span>
<span class="fc" id="L549">            .thenCompose(r -&gt; importOrSavePendingBlock(r.getResult(), r.getPeer().nodeId()));</span>

<span class="fc" id="L551">    ethContext.getScheduler().failAfterTimeout(future, getBlockTimeoutMillis);</span>

<span class="fc" id="L553">    return future;</span>
  }

  private void broadcastBlock(final Block block, final BlockHeader parent) {
<span class="fc" id="L557">    final Difficulty totalDifficulty =</span>
        protocolContext
<span class="fc" id="L559">            .getBlockchain()</span>
<span class="fc" id="L560">            .getTotalDifficultyByHash(parent.getHash())</span>
<span class="fc" id="L561">            .get()</span>
<span class="fc" id="L562">            .add(block.getHeader().getDifficulty());</span>
<span class="fc" id="L563">    blockBroadcaster.propagate(block, totalDifficulty);</span>
<span class="fc" id="L564">  }</span>

  @VisibleForTesting
  CompletableFuture&lt;Block&gt; importOrSavePendingBlock(final Block block, final Bytes nodeId) {
    // Synchronize to avoid race condition where block import event fires after the
    // blockchain.contains() check and before the block is registered, causing onBlockAdded() to be
    // invoked for the parent of this block before we are able to register it.
<span class="fc" id="L571">    LOG.atTrace()</span>
<span class="fc" id="L572">        .setMessage(&quot;Import or save pending block {}&quot;)</span>
<span class="fc" id="L573">        .addArgument(block::toLogString)</span>
<span class="fc" id="L574">        .log();</span>

<span class="fc bfc" id="L576" title="All 2 branches covered.">    if (!protocolContext.getBlockchain().contains(block.getHeader().getParentHash())) {</span>
      // Block isn't connected to local chain, save it to pending blocks collection
<span class="fc bfc" id="L578" title="All 2 branches covered.">      if (savePendingBlock(block, nodeId)) {</span>
        // if block is saved as pending, try to resolve it
<span class="fc" id="L580">        maybeProcessPendingBlocks(block);</span>
      }
<span class="fc" id="L582">      return CompletableFuture.completedFuture(block);</span>
    }

<span class="fc bfc" id="L585" title="All 2 branches covered.">    if (!processingBlocksManager.addImportingBlock(block.getHash())) {</span>
<span class="fc" id="L586">      LOG.atTrace()</span>
<span class="fc" id="L587">          .setMessage(&quot;We're already importing this block {}&quot;)</span>
<span class="fc" id="L588">          .addArgument(block::toLogString)</span>
<span class="fc" id="L589">          .log();</span>
<span class="fc" id="L590">      return CompletableFuture.completedFuture(block);</span>
    }

<span class="fc bfc" id="L593" title="All 2 branches covered.">    if (protocolContext.getBlockchain().contains(block.getHash())) {</span>
<span class="fc" id="L594">      LOG.atTrace()</span>
<span class="fc" id="L595">          .setMessage(&quot;We've already imported this block {}&quot;)</span>
<span class="fc" id="L596">          .addArgument(block::toLogString)</span>
<span class="fc" id="L597">          .log();</span>
<span class="fc" id="L598">      processingBlocksManager.registerBlockImportDone(block.getHash());</span>
<span class="fc" id="L599">      return CompletableFuture.completedFuture(block);</span>
    }

<span class="fc" id="L602">    final BlockHeader parent =</span>
        protocolContext
<span class="fc" id="L604">            .getBlockchain()</span>
<span class="fc" id="L605">            .getBlockHeader(block.getHeader().getParentHash())</span>
<span class="fc" id="L606">            .orElseThrow(</span>
                () -&gt;
<span class="nc" id="L608">                    new IllegalArgumentException(</span>
                        &quot;Incapable of retrieving header from non-existent parent of &quot;
<span class="nc" id="L610">                            + block.toLogString()));</span>
<span class="fc" id="L611">    final ProtocolSpec protocolSpec = protocolSchedule.getByBlockHeader(block.getHeader());</span>
<span class="fc" id="L612">    final BlockHeaderValidator blockHeaderValidator = protocolSpec.getBlockHeaderValidator();</span>
<span class="fc" id="L613">    final BadBlockManager badBlockManager = protocolContext.getBadBlockManager();</span>
<span class="fc" id="L614">    return ethContext</span>
<span class="fc" id="L615">        .getScheduler()</span>
<span class="fc" id="L616">        .scheduleSyncWorkerTask(</span>
            () -&gt;
<span class="fc" id="L618">                validateAndProcessPendingBlock(</span>
                    blockHeaderValidator, block, parent, badBlockManager));
  }

  /**
   * Save the given block.
   *
   * @param block the block to track
   * @param nodeId node that sent the block
   * @return true if the block was added (was not previously present)
   */
  private boolean savePendingBlock(final Block block, final Bytes nodeId) {
<span class="fc" id="L630">    synchronized (pendingBlocksManager) {</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">      if (pendingBlocksManager.registerPendingBlock(block, nodeId)) {</span>
<span class="fc" id="L632">        LOG.info(</span>
            &quot;Saved announced block for future import {} - {} saved block(s)&quot;,
<span class="fc" id="L634">            block.toLogString(),</span>
<span class="fc" id="L635">            pendingBlocksManager.size());</span>
<span class="fc" id="L636">        return true;</span>
      }
<span class="fc" id="L638">      return false;</span>
    }
  }

  /**
   * Try to request the lowest ancestor for the given pending block or process the descendants if
   * the ancestor is already in the chain
   */
  private void maybeProcessPendingBlocks(final Block block) {
    // Try to get the lowest ancestor pending for this block, so we can import it
<span class="fc" id="L648">    final Optional&lt;Block&gt; lowestPending = pendingBlocksManager.pendingAncestorBlockOf(block);</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">    if (lowestPending.isPresent()) {</span>
<span class="fc" id="L650">      final Block lowestPendingBlock = lowestPending.get();</span>
      // If the parent of the lowest ancestor is not in the chain, request it.
<span class="fc" id="L652">      if (!protocolContext</span>
<span class="fc" id="L653">          .getBlockchain()</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">          .contains(lowestPendingBlock.getHeader().getParentHash())) {</span>
<span class="fc" id="L655">        requestParentBlock(lowestPendingBlock);</span>
      } else {
<span class="nc" id="L657">        LOG.trace(&quot;Parent block is already in the chain&quot;);</span>
        // if the parent is already imported, process its children
<span class="nc" id="L659">        maybeProcessPendingChildrenBlocks(lowestPendingBlock);</span>
      }
    }
<span class="fc" id="L662">  }</span>

  private CompletableFuture&lt;Block&gt; validateAndProcessPendingBlock(
      final BlockHeaderValidator blockHeaderValidator,
      final Block block,
      final BlockHeader parent,
      final BadBlockManager badBlockManager) {
<span class="fc" id="L669">    final HeaderValidationMode validationMode = HeaderValidationMode.FULL;</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">    if (blockHeaderValidator.validateHeader(</span>
<span class="fc" id="L671">        block.getHeader(), parent, protocolContext, validationMode)) {</span>
<span class="fc" id="L672">      ethContext.getScheduler().scheduleSyncWorkerTask(() -&gt; broadcastBlock(block, parent));</span>
<span class="fc" id="L673">      return runImportTask(block);</span>
    } else {
<span class="fc" id="L675">      processingBlocksManager.registerBlockImportDone(block.getHash());</span>
<span class="fc" id="L676">      final String description = String.format(&quot;Failed header validation (%s)&quot;, validationMode);</span>
<span class="fc" id="L677">      badBlockManager.addBadBlock(block, BadBlockCause.fromValidationFailure(description));</span>
<span class="fc" id="L678">      LOG.warn(</span>
          &quot;Added to bad block manager for invalid header, failed to import announced block {}&quot;,
<span class="fc" id="L680">          block.toLogString());</span>
<span class="fc" id="L681">      return CompletableFuture.completedFuture(block);</span>
    }
  }

  private CompletableFuture&lt;Block&gt; runImportTask(final Block block) {
<span class="fc" id="L686">    final PersistBlockTask importTask =</span>
<span class="fc" id="L687">        PersistBlockTask.create(</span>
            protocolSchedule,
            protocolContext,
            ethContext,
            block,
            HeaderValidationMode.NONE,
            metricsSystem);
<span class="fc" id="L694">    return importTask</span>
<span class="fc" id="L695">        .run()</span>
<span class="fc" id="L696">        .whenComplete(</span>
            (result, throwable) -&gt; {
<span class="fc" id="L698">              processingBlocksManager.registerBlockImportDone(block.getHash());</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">              if (throwable != null) {</span>
<span class="nc" id="L700">                LOG.warn(&quot;Failed to import announced block {}&quot;, block.toLogString());</span>
              }
<span class="fc" id="L702">            });</span>
  }

  // Only import blocks within a certain range of our head and sync target
  private boolean shouldImportBlockAtHeight(
      final long blockNumber, final long localHeight, final long bestChainHeight) {
<span class="fc" id="L708">    final long distanceFromLocalHead = blockNumber - localHeight;</span>
<span class="fc" id="L709">    final long distanceFromBestPeer = blockNumber - bestChainHeight;</span>
<span class="fc" id="L710">    final Range&lt;Long&gt; importRange = config.getBlockPropagationRange();</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">    return importRange.contains(distanceFromLocalHead)</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        &amp;&amp; importRange.contains(distanceFromBestPeer);</span>
  }

  private String toLogString(final Collection&lt;NewBlockHash&gt; newBlockHashs) {
<span class="nc" id="L716">    return newBlockHashs.stream()</span>
<span class="nc" id="L717">        .map(NewBlockHash::toString)</span>
<span class="nc" id="L718">        .collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));</span>
  }

  private void reactToTTDReachedEvent(final boolean ttdReached) {
<span class="pc bpc" id="L722" title="1 of 4 branches missed.">    if (started.get() &amp;&amp; ttdReached) {</span>
<span class="fc" id="L723">      LOG.info(&quot;Block propagation was running, then ttd reached&quot;);</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">    } else if (!started.get()) {</span>
<span class="fc" id="L725">      start();</span>
    }
<span class="fc" id="L727">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L731">    return &quot;BlockPropagationManager{&quot;</span>
        + processingBlocksManager
        + &quot;, pendingBlocksManager=&quot;
        + pendingBlocksManager
        + '}';
  }

  private String logBlockNumberMaybeHash(
      final long blockNumber, final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="nc" id="L740">    return blockNumber + maybeBlockHash.map(h -&gt; &quot; (&quot; + h + &quot;)&quot;).orElse(&quot;&quot;);</span>
  }

  @Override
  public void onNewUnverifiedForkchoice(final ForkchoiceEvent event) {
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">    if (event.hasValidFinalizedBlockHash()) {</span>
<span class="fc" id="L746">      stop();</span>
    }
<span class="fc" id="L748">  }</span>

<span class="fc" id="L750">  static class ProcessingBlocksManager {</span>
<span class="fc" id="L751">    private final Set&lt;Hash&gt; importingBlocks = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span>
<span class="fc" id="L752">    private final Set&lt;Hash&gt; requestedBlocks = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span>
<span class="fc" id="L753">    private final Set&lt;Long&gt; requestedNonAnnouncedBlocks =</span>
<span class="fc" id="L754">        Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;());</span>

    boolean addRequestedBlock(final Hash hash) {
<span class="fc" id="L757">      return requestedBlocks.add(hash);</span>
    }

    public boolean addNonAnnouncedBlocks(final long blockNumber) {
<span class="nc" id="L761">      return requestedNonAnnouncedBlocks.add(blockNumber);</span>
    }

    public boolean alreadyImporting(final Hash hash) {
<span class="fc" id="L765">      return importingBlocks.contains(hash);</span>
    }

    public synchronized void registerReceivedBlock(final Block block) {
<span class="fc" id="L769">      requestedBlocks.remove(block.getHash());</span>
<span class="fc" id="L770">      requestedNonAnnouncedBlocks.remove(block.getHeader().getNumber());</span>
<span class="fc" id="L771">    }</span>

    public synchronized void registerFailedGetBlock(
        final long blockNumber, final Optional&lt;Hash&gt; maybeBlockHash) {
<span class="nc" id="L775">      requestedNonAnnouncedBlocks.remove(blockNumber);</span>
<span class="nc" id="L776">      maybeBlockHash.ifPresent(requestedBlocks::remove);</span>
<span class="nc" id="L777">    }</span>

    public boolean addImportingBlock(final Hash hash) {
<span class="fc" id="L780">      return importingBlocks.add(hash);</span>
    }

    public void registerBlockImportDone(final Hash hash) {
<span class="fc" id="L784">      importingBlocks.remove(hash);</span>
<span class="fc" id="L785">    }</span>

    @Override
    public synchronized String toString() {
<span class="nc" id="L789">      return &quot;ProcessingBlocksManager{&quot;</span>
          + &quot;importingBlocks=&quot;
          + importingBlocks
          + &quot;, requestedBlocks=&quot;
          + requestedBlocks
          + &quot;, requestedNonAnnouncedBlocks=&quot;
          + requestedNonAnnouncedBlocks
          + '}';
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>