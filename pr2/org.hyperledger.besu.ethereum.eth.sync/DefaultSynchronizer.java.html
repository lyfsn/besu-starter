<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultSynchronizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.sync</a> &gt; <span class="el_source">DefaultSynchronizer.java</span></div><h1>DefaultSynchronizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.sync;

import static com.google.common.base.Preconditions.checkNotNull;

import org.hyperledger.besu.consensus.merge.ForkchoiceEvent;
import org.hyperledger.besu.consensus.merge.UnverifiedForkchoiceListener;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.core.Synchronizer;
import org.hyperledger.besu.ethereum.eth.manager.EthContext;
import org.hyperledger.besu.ethereum.eth.sync.checkpointsync.CheckpointDownloaderFactory;
import org.hyperledger.besu.ethereum.eth.sync.fastsync.FastSyncDownloader;
import org.hyperledger.besu.ethereum.eth.sync.fastsync.FastSyncState;
import org.hyperledger.besu.ethereum.eth.sync.fastsync.worldstate.FastDownloaderFactory;
import org.hyperledger.besu.ethereum.eth.sync.fullsync.FullSyncDownloader;
import org.hyperledger.besu.ethereum.eth.sync.fullsync.SyncTerminationCondition;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapDownloaderFactory;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.context.SnapSyncStatePersistenceManager;
import org.hyperledger.besu.ethereum.eth.sync.state.PendingBlocksManager;
import org.hyperledger.besu.ethereum.eth.sync.state.SyncState;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.storage.StorageProvider;
import org.hyperledger.besu.ethereum.trie.diffbased.bonsai.BonsaiWorldStateProvider;
import org.hyperledger.besu.ethereum.worldstate.WorldStateStorageCoordinator;
import org.hyperledger.besu.metrics.BesuMetricCategory;
import org.hyperledger.besu.plugin.data.SyncStatus;
import org.hyperledger.besu.plugin.services.BesuEvents;
import org.hyperledger.besu.plugin.services.BesuEvents.SyncStatusListener;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.util.log.FramedLogMessage;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Path;
import java.time.Clock;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

import org.apache.tuweni.bytes.Bytes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DefaultSynchronizer implements Synchronizer, UnverifiedForkchoiceListener {

<span class="fc" id="L63">  private static final Logger LOG = LoggerFactory.getLogger(DefaultSynchronizer.class);</span>

  private final SyncState syncState;
<span class="fc" id="L66">  private final AtomicBoolean running = new AtomicBoolean(false);</span>
  private final Optional&lt;BlockPropagationManager&gt; blockPropagationManager;
  private final Supplier&lt;Optional&lt;FastSyncDownloader&lt;?&gt;&gt;&gt; fastSyncFactory;
  private Optional&lt;FastSyncDownloader&lt;?&gt;&gt; fastSyncDownloader;
  private final Optional&lt;FullSyncDownloader&gt; fullSyncDownloader;
  private final ProtocolContext protocolContext;
  private final PivotBlockSelector pivotBlockSelector;
  private final SyncTerminationCondition terminationCondition;

  public DefaultSynchronizer(
      final SynchronizerConfiguration syncConfig,
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final BlockBroadcaster blockBroadcaster,
      final EthContext ethContext,
      final SyncState syncState,
      final Path dataDirectory,
      final StorageProvider storageProvider,
      final Clock clock,
      final MetricsSystem metricsSystem,
      final SyncTerminationCondition terminationCondition,
<span class="fc" id="L88">      final PivotBlockSelector pivotBlockSelector) {</span>
<span class="fc" id="L89">    this.syncState = syncState;</span>
<span class="fc" id="L90">    this.pivotBlockSelector = pivotBlockSelector;</span>
<span class="fc" id="L91">    this.protocolContext = protocolContext;</span>
<span class="fc" id="L92">    this.terminationCondition = terminationCondition;</span>

<span class="fc" id="L94">    ChainHeadTracker.trackChainHeadForPeers(</span>
        ethContext,
        protocolSchedule,
<span class="fc" id="L97">        protocolContext.getBlockchain(),</span>
        this::calculateTrailingPeerRequirements,
        metricsSystem);

<span class="fc" id="L101">    this.blockPropagationManager =</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        terminationCondition.shouldStopDownload()</span>
<span class="nc" id="L103">            ? Optional.empty()</span>
<span class="fc" id="L104">            : Optional.of(</span>
                new BlockPropagationManager(
                    syncConfig,
                    protocolSchedule,
                    protocolContext,
                    ethContext,
                    syncState,
                    new PendingBlocksManager(syncConfig),
                    metricsSystem,
                    blockBroadcaster));

<span class="fc" id="L115">    this.fullSyncDownloader =</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        terminationCondition.shouldStopDownload()</span>
<span class="nc" id="L117">            ? Optional.empty()</span>
<span class="fc" id="L118">            : Optional.of(</span>
                new FullSyncDownloader(
                    syncConfig,
                    protocolSchedule,
                    protocolContext,
                    ethContext,
                    syncState,
                    metricsSystem,
                    terminationCondition));

<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (SyncMode.FAST.equals(syncConfig.getSyncMode())) {</span>
<span class="fc" id="L129">      this.fastSyncFactory =</span>
          () -&gt;
<span class="fc" id="L131">              FastDownloaderFactory.create(</span>
                  pivotBlockSelector,
                  syncConfig,
                  dataDirectory,
                  protocolSchedule,
                  protocolContext,
                  metricsSystem,
                  ethContext,
                  worldStateStorageCoordinator,
                  syncState,
                  clock);
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">    } else if (SyncMode.isCheckpointSync(syncConfig.getSyncMode())) {</span>
<span class="nc" id="L143">      this.fastSyncFactory =</span>
          () -&gt;
<span class="nc" id="L145">              CheckpointDownloaderFactory.createCheckpointDownloader(</span>
                  new SnapSyncStatePersistenceManager(storageProvider),
                  pivotBlockSelector,
                  syncConfig,
                  dataDirectory,
                  protocolSchedule,
                  protocolContext,
                  metricsSystem,
                  ethContext,
                  worldStateStorageCoordinator,
                  syncState,
                  clock);
    } else {
<span class="fc" id="L158">      this.fastSyncFactory =</span>
          () -&gt;
<span class="fc" id="L160">              SnapDownloaderFactory.createSnapDownloader(</span>
                  new SnapSyncStatePersistenceManager(storageProvider),
                  pivotBlockSelector,
                  syncConfig,
                  dataDirectory,
                  protocolSchedule,
                  protocolContext,
                  metricsSystem,
                  ethContext,
                  worldStateStorageCoordinator,
                  syncState,
                  clock);
    }

    // create a non-resync fast sync downloader:
<span class="fc" id="L175">    this.fastSyncDownloader = this.fastSyncFactory.get();</span>

<span class="fc" id="L177">    metricsSystem.createLongGauge(</span>
        BesuMetricCategory.ETHEREUM,
        &quot;best_known_block_number&quot;,
        &quot;The estimated highest block available&quot;,
<span class="fc" id="L181">        syncState::bestChainHeight);</span>
<span class="fc" id="L182">    metricsSystem.createIntegerGauge(</span>
        BesuMetricCategory.SYNCHRONIZER,
        &quot;in_sync&quot;,
        &quot;Whether or not the local node has caught up to the best known peer&quot;,
<span class="nc bnc" id="L186" title="All 2 branches missed.">        () -&gt; getSyncStatus().isPresent() ? 0 : 1);</span>
<span class="fc" id="L187">  }</span>

  private TrailingPeerRequirements calculateTrailingPeerRequirements() {
<span class="fc" id="L190">    return fastSyncDownloader</span>
<span class="fc" id="L191">        .flatMap(FastSyncDownloader::calculateTrailingPeerRequirements)</span>
<span class="fc" id="L192">        .orElse(</span>
            fullSyncDownloader
<span class="fc" id="L194">                .map(FullSyncDownloader::calculateTrailingPeerRequirements)</span>
<span class="fc" id="L195">                .orElse(TrailingPeerRequirements.UNRESTRICTED));</span>
  }

  @Override
  public CompletableFuture&lt;Void&gt; start() {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (running.compareAndSet(false, true)) {</span>
<span class="fc" id="L201">      LOG.info(&quot;Starting synchronizer.&quot;);</span>
<span class="fc" id="L202">      blockPropagationManager.ifPresent(</span>
          manager -&gt; {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if (!manager.isRunning()) {</span>
<span class="fc" id="L205">              manager.start();</span>
            }
<span class="fc" id="L207">          });</span>

      CompletableFuture&lt;Void&gt; future;
<span class="fc bfc" id="L210" title="All 2 branches covered.">      if (fastSyncDownloader.isPresent()) {</span>
<span class="fc" id="L211">        future = fastSyncDownloader.get().start().thenCompose(this::handleSyncResult);</span>
      } else {
<span class="fc" id="L213">        syncState.markInitialSyncPhaseAsDone();</span>
<span class="fc" id="L214">        future = startFullSync();</span>
      }
<span class="fc" id="L216">      return future.thenApply(this::finalizeSync);</span>
    } else {
<span class="nc" id="L218">      throw new IllegalStateException(&quot;Attempt to start an already started synchronizer.&quot;);</span>
    }
  }

  @Override
  public void stop() {
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">    if (running.compareAndSet(true, false)) {</span>
<span class="fc" id="L225">      LOG.info(&quot;Stopping synchronizer&quot;);</span>
<span class="fc" id="L226">      fastSyncDownloader.ifPresent(FastSyncDownloader::stop);</span>
<span class="fc" id="L227">      fullSyncDownloader.ifPresent(FullSyncDownloader::stop);</span>
<span class="fc" id="L228">      blockPropagationManager.ifPresent(</span>
          manager -&gt; {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (manager.isRunning()) {</span>
<span class="fc" id="L231">              manager.stop();</span>
            }
<span class="fc" id="L233">          });</span>
    }
<span class="fc" id="L235">  }</span>

  @Override
<span class="fc" id="L238">  public void awaitStop() {}</span>

  private CompletableFuture&lt;Void&gt; handleSyncResult(final FastSyncState result) {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">    if (!running.get()) {</span>
      // We've been shutdown which will have triggered the fast sync future to complete
<span class="nc" id="L243">      return CompletableFuture.completedFuture(null);</span>
    }
<span class="fc" id="L245">    fastSyncDownloader.ifPresent(FastSyncDownloader::deleteFastSyncState);</span>
<span class="fc" id="L246">    result</span>
<span class="fc" id="L247">        .getPivotBlockHeader()</span>
<span class="fc" id="L248">        .ifPresent(</span>
<span class="fc" id="L249">            blockHeader -&gt; protocolContext.getWorldStateArchive().resetArchiveStateTo(blockHeader));</span>
<span class="fc" id="L250">    LOG.info(</span>
        &quot;Sync completed successfully with pivot block {}&quot;,
<span class="fc" id="L252">        result.getPivotBlockNumber().getAsLong());</span>
<span class="fc" id="L253">    pivotBlockSelector.close();</span>
<span class="fc" id="L254">    syncState.markInitialSyncPhaseAsDone();</span>

<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    if (terminationCondition.shouldContinueDownload()) {</span>
<span class="fc" id="L257">      return startFullSync();</span>
    } else {
<span class="nc" id="L259">      syncState.setReachedTerminalDifficulty(true);</span>
<span class="nc" id="L260">      return CompletableFuture.completedFuture(null);</span>
    }
  }

  private CompletableFuture&lt;Void&gt; startFullSync() {
<span class="fc" id="L265">    return fullSyncDownloader</span>
<span class="fc" id="L266">        .map(FullSyncDownloader::start)</span>
<span class="fc" id="L267">        .orElse(CompletableFuture.completedFuture(null))</span>
<span class="fc" id="L268">        .thenRun(</span>
            () -&gt; {
<span class="nc bnc" id="L270" title="All 2 branches missed.">              if (terminationCondition.shouldStopDownload()) {</span>
<span class="nc" id="L271">                syncState.setReachedTerminalDifficulty(true);</span>
              }
<span class="nc" id="L273">            });</span>
  }

  @Override
  public Optional&lt;SyncStatus&gt; getSyncStatus() {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">    if (!running.get()) {</span>
<span class="nc" id="L279">      return Optional.empty();</span>
    }
<span class="fc" id="L281">    return syncState.syncStatus();</span>
  }

  @Override
  public boolean resyncWorldState() {
    // if sync is running currently, stop it and delete the fast sync state
<span class="nc bnc" id="L287" title="All 4 branches missed.">    if (fastSyncDownloader.isPresent() &amp;&amp; running.get()) {</span>
<span class="nc" id="L288">      stop();</span>
<span class="nc" id="L289">      fastSyncDownloader.get().deleteFastSyncState();</span>
    }
    // recreate fast sync with resync and start
<span class="nc" id="L292">    this.syncState.markInitialSyncRestart();</span>
<span class="nc" id="L293">    this.syncState.markResyncNeeded();</span>
<span class="nc" id="L294">    this.fastSyncDownloader = this.fastSyncFactory.get();</span>
<span class="nc" id="L295">    start();</span>
<span class="nc" id="L296">    return true;</span>
  }

  @Override
  public boolean healWorldState(
      final Optional&lt;Address&gt; maybeAccountToRepair, final Bytes location) {
    // recreate fast sync with resync and start
<span class="nc bnc" id="L303" title="All 4 branches missed.">    if (fastSyncDownloader.isPresent() &amp;&amp; running.get()) {</span>
<span class="nc" id="L304">      stop();</span>
<span class="nc" id="L305">      fastSyncDownloader.get().deleteFastSyncState();</span>
    }

<span class="nc" id="L308">    LOG.atDebug()</span>
<span class="nc" id="L309">        .setMessage(&quot;heal stacktrace: \n{}&quot;)</span>
<span class="nc" id="L310">        .addArgument(</span>
            () -&gt; {
<span class="nc" id="L312">              var sw = new StringWriter();</span>
<span class="nc" id="L313">              new Exception().printStackTrace(new PrintWriter(sw, true));</span>
<span class="nc" id="L314">              return sw.toString();</span>
            })
<span class="nc" id="L316">        .log();</span>

<span class="nc" id="L318">    final List&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L319">    lines.add(&quot;Besu has identified a problem with its worldstate database.&quot;);</span>
<span class="nc" id="L320">    lines.add(&quot;Your node will fetch the correct data from peers to repair the problem.&quot;);</span>
<span class="nc" id="L321">    lines.add(&quot;Starting the sync pipeline...&quot;);</span>
<span class="nc" id="L322">    LOG.atInfo().setMessage(FramedLogMessage.generate(lines)).log();</span>

<span class="nc" id="L324">    this.syncState.markInitialSyncRestart();</span>
<span class="nc" id="L325">    this.syncState.markResyncNeeded();</span>
<span class="nc" id="L326">    maybeAccountToRepair.ifPresent(</span>
        address -&gt; {
<span class="nc bnc" id="L328" title="All 2 branches missed.">          if (this.protocolContext.getWorldStateArchive() instanceof BonsaiWorldStateProvider) {</span>
<span class="nc" id="L329">            ((BonsaiWorldStateProvider) this.protocolContext.getWorldStateArchive())</span>
<span class="nc" id="L330">                .prepareStateHealing(</span>
<span class="nc" id="L331">                    org.hyperledger.besu.datatypes.Address.wrap(address), location);</span>
          }
<span class="nc" id="L333">          this.syncState.markAccountToRepair(maybeAccountToRepair);</span>
<span class="nc" id="L334">        });</span>
<span class="nc" id="L335">    this.fastSyncDownloader = this.fastSyncFactory.get();</span>
<span class="nc" id="L336">    start();</span>
<span class="nc" id="L337">    return true;</span>
  }

  @Override
  public long subscribeSyncStatus(final SyncStatusListener listener) {
<span class="fc" id="L342">    checkNotNull(listener);</span>
<span class="fc" id="L343">    return syncState.subscribeSyncStatus(listener);</span>
  }

  @Override
  public boolean unsubscribeSyncStatus(final long subscriberId) {
<span class="nc" id="L348">    return syncState.unsubscribeSyncStatus(subscriberId);</span>
  }

  @Override
  public long subscribeInSync(final InSyncListener listener) {
<span class="nc" id="L353">    return syncState.subscribeInSync(listener);</span>
  }

  @Override
  public long subscribeInSync(final InSyncListener listener, final long syncTolerance) {
<span class="nc" id="L358">    return syncState.subscribeInSync(listener, syncTolerance);</span>
  }

  @Override
  public boolean unsubscribeInSync(final long listenerId) {
<span class="nc" id="L363">    return syncState.unsubscribeSyncStatus(listenerId);</span>
  }

  public long subscribeInitialSync(final BesuEvents.InitialSyncCompletionListener listener) {
<span class="fc" id="L367">    return syncState.subscribeCompletionReached(listener);</span>
  }

  public boolean unsubscribeInitialSync(final long listenerId) {
<span class="nc" id="L371">    return syncState.unsubscribeInitialConditionReached(listenerId);</span>
  }

  private Void finalizeSync(final Void unused) {
<span class="nc" id="L375">    LOG.info(&quot;Stopping block propagation.&quot;);</span>
<span class="nc" id="L376">    blockPropagationManager.ifPresent(BlockPropagationManager::stop);</span>
<span class="nc" id="L377">    LOG.info(&quot;Stopping the pruner.&quot;);</span>
<span class="nc" id="L378">    running.set(false);</span>
<span class="nc" id="L379">    return null;</span>
  }

  @Override
  public void onNewUnverifiedForkchoice(final ForkchoiceEvent event) {
<span class="nc bnc" id="L384" title="All 2 branches missed.">    if (this.blockPropagationManager.isPresent()) {</span>
<span class="nc" id="L385">      this.blockPropagationManager.get().onNewUnverifiedForkchoice(event);</span>
    }
<span class="nc" id="L387">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>