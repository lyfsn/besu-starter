<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.config</a> &gt; <span class="el_source">JsonUtil.java</span></div><h1>JsonUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.config;

import org.hyperledger.besu.util.number.PositiveNumber;

import java.io.File;
import java.io.IOException;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.OptionalLong;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonParser.Feature;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeType;
import com.fasterxml.jackson.databind.node.ObjectNode;

/** The Json util class. */
<span class="nc" id="L39">public class JsonUtil {</span>

  /**
   * Converts all the object keys (but none of the string values) to lowercase for easier lookup.
   * This is useful in cases such as the 'genesis.json' file where all keys are assumed to be case
   * insensitive.
   *
   * @param objectNode The ObjectNode to be normalized
   * @return a copy of the json object with all keys in lower case.
   */
  public static ObjectNode normalizeKeys(final ObjectNode objectNode) {
<span class="fc" id="L50">    final ObjectNode normalized = JsonUtil.createEmptyObjectNode();</span>
<span class="fc" id="L51">    objectNode</span>
<span class="fc" id="L52">        .fields()</span>
<span class="fc" id="L53">        .forEachRemaining(</span>
            entry -&gt; {
<span class="fc" id="L55">              final String key = entry.getKey();</span>
<span class="fc" id="L56">              final JsonNode value = entry.getValue();</span>
<span class="fc" id="L57">              final String normalizedKey = key.toLowerCase(Locale.US);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">              if (value instanceof ObjectNode) {</span>
<span class="fc" id="L59">                normalized.set(normalizedKey, normalizeKeys((ObjectNode) value));</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">              } else if (value instanceof ArrayNode) {</span>
<span class="fc" id="L61">                normalized.set(normalizedKey, normalizeKeysInArray((ArrayNode) value));</span>
              } else {
<span class="fc" id="L63">                normalized.set(normalizedKey, value);</span>
              }
<span class="fc" id="L65">            });</span>
<span class="fc" id="L66">    return normalized;</span>
  }

  private static ArrayNode normalizeKeysInArray(final ArrayNode arrayNode) {
<span class="fc" id="L70">    final ArrayNode normalizedArray = JsonUtil.createEmptyArrayNode();</span>
<span class="fc" id="L71">    arrayNode.forEach(</span>
        value -&gt; {
<span class="fc bfc" id="L73" title="All 2 branches covered.">          if (value instanceof ObjectNode) {</span>
<span class="fc" id="L74">            normalizedArray.add(normalizeKeys((ObjectNode) value));</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">          } else if (value instanceof ArrayNode) {</span>
<span class="fc" id="L76">            normalizedArray.add(normalizeKeysInArray((ArrayNode) value));</span>
          } else {
<span class="fc" id="L78">            normalizedArray.add(value);</span>
          }
<span class="fc" id="L80">        });</span>
<span class="fc" id="L81">    return normalizedArray;</span>
  }

  /**
   * Get the string representation of the value at {@code key}. For example, a numeric value like 5
   * will be returned as &quot;5&quot;.
   *
   * @param node The {@code ObjectNode} from which the value will be extracted.
   * @param key The key corresponding to the value to extract.
   * @return The value at the given key as a string if it exists.
   */
  public static Optional&lt;String&gt; getValueAsString(final ObjectNode node, final String key) {
<span class="fc" id="L93">    return getValue(node, key).map(JsonNode::asText);</span>
  }

  /**
   * Get the string representation of the value at {@code key}. For example, a numeric value like 5
   * will be returned as &quot;5&quot;.
   *
   * @param node The {@code ObjectNode} from which the value will be extracted.
   * @param key The key corresponding to the value to extract.
   * @param defaultValue The value to return if no value is found at {@code key}.
   * @return The value at the given key as a string if it exists, otherwise {@code defaultValue}
   */
  public static String getValueAsString(
      final ObjectNode node, final String key, final String defaultValue) {
<span class="fc" id="L107">    return getValueAsString(node, key).orElse(defaultValue);</span>
  }

  /**
   * Checks whether an {@code ObjectNode} contains the given key.
   *
   * @param node The {@code ObjectNode} to inspect.
   * @param key The key to check.
   * @return Returns true if the given key is set.
   */
  public static boolean hasKey(final ObjectNode node, final String key) {
<span class="fc" id="L118">    return node.has(key);</span>
  }

  /**
   * Returns textual (string) value at {@code key}. See {@link #getValueAsString} for retrieving
   * non-textual values in string form.
   *
   * @param node The {@code ObjectNode} from which the value will be extracted.
   * @param key The key corresponding to the value to extract.
   * @return The textual value at {@code key} if it exists.
   */
  public static Optional&lt;String&gt; getString(final ObjectNode node, final String key) {
<span class="fc" id="L130">    return getValue(node, key)</span>
<span class="fc" id="L131">        .filter(jsonNode -&gt; validateType(jsonNode, JsonNodeType.STRING))</span>
<span class="fc" id="L132">        .map(JsonNode::asText);</span>
  }

  /**
   * Returns textual (string) value at {@code key}. See {@link #getValueAsString} for retrieving
   * non-textual values in string form.
   *
   * @param node The {@code ObjectNode} from which the value will be extracted.
   * @param key The key corresponding to the value to extract.
   * @param defaultValue The value to return if no value is found at {@code key}.
   * @return The textual value at {@code key} if it exists, otherwise {@code defaultValue}
   */
  public static String getString(
      final ObjectNode node, final String key, final String defaultValue) {
<span class="fc" id="L146">    return getString(node, key).orElse(defaultValue);</span>
  }

  /**
   * Gets int.
   *
   * @param node the node
   * @param key the key
   * @return the int
   */
  public static OptionalInt getInt(final ObjectNode node, final String key) {
<span class="fc" id="L157">    return getValue(node, key)</span>
<span class="fc" id="L158">        .filter(jsonNode -&gt; validateType(jsonNode, JsonNodeType.NUMBER))</span>
<span class="fc" id="L159">        .filter(JsonUtil::validateInt)</span>
<span class="fc" id="L160">        .map(JsonNode::asInt)</span>
<span class="fc" id="L161">        .map(OptionalInt::of)</span>
<span class="fc" id="L162">        .orElse(OptionalInt.empty());</span>
  }

  /**
   * Gets int.
   *
   * @param node the node
   * @param key the key
   * @param defaultValue the default value
   * @return the int
   */
  public static int getInt(final ObjectNode node, final String key, final int defaultValue) {
<span class="fc" id="L174">    return getInt(node, key).orElse(defaultValue);</span>
  }

  /**
   * Gets positive int.
   *
   * @param node the node
   * @param key the key
   * @return the positive int
   */
  public static OptionalInt getPositiveInt(final ObjectNode node, final String key) {
<span class="fc" id="L185">    return getValueAsString(node, key)</span>
<span class="fc" id="L186">        .map(v -&gt; OptionalInt.of(parsePositiveInt(key, v)))</span>
<span class="fc" id="L187">        .orElse(OptionalInt.empty());</span>
  }

  /**
   * Gets positive int.
   *
   * @param node the node
   * @param key the key
   * @param defaultValue the default value
   * @return the positive int
   */
  public static int getPositiveInt(
      final ObjectNode node, final String key, final int defaultValue) {
<span class="fc" id="L200">    final String value = getValueAsString(node, key, String.valueOf(defaultValue));</span>
<span class="fc" id="L201">    return parsePositiveInt(key, value);</span>
  }

  private static int parsePositiveInt(final String key, final String value) {
    try {
<span class="fc" id="L206">      return PositiveNumber.fromString(value).getValue();</span>
<span class="fc" id="L207">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L208">      throw new IllegalArgumentException(</span>
          &quot;Invalid property value, &quot; + key + &quot; should be a positive integer: &quot; + value);
    }
  }

  /**
   * Gets long.
   *
   * @param json the json
   * @param key the key
   * @return the long
   */
  public static OptionalLong getLong(final ObjectNode json, final String key) {
<span class="fc" id="L221">    return getValue(json, key)</span>
<span class="fc" id="L222">        .filter(jsonNode -&gt; validateType(jsonNode, JsonNodeType.NUMBER))</span>
<span class="fc" id="L223">        .filter(JsonUtil::validateLong)</span>
<span class="fc" id="L224">        .map(JsonNode::asLong)</span>
<span class="fc" id="L225">        .map(OptionalLong::of)</span>
<span class="fc" id="L226">        .orElse(OptionalLong.empty());</span>
  }

  /**
   * Gets long.
   *
   * @param json the json
   * @param key the key
   * @param defaultValue the default value
   * @return the long
   */
  public static long getLong(final ObjectNode json, final String key, final long defaultValue) {
<span class="fc" id="L238">    return getLong(json, key).orElse(defaultValue);</span>
  }

  /**
   * Gets boolean.
   *
   * @param node the node
   * @param key the key
   * @return the boolean
   */
  public static Optional&lt;Boolean&gt; getBoolean(final ObjectNode node, final String key) {
<span class="fc" id="L249">    return getValue(node, key)</span>
<span class="fc" id="L250">        .filter(jsonNode -&gt; validateType(jsonNode, JsonNodeType.BOOLEAN))</span>
<span class="fc" id="L251">        .map(JsonNode::asBoolean);</span>
  }

  /**
   * Gets boolean.
   *
   * @param node the node
   * @param key the key
   * @param defaultValue the default value
   * @return the boolean
   */
  public static boolean getBoolean(
      final ObjectNode node, final String key, final boolean defaultValue) {
<span class="fc" id="L264">    return getBoolean(node, key).orElse(defaultValue);</span>
  }

  /**
   * Create empty object node object node.
   *
   * @return the object node
   */
  public static ObjectNode createEmptyObjectNode() {
<span class="fc" id="L273">    final ObjectMapper mapper = getObjectMapper();</span>
<span class="fc" id="L274">    return mapper.createObjectNode();</span>
  }

  /**
   * Create empty array node array node.
   *
   * @return the array node
   */
  public static ArrayNode createEmptyArrayNode() {
<span class="fc" id="L283">    final ObjectMapper mapper = getObjectMapper();</span>
<span class="fc" id="L284">    return mapper.createArrayNode();</span>
  }

  /**
   * Object node from map object node.
   *
   * @param map the map
   * @return the object node
   */
  public static ObjectNode objectNodeFromMap(final Map&lt;String, Object&gt; map) {
<span class="fc" id="L294">    return (ObjectNode) getObjectMapper().valueToTree(map);</span>
  }

  /**
   * Object node from string object node.
   *
   * @param jsonData the json data
   * @return the object node
   */
  public static ObjectNode objectNodeFromString(final String jsonData) {
<span class="fc" id="L304">    return objectNodeFromString(jsonData, false);</span>
  }

  /**
   * Object node from string object node.
   *
   * @param jsonData the json data
   * @param allowComments true to allow comments
   * @return the object node
   */
  public static ObjectNode objectNodeFromString(
      final String jsonData, final boolean allowComments) {
<span class="fc" id="L316">    final ObjectMapper objectMapper = new ObjectMapper();</span>
<span class="fc" id="L317">    objectMapper.configure(Feature.ALLOW_COMMENTS, allowComments);</span>
    try {
<span class="fc" id="L319">      final JsonNode jsonNode = objectMapper.readTree(jsonData);</span>
<span class="fc" id="L320">      validateType(jsonNode, JsonNodeType.OBJECT);</span>
<span class="fc" id="L321">      return (ObjectNode) jsonNode;</span>
<span class="fc" id="L322">    } catch (final IOException e) {</span>
      // Reading directly from a string should not raise an IOException, just catch and rethrow
<span class="fc" id="L324">      throw new RuntimeException(e);</span>
    }
  }

  /**
   * Object node from string without some field.
   *
   * @param jsonData the json data
   * @param allowComments true to allow comments
   * @param withoutField the without field
   * @return the object node
   */
  public static ObjectNode objectNodeFromStringWithout(
      final String jsonData, final boolean allowComments, final String withoutField) {
<span class="fc" id="L338">    final ObjectMapper objectMapper = new ObjectMapper();</span>
    JsonFactory jsonFactory =
<span class="fc" id="L340">        JsonFactory.builder()</span>
<span class="fc" id="L341">            .configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false)</span>
<span class="fc" id="L342">            .configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, false)</span>
<span class="fc" id="L343">            .build();</span>
<span class="fc" id="L344">    jsonFactory.configure(JsonParser.Feature.ALLOW_COMMENTS, allowComments);</span>

<span class="fc" id="L346">    ObjectNode root = objectMapper.createObjectNode();</span>

<span class="fc" id="L348">    try (JsonParser jp = jsonFactory.createParser(jsonData)) {</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">      if (jp.nextToken() != JsonToken.START_OBJECT) {</span>
<span class="nc" id="L350">        throw new RuntimeException(&quot;Expected data to start with an Object&quot;);</span>
      }

<span class="fc bfc" id="L353" title="All 2 branches covered.">      while (jp.nextToken() != JsonToken.END_OBJECT) {</span>
<span class="fc" id="L354">        String fieldName = jp.getCurrentName();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (withoutField.equals(fieldName)) {</span>
<span class="fc" id="L356">          jp.nextToken();</span>
<span class="fc" id="L357">          jp.skipChildren();</span>
        } else {
<span class="fc" id="L359">          jp.nextToken();</span>
<span class="fc" id="L360">          root.set(fieldName, objectMapper.readTree(jp));</span>
        }
<span class="fc" id="L362">      }</span>
<span class="nc" id="L363">    } catch (Exception e) {</span>
<span class="nc" id="L364">      throw new RuntimeException(e);</span>
<span class="fc" id="L365">    }</span>
<span class="fc" id="L366">    return root;</span>
  }

  /**
   * Gets json.
   *
   * @param objectNode the object node
   * @return the json
   * @throws JsonProcessingException the json processing exception
   */
  public static String getJson(final Object objectNode) throws JsonProcessingException {
<span class="fc" id="L377">    return getJson(objectNode, true);</span>
  }

  /**
   * Gets json.
   *
   * @param objectNode the object node
   * @param prettyPrint true for pretty print
   * @return the json
   * @throws JsonProcessingException the json processing exception
   */
  public static String getJson(final Object objectNode, final boolean prettyPrint)
      throws JsonProcessingException {
<span class="fc" id="L390">    final ObjectMapper mapper = getObjectMapper();</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">    if (prettyPrint) {</span>
<span class="fc" id="L392">      return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(objectNode);</span>
    } else {
<span class="fc" id="L394">      return mapper.writeValueAsString(objectNode);</span>
    }
  }

  /**
   * Gets object mapper.
   *
   * @return the object mapper
   */
  public static ObjectMapper getObjectMapper() {
<span class="fc" id="L404">    return new ObjectMapper();</span>
  }

  /**
   * Gets object node.
   *
   * @param json the json
   * @param fieldKey the field key
   * @return the object node
   */
  public static Optional&lt;ObjectNode&gt; getObjectNode(final ObjectNode json, final String fieldKey) {
<span class="fc" id="L415">    return getObjectNode(json, fieldKey, true);</span>
  }

  /**
   * Gets object node.
   *
   * @param json the json
   * @param fieldKey the field key
   * @param strict true for strict mode
   * @return the object node
   */
  public static Optional&lt;ObjectNode&gt; getObjectNode(
      final ObjectNode json, final String fieldKey, final boolean strict) {
<span class="fc" id="L428">    final JsonNode obj = json.get(fieldKey);</span>
<span class="fc bfc" id="L429" title="All 4 branches covered.">    if (obj == null || obj.isNull()) {</span>
<span class="fc" id="L430">      return Optional.empty();</span>
    }

<span class="fc bfc" id="L433" title="All 2 branches covered.">    if (!obj.isObject()) {</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">      if (strict) {</span>
<span class="nc" id="L435">        validateType(obj, JsonNodeType.OBJECT);</span>
      } else {
<span class="nc" id="L437">        return Optional.empty();</span>
      }
    }

<span class="fc" id="L441">    return Optional.of((ObjectNode) obj);</span>
  }

  /**
   * Gets array node.
   *
   * @param json the json
   * @param fieldKey the field key
   * @return the array node
   */
  public static Optional&lt;ArrayNode&gt; getArrayNode(final ObjectNode json, final String fieldKey) {
<span class="fc" id="L452">    return getArrayNode(json, fieldKey, true);</span>
  }

  /**
   * Gets array node.
   *
   * @param json the json
   * @param fieldKey the field key
   * @param strict true for strict mode
   * @return the array node
   */
  public static Optional&lt;ArrayNode&gt; getArrayNode(
      final ObjectNode json, final String fieldKey, final boolean strict) {
<span class="fc" id="L465">    final JsonNode obj = json.get(fieldKey);</span>
<span class="fc bfc" id="L466" title="All 4 branches covered.">    if (obj == null || obj.isNull()) {</span>
<span class="fc" id="L467">      return Optional.empty();</span>
    }

<span class="fc bfc" id="L470" title="All 2 branches covered.">    if (!obj.isArray()) {</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">      if (strict) {</span>
<span class="nc" id="L472">        validateType(obj, JsonNodeType.ARRAY);</span>
      } else {
<span class="nc" id="L474">        return Optional.empty();</span>
      }
    }

<span class="fc" id="L478">    return Optional.of((ArrayNode) obj);</span>
  }

  private static Optional&lt;JsonNode&gt; getValue(final ObjectNode node, final String key) {
<span class="fc" id="L482">    final JsonNode jsonNode = node.get(key);</span>
<span class="fc bfc" id="L483" title="All 4 branches covered.">    if (jsonNode == null || jsonNode.isNull()) {</span>
<span class="fc" id="L484">      return Optional.empty();</span>
    }
<span class="fc" id="L486">    return Optional.of(jsonNode);</span>
  }

  private static boolean validateType(final JsonNode node, final JsonNodeType expectedType) {
<span class="fc bfc" id="L490" title="All 2 branches covered.">    if (node.getNodeType() != expectedType) {</span>
<span class="fc" id="L491">      final String errorMessage =</span>
<span class="fc" id="L492">          String.format(</span>
              &quot;Expected %s value but got %s&quot;,
<span class="fc" id="L494">              expectedType.toString().toLowerCase(Locale.ROOT),</span>
<span class="fc" id="L495">              node.getNodeType().toString().toLowerCase(Locale.ROOT));</span>
<span class="fc" id="L496">      throw new IllegalArgumentException(errorMessage);</span>
    }
<span class="fc" id="L498">    return true;</span>
  }

  private static boolean validateLong(final JsonNode node) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">    if (!node.canConvertToLong()) {</span>
<span class="fc" id="L503">      throw new IllegalArgumentException(&quot;Cannot convert value to long: &quot; + node.toString());</span>
    }
<span class="fc" id="L505">    return true;</span>
  }

  private static boolean validateInt(final JsonNode node) {
<span class="fc bfc" id="L509" title="All 2 branches covered.">    if (!node.canConvertToInt()) {</span>
<span class="fc" id="L510">      throw new IllegalArgumentException(&quot;Cannot convert value to integer: &quot; + node.toString());</span>
    }
<span class="fc" id="L512">    return true;</span>
  }

  /**
   * Get the JSON representation of a genesis file without a specific field.
   *
   * @param genesisFile The genesis file to read.
   * @param excludedFieldName The field to exclude from the JSON representation.
   * @return The JSON representation of the genesis file without the excluded field.
   */
  public static String getJsonFromFileWithout(
      final File genesisFile, final String excludedFieldName) {
<span class="fc" id="L524">    StringBuilder jsonBuilder = new StringBuilder();</span>
    JsonFactory jsonFactory =
<span class="fc" id="L526">        JsonFactory.builder()</span>
<span class="fc" id="L527">            .configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false)</span>
<span class="fc" id="L528">            .configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, false)</span>
<span class="fc" id="L529">            .build();</span>
<span class="fc" id="L530">    try (JsonParser parser = jsonFactory.createParser(genesisFile)) {</span>
      JsonToken token;
<span class="fc bfc" id="L532" title="All 2 branches covered.">      while ((token = parser.nextToken()) != null) {</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (token == JsonToken.START_OBJECT) {</span>
<span class="fc" id="L534">          jsonBuilder.append(handleObject(parser, excludedFieldName));</span>
        }
      }
<span class="nc" id="L537">    } catch (Exception e) {</span>
<span class="nc" id="L538">      throw new RuntimeException(e);</span>
<span class="fc" id="L539">    }</span>
<span class="fc" id="L540">    return jsonBuilder.toString();</span>
  }

  private static String handleObject(final JsonParser parser, final String excludedFieldName)
      throws IOException {
<span class="fc" id="L545">    StringBuilder objectBuilder = new StringBuilder();</span>
<span class="fc" id="L546">    objectBuilder.append(&quot;{&quot;);</span>
    String fieldName;
<span class="fc" id="L548">    boolean isFirstField = true;</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">    while (parser.nextToken() != JsonToken.END_OBJECT) {</span>
<span class="fc" id="L550">      fieldName = parser.getCurrentName();</span>
<span class="pc bpc" id="L551" title="1 of 4 branches missed.">      if (fieldName != null &amp;&amp; fieldName.equals(excludedFieldName)) {</span>
<span class="fc" id="L552">        parser.skipChildren(); // Skip this field</span>
<span class="fc" id="L553">        continue;</span>
      }
<span class="fc bfc" id="L555" title="All 2 branches covered.">      if (!isFirstField) objectBuilder.append(&quot;, &quot;);</span>
<span class="fc" id="L556">      parser.nextToken(); // move to value</span>
<span class="fc" id="L557">      objectBuilder</span>
<span class="fc" id="L558">          .append(&quot;\&quot;&quot;)</span>
<span class="fc" id="L559">          .append(fieldName)</span>
<span class="fc" id="L560">          .append(&quot;\&quot;:&quot;)</span>
<span class="fc" id="L561">          .append(handleValue(parser, excludedFieldName));</span>
<span class="fc" id="L562">      isFirstField = false;</span>
    }
<span class="fc" id="L564">    objectBuilder.append(&quot;}&quot;);</span>
<span class="fc" id="L565">    return objectBuilder.toString();</span>
  }

  private static String handleValue(final JsonParser parser, final String excludedFieldName)
      throws IOException {
<span class="fc" id="L570">    JsonToken token = parser.getCurrentToken();</span>
<span class="pc bpc" id="L571" title="4 of 7 branches missed.">    switch (token) {</span>
      case START_OBJECT:
<span class="fc" id="L573">        return handleObject(parser, excludedFieldName);</span>
      case START_ARRAY:
<span class="nc" id="L575">        return handleArray(parser, excludedFieldName);</span>
      case VALUE_STRING:
<span class="fc" id="L577">        return &quot;\&quot;&quot; + parser.getText() + &quot;\&quot;&quot;;</span>
      case VALUE_NUMBER_INT:
      case VALUE_NUMBER_FLOAT:
<span class="fc" id="L580">        return parser.getNumberValue().toString();</span>
      case VALUE_TRUE:
      case VALUE_FALSE:
<span class="nc bnc" id="L583" title="All 2 branches missed.">        return parser.getBooleanValue() ? &quot;true&quot; : &quot;false&quot;;</span>
      case VALUE_NULL:
<span class="nc" id="L585">        return &quot;null&quot;;</span>
      default:
<span class="nc" id="L587">        throw new IllegalStateException(&quot;Unrecognized token: &quot; + token);</span>
    }
  }

  private static String handleArray(final JsonParser parser, final String excludedFieldName)
      throws IOException {
<span class="nc" id="L593">    StringBuilder arrayBuilder = new StringBuilder();</span>
<span class="nc" id="L594">    arrayBuilder.append(&quot;[&quot;);</span>
<span class="nc" id="L595">    boolean isFirstElement = true;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">    while (parser.nextToken() != JsonToken.END_ARRAY) {</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">      if (!isFirstElement) arrayBuilder.append(&quot;, &quot;);</span>
<span class="nc" id="L598">      arrayBuilder.append(handleValue(parser, excludedFieldName));</span>
<span class="nc" id="L599">      isFirstElement = false;</span>
    }
<span class="nc" id="L601">    arrayBuilder.append(&quot;]&quot;);</span>
<span class="nc" id="L602">    return arrayBuilder.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>