<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonBlockImporter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.chainimport</a> &gt; <span class="el_source">JsonBlockImporter.java</span></div><h1>JsonBlockImporter.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.chainimport;

import org.hyperledger.besu.chainimport.internal.BlockData;
import org.hyperledger.besu.chainimport.internal.ChainData;
import org.hyperledger.besu.config.GenesisConfigOptions;
import org.hyperledger.besu.config.PowAlgorithm;
import org.hyperledger.besu.controller.BesuController;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.blockcreation.MiningCoordinator;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockImporter;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.hyperledger.besu.ethereum.mainnet.BlockImportResult;
import org.hyperledger.besu.ethereum.mainnet.HeaderValidationMode;
import org.hyperledger.besu.evm.worldstate.WorldState;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
import org.apache.tuweni.bytes.Bytes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** Tool for importing blocks with transactions from human-readable json. */
public class JsonBlockImporter {
<span class="fc" id="L50">  private static final Logger LOG = LoggerFactory.getLogger(JsonBlockImporter.class);</span>

  private final ObjectMapper mapper;
  private final BesuController controller;

  /**
   * Instantiates a new Json block importer.
   *
   * @param controller the controller
   */
<span class="fc" id="L60">  public JsonBlockImporter(final BesuController controller) {</span>
<span class="fc" id="L61">    this.controller = controller;</span>
<span class="fc" id="L62">    mapper = new ObjectMapper();</span>
    // Jdk8Module allows us to easily parse {@code Optional} values from json
<span class="fc" id="L64">    mapper.registerModule(new Jdk8Module());</span>
    // Ignore casing of properties
<span class="fc" id="L66">    mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);</span>
<span class="fc" id="L67">  }</span>

  /**
   * Import chain.
   *
   * @param chainJson the chain json
   * @throws IOException the io exception
   */
  public void importChain(final String chainJson) throws IOException {
<span class="fc" id="L76">    warnIfDatabaseIsNotEmpty();</span>

<span class="fc" id="L78">    final ChainData chainData = mapper.readValue(chainJson, ChainData.class);</span>

<span class="fc" id="L80">    final List&lt;Block&gt; importedBlocks = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">    for (final BlockData blockData : chainData.getBlocks()) {</span>
<span class="fc" id="L82">      final BlockHeader parentHeader = getParentHeader(blockData, importedBlocks);</span>
<span class="fc" id="L83">      final Block importedBlock = processBlockData(blockData, parentHeader);</span>
<span class="fc" id="L84">      importedBlocks.add(importedBlock);</span>
<span class="fc" id="L85">    }</span>

<span class="fc" id="L87">    this.warnIfImportedBlocksAreNotOnCanonicalChain(importedBlocks);</span>
<span class="fc" id="L88">  }</span>

  private Block processBlockData(final BlockData blockData, final BlockHeader parentHeader) {
<span class="fc" id="L91">    LOG.info(</span>
        &quot;Preparing to import block at height {} (parent: {})&quot;,
<span class="fc" id="L93">        parentHeader.getNumber() + 1L,</span>
<span class="fc" id="L94">        parentHeader.getHash());</span>

<span class="fc" id="L96">    final WorldState worldState =</span>
        controller
<span class="fc" id="L98">            .getProtocolContext()</span>
<span class="fc" id="L99">            .getWorldStateArchive()</span>
<span class="fc" id="L100">            .get(parentHeader.getStateRoot(), parentHeader.getHash())</span>
<span class="fc" id="L101">            .get();</span>
<span class="fc" id="L102">    final List&lt;Transaction&gt; transactions =</span>
<span class="fc" id="L103">        blockData.streamTransactions(worldState).collect(Collectors.toList());</span>

<span class="fc" id="L105">    final Block block = createBlock(blockData, parentHeader, transactions);</span>
<span class="fc" id="L106">    assertAllTransactionsIncluded(block, transactions);</span>
<span class="fc" id="L107">    importBlock(block);</span>

<span class="fc" id="L109">    return block;</span>
  }

  private Block createBlock(
      final BlockData blockData,
      final BlockHeader parentHeader,
      final List&lt;Transaction&gt; transactions) {
<span class="fc" id="L116">    final MiningCoordinator miner = controller.getMiningCoordinator();</span>
<span class="fc" id="L117">    final GenesisConfigOptions genesisConfigOptions = controller.getGenesisConfigOptions();</span>
<span class="fc" id="L118">    setOptionalFields(miner, blockData, genesisConfigOptions);</span>

    // Some MiningCoordinator's (specific to consensus type) do not support block-level imports
<span class="fc" id="L121">    return miner</span>
<span class="fc" id="L122">        .createBlock(parentHeader, transactions, Collections.emptyList())</span>
<span class="fc" id="L123">        .orElseThrow(</span>
            () -&gt;
<span class="fc" id="L125">                new IllegalArgumentException(</span>
                    &quot;Unable to create block using current consensus engine: &quot;
<span class="fc" id="L127">                        + genesisConfigOptions.getConsensusEngine()));</span>
  }

  private void setOptionalFields(
      final MiningCoordinator miner,
      final BlockData blockData,
      final GenesisConfigOptions genesisConfig) {
    // Some fields can only be configured for ethash
<span class="fc bfc" id="L135" title="All 2 branches covered.">    if (genesisConfig.getPowAlgorithm() != PowAlgorithm.UNSUPPORTED) {</span>
      // For simplicity only set these for PoW consensus algorithms.
      // Other consensus algorithms use these fields for special purposes or ignore them.
<span class="fc" id="L138">      miner.setCoinbase(blockData.getCoinbase().orElse(Address.ZERO));</span>
<span class="fc" id="L139">      miner.setExtraData(blockData.getExtraData().orElse(Bytes.EMPTY));</span>
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">    } else if (blockData.getCoinbase().isPresent() || blockData.getExtraData().isPresent()) {</span>
      // Fail if these fields are set for non-ethash chains
<span class="fc" id="L142">      final Stream.Builder&lt;String&gt; fields = Stream.builder();</span>
<span class="fc" id="L143">      blockData.getCoinbase().map((c) -&gt; &quot;coinbase&quot;).ifPresent(fields::add);</span>
<span class="fc" id="L144">      blockData.getExtraData().map((e) -&gt; &quot;extraData&quot;).ifPresent(fields::add);</span>
<span class="fc" id="L145">      final String fieldsList = fields.build().collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L146">      throw new IllegalArgumentException(</span>
          &quot;Some fields (&quot;
              + fieldsList
              + &quot;) are unsupported by the current consensus engine: &quot;
<span class="fc" id="L150">              + genesisConfig.getConsensusEngine());</span>
    }
<span class="fc" id="L152">  }</span>

  private void importBlock(final Block block) {
<span class="fc" id="L155">    final BlockImporter importer =</span>
<span class="fc" id="L156">        controller.getProtocolSchedule().getByBlockHeader(block.getHeader()).getBlockImporter();</span>

<span class="fc" id="L158">    final BlockImportResult importResult =</span>
<span class="fc" id="L159">        importer.importBlock(controller.getProtocolContext(), block, HeaderValidationMode.NONE);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (importResult.isImported()) {</span>
<span class="fc" id="L161">      LOG.info(</span>
          &quot;Successfully created and imported block at height {} ({})&quot;,
<span class="fc" id="L163">          block.getHeader().getNumber(),</span>
<span class="fc" id="L164">          block.getHash());</span>
    } else {
<span class="nc" id="L166">      throw new IllegalStateException(</span>
<span class="nc" id="L167">          &quot;Newly created block &quot; + block.getHeader().getNumber() + &quot; failed validation.&quot;);</span>
    }
<span class="fc" id="L169">  }</span>

  private void assertAllTransactionsIncluded(
      final Block block, final List&lt;Transaction&gt; transactions) {
<span class="fc bfc" id="L173" title="All 2 branches covered.">    if (transactions.size() != block.getBody().getTransactions().size()) {</span>
<span class="fc" id="L174">      final int missingTransactions =</span>
<span class="fc" id="L175">          transactions.size() - block.getBody().getTransactions().size();</span>
<span class="fc" id="L176">      throw new IllegalStateException(</span>
          &quot;Unable to create block.  &quot;
              + missingTransactions
              + &quot; transaction(s) were found to be invalid.&quot;);
    }
<span class="fc" id="L181">  }</span>

  private void warnIfDatabaseIsNotEmpty() {
<span class="fc" id="L184">    final long chainHeight =</span>
<span class="fc" id="L185">        controller.getProtocolContext().getBlockchain().getChainHead().getHeight();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (chainHeight &gt; BlockHeader.GENESIS_BLOCK_NUMBER) {</span>
<span class="fc" id="L187">      LOG.warn(</span>
          &quot;Importing to a non-empty database with chain height {}.  This may cause imported blocks to be considered non-canonical.&quot;,
<span class="fc" id="L189">          chainHeight);</span>
    }
<span class="fc" id="L191">  }</span>

  private void warnIfImportedBlocksAreNotOnCanonicalChain(final List&lt;Block&gt; importedBlocks) {
<span class="fc" id="L194">    final List&lt;BlockHeader&gt; nonCanonicalHeaders =</span>
<span class="fc" id="L195">        importedBlocks.stream()</span>
<span class="fc" id="L196">            .map(Block::getHeader)</span>
<span class="fc" id="L197">            .filter(</span>
                header -&gt;
                    controller
<span class="fc" id="L200">                        .getProtocolContext()</span>
<span class="fc" id="L201">                        .getBlockchain()</span>
<span class="fc" id="L202">                        .getBlockHeader(header.getNumber())</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">                        .map(c -&gt; !c.equals(header))</span>
<span class="fc" id="L204">                        .orElse(true))</span>
<span class="fc" id="L205">            .collect(Collectors.toList());</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">    if (nonCanonicalHeaders.size() &gt; 0) {</span>
<span class="nc" id="L207">      final String blocksString =</span>
<span class="nc" id="L208">          nonCanonicalHeaders.stream()</span>
<span class="nc" id="L209">              .map(h -&gt; &quot;#&quot; + h.getNumber() + &quot; (&quot; + h.getHash() + &quot;)&quot;)</span>
<span class="nc" id="L210">              .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="nc" id="L211">      LOG.warn(</span>
          &quot;{} / {} imported blocks are not on the canonical chain: {}&quot;,
<span class="nc" id="L213">          nonCanonicalHeaders.size(),</span>
<span class="nc" id="L214">          importedBlocks.size(),</span>
          blocksString);
    }
<span class="fc" id="L217">  }</span>

  private BlockHeader getParentHeader(final BlockData blockData, final List&lt;Block&gt; importedBlocks) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">    if (blockData.getParentHash().isPresent()) {</span>
<span class="fc" id="L221">      final Hash parentHash = blockData.getParentHash().get();</span>
<span class="fc" id="L222">      return controller</span>
<span class="fc" id="L223">          .getProtocolContext()</span>
<span class="fc" id="L224">          .getBlockchain()</span>
<span class="fc" id="L225">          .getBlockHeader(parentHash)</span>
<span class="fc" id="L226">          .orElseThrow(</span>
<span class="nc" id="L227">              () -&gt; new IllegalArgumentException(&quot;Unable to locate block parent at &quot; + parentHash));</span>
    }

<span class="fc bfc" id="L230" title="All 4 branches covered.">    if (importedBlocks.size() &gt; 0 &amp;&amp; blockData.getNumber().isPresent()) {</span>
<span class="fc" id="L231">      final long targetParentBlockNumber = blockData.getNumber().get() - 1L;</span>
<span class="fc" id="L232">      final Optional&lt;BlockHeader&gt; maybeHeader =</span>
<span class="fc" id="L233">          importedBlocks.stream()</span>
<span class="fc" id="L234">              .map(Block::getHeader)</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">              .filter(h -&gt; h.getNumber() == targetParentBlockNumber)</span>
<span class="fc" id="L236">              .findFirst();</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">      if (maybeHeader.isPresent()) {</span>
<span class="fc" id="L238">        return maybeHeader.get();</span>
      }
    }

    final long blockNumber;
<span class="fc bfc" id="L243" title="All 2 branches covered.">    if (blockData.getNumber().isPresent()) {</span>
<span class="fc" id="L244">      blockNumber = blockData.getNumber().get() - 1L;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">    } else if (importedBlocks.size() &gt; 0) {</span>
      // If there is no number or hash, import blocks in order
<span class="fc" id="L247">      blockNumber = importedBlocks.get(importedBlocks.size() - 1).getHeader().getNumber();</span>
    } else {
<span class="fc" id="L249">      blockNumber = BlockHeader.GENESIS_BLOCK_NUMBER;</span>
    }

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (blockNumber &lt; BlockHeader.GENESIS_BLOCK_NUMBER) {</span>
<span class="nc" id="L253">      throw new IllegalArgumentException(&quot;Invalid block number: &quot; + (blockNumber + 1));</span>
    }

<span class="fc" id="L256">    return controller</span>
<span class="fc" id="L257">        .getProtocolContext()</span>
<span class="fc" id="L258">        .getBlockchain()</span>
<span class="fc" id="L259">        .getBlockHeader(blockNumber)</span>
<span class="fc" id="L260">        .orElseThrow(</span>
<span class="fc" id="L261">            () -&gt; new IllegalArgumentException(&quot;Unable to locate block parent at &quot; + blockNumber));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>