<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractBlockCreator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.blockcreation</a> &gt; <span class="el_source">AbstractBlockCreator.java</span></div><h1>AbstractBlockCreator.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.blockcreation;

import static org.hyperledger.besu.ethereum.mainnet.feemarket.ExcessBlobGasCalculator.calculateExcessBlobGasForParent;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.BlobGas;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.datatypes.TransactionType;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.blockcreation.txselection.BlockTransactionSelector;
import org.hyperledger.besu.ethereum.blockcreation.txselection.TransactionSelectionResults;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockBody;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockHeaderBuilder;
import org.hyperledger.besu.ethereum.core.BlockHeaderFunctions;
import org.hyperledger.besu.ethereum.core.Deposit;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.core.MiningParameters;
import org.hyperledger.besu.ethereum.core.MutableWorldState;
import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;
import org.hyperledger.besu.ethereum.core.SealableBlockHeader;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.hyperledger.besu.ethereum.core.ValidatorExit;
import org.hyperledger.besu.ethereum.core.Withdrawal;
import org.hyperledger.besu.ethereum.core.encoding.DepositDecoder;
import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;
import org.hyperledger.besu.ethereum.mainnet.AbstractBlockProcessor;
import org.hyperledger.besu.ethereum.mainnet.BodyValidation;
import org.hyperledger.besu.ethereum.mainnet.DepositsValidator;
import org.hyperledger.besu.ethereum.mainnet.DifficultyCalculator;
import org.hyperledger.besu.ethereum.mainnet.MainnetTransactionProcessor;
import org.hyperledger.besu.ethereum.mainnet.ParentBeaconBlockRootHelper;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;
import org.hyperledger.besu.ethereum.mainnet.ScheduleBasedBlockHeaderFunctions;
import org.hyperledger.besu.ethereum.mainnet.ValidatorExitsValidator;
import org.hyperledger.besu.ethereum.mainnet.WithdrawalsProcessor;
import org.hyperledger.besu.ethereum.mainnet.feemarket.BaseFeeMarket;
import org.hyperledger.besu.ethereum.mainnet.feemarket.ExcessBlobGasCalculator;
import org.hyperledger.besu.ethereum.mainnet.feemarket.FeeMarket;
import org.hyperledger.besu.evm.account.MutableAccount;
import org.hyperledger.besu.evm.worldstate.WorldUpdater;
import org.hyperledger.besu.plugin.services.exception.StorageException;
import org.hyperledger.besu.plugin.services.securitymodule.SecurityModuleException;
import org.hyperledger.besu.plugin.services.tracer.BlockAwareOperationTracer;
import org.hyperledger.besu.plugin.services.txselection.PluginTransactionSelector;

import java.math.BigInteger;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CancellationException;
import java.util.concurrent.atomic.AtomicBoolean;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class AbstractBlockCreator implements AsyncBlockCreator {

  public interface ExtraDataCalculator {

    Bytes get(final BlockHeader parent);
  }

<span class="fc" id="L85">  private static final Logger LOG = LoggerFactory.getLogger(AbstractBlockCreator.class);</span>

  private final MiningBeneficiaryCalculator miningBeneficiaryCalculator;
  private final ExtraDataCalculator extraDataCalculator;
  private final TransactionPool transactionPool;
  protected final MiningParameters miningParameters;
  protected final ProtocolContext protocolContext;
  protected final ProtocolSchedule protocolSchedule;
  protected final BlockHeaderFunctions blockHeaderFunctions;
  protected final BlockHeader parentHeader;
  private final Optional&lt;Address&gt; depositContractAddress;
  private final EthScheduler ethScheduler;
<span class="fc" id="L97">  private final AtomicBoolean isCancelled = new AtomicBoolean(false);</span>

  protected AbstractBlockCreator(
      final MiningParameters miningParameters,
      final MiningBeneficiaryCalculator miningBeneficiaryCalculator,
      final ExtraDataCalculator extraDataCalculator,
      final TransactionPool transactionPool,
      final ProtocolContext protocolContext,
      final ProtocolSchedule protocolSchedule,
      final BlockHeader parentHeader,
      final Optional&lt;Address&gt; depositContractAddress,
<span class="fc" id="L108">      final EthScheduler ethScheduler) {</span>
<span class="fc" id="L109">    this.miningParameters = miningParameters;</span>
<span class="fc" id="L110">    this.miningBeneficiaryCalculator = miningBeneficiaryCalculator;</span>
<span class="fc" id="L111">    this.extraDataCalculator = extraDataCalculator;</span>
<span class="fc" id="L112">    this.transactionPool = transactionPool;</span>
<span class="fc" id="L113">    this.protocolContext = protocolContext;</span>
<span class="fc" id="L114">    this.protocolSchedule = protocolSchedule;</span>
<span class="fc" id="L115">    this.parentHeader = parentHeader;</span>
<span class="fc" id="L116">    this.depositContractAddress = depositContractAddress;</span>
<span class="fc" id="L117">    this.ethScheduler = ethScheduler;</span>
<span class="fc" id="L118">    blockHeaderFunctions = ScheduleBasedBlockHeaderFunctions.create(protocolSchedule);</span>
<span class="fc" id="L119">  }</span>

  /**
   * Create block will create a new block at the head of the blockchain specified in the
   * protocolContext.
   *
   * &lt;p&gt;It will select transactions from the PendingTransaction list for inclusion in the Block
   * body, and will supply an empty Ommers list.
   *
   * &lt;p&gt;Once transactions have been selected and applied to a disposable/temporary world state, the
   * block reward is paid to the relevant coinbase, and a sealable header is constucted.
   *
   * &lt;p&gt;The sealableHeader is then provided to child instances for sealing (i.e. proof of work or
   * otherwise).
   *
   * &lt;p&gt;The constructed block is then returned.
   *
   * @return a block with appropriately selected transactions, seals and ommers.
   */
  @Override
  public BlockCreationResult createBlock(final long timestamp) {
<span class="fc" id="L140">    return createBlock(Optional.empty(), Optional.empty(), timestamp);</span>
  }

  @Override
  public BlockCreationResult createBlock(
      final List&lt;Transaction&gt; transactions, final List&lt;BlockHeader&gt; ommers, final long timestamp) {
<span class="fc" id="L146">    return createBlock(Optional.of(transactions), Optional.of(ommers), timestamp);</span>
  }

  @Override
  public BlockCreationResult createBlock(
      final Optional&lt;List&lt;Transaction&gt;&gt; maybeTransactions,
      final Optional&lt;List&lt;BlockHeader&gt;&gt; maybeOmmers,
      final long timestamp) {
<span class="fc" id="L154">    return createBlock(</span>
        maybeTransactions,
        maybeOmmers,
<span class="fc" id="L157">        Optional.empty(),</span>
<span class="fc" id="L158">        Optional.empty(),</span>
<span class="fc" id="L159">        Optional.empty(),</span>
        timestamp,
        true);
  }

  @Override
  public BlockCreationResult createEmptyWithdrawalsBlock(final long timestamp) {
<span class="nc" id="L166">    throw new UnsupportedOperationException(&quot;Only used by BFT block creators&quot;);</span>
  }

  public BlockCreationResult createBlock(
      final Optional&lt;List&lt;Transaction&gt;&gt; maybeTransactions,
      final Optional&lt;List&lt;BlockHeader&gt;&gt; maybeOmmers,
      final Optional&lt;List&lt;Withdrawal&gt;&gt; maybeWithdrawals,
      final long timestamp) {
<span class="fc" id="L174">    return createBlock(</span>
        maybeTransactions,
        maybeOmmers,
        maybeWithdrawals,
<span class="fc" id="L178">        Optional.empty(),</span>
<span class="fc" id="L179">        Optional.empty(),</span>
        timestamp,
        true);
  }

  protected BlockCreationResult createBlock(
      final Optional&lt;List&lt;Transaction&gt;&gt; maybeTransactions,
      final Optional&lt;List&lt;BlockHeader&gt;&gt; maybeOmmers,
      final Optional&lt;List&lt;Withdrawal&gt;&gt; maybeWithdrawals,
      final Optional&lt;Bytes32&gt; maybePrevRandao,
      final Optional&lt;Bytes32&gt; maybeParentBeaconBlockRoot,
      final long timestamp,
      boolean rewardCoinbase) {

<span class="fc" id="L193">    final var timings = new BlockCreationTiming();</span>

<span class="fc" id="L195">    try (final MutableWorldState disposableWorldState = duplicateWorldStateAtParent()) {</span>
<span class="fc" id="L196">      timings.register(&quot;duplicateWorldState&quot;);</span>
<span class="fc" id="L197">      final ProtocolSpec newProtocolSpec =</span>
<span class="fc" id="L198">          protocolSchedule.getForNextBlockHeader(parentHeader, timestamp);</span>

<span class="fc" id="L200">      final ProcessableBlockHeader processableBlockHeader =</span>
<span class="fc" id="L201">          createPendingBlockHeader(</span>
              timestamp, maybePrevRandao, maybeParentBeaconBlockRoot, newProtocolSpec);
<span class="fc" id="L203">      final Address miningBeneficiary =</span>
<span class="fc" id="L204">          miningBeneficiaryCalculator.getMiningBeneficiary(processableBlockHeader.getNumber());</span>

<span class="fc" id="L206">      throwIfStopped();</span>

<span class="fc" id="L208">      final List&lt;BlockHeader&gt; ommers = maybeOmmers.orElse(selectOmmers());</span>

<span class="fc" id="L210">      maybeParentBeaconBlockRoot.ifPresent(</span>
          bytes32 -&gt;
<span class="nc" id="L212">              ParentBeaconBlockRootHelper.storeParentBeaconBlockRoot(</span>
<span class="nc" id="L213">                  disposableWorldState.updater(), timestamp, bytes32));</span>

<span class="fc" id="L215">      throwIfStopped();</span>

<span class="fc" id="L217">      final PluginTransactionSelector pluginTransactionSelector =</span>
<span class="fc" id="L218">          miningParameters.getTransactionSelectionService().createPluginTransactionSelector();</span>

<span class="fc" id="L220">      final BlockAwareOperationTracer operationTracer =</span>
<span class="fc" id="L221">          pluginTransactionSelector.getOperationTracer();</span>

<span class="fc" id="L223">      operationTracer.traceStartBlock(processableBlockHeader);</span>
<span class="fc" id="L224">      timings.register(&quot;preTxsSelection&quot;);</span>
<span class="fc" id="L225">      final TransactionSelectionResults transactionResults =</span>
<span class="fc" id="L226">          selectTransactions(</span>
              processableBlockHeader,
              disposableWorldState,
              maybeTransactions,
              miningBeneficiary,
              newProtocolSpec,
              pluginTransactionSelector);
<span class="fc" id="L233">      transactionResults.logSelectionStats();</span>
<span class="fc" id="L234">      timings.register(&quot;txsSelection&quot;);</span>
<span class="fc" id="L235">      throwIfStopped();</span>

<span class="fc" id="L237">      final Optional&lt;WithdrawalsProcessor&gt; maybeWithdrawalsProcessor =</span>
<span class="fc" id="L238">          newProtocolSpec.getWithdrawalsProcessor();</span>
<span class="fc" id="L239">      final boolean withdrawalsCanBeProcessed =</span>
<span class="fc bfc" id="L240" title="All 4 branches covered.">          maybeWithdrawalsProcessor.isPresent() &amp;&amp; maybeWithdrawals.isPresent();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (withdrawalsCanBeProcessed) {</span>
<span class="fc" id="L242">        maybeWithdrawalsProcessor</span>
<span class="fc" id="L243">            .get()</span>
<span class="fc" id="L244">            .processWithdrawals(maybeWithdrawals.get(), disposableWorldState.updater());</span>
      }

<span class="fc" id="L247">      throwIfStopped();</span>

<span class="fc" id="L249">      final DepositsValidator depositsValidator = newProtocolSpec.getDepositsValidator();</span>
<span class="fc" id="L250">      Optional&lt;List&lt;Deposit&gt;&gt; maybeDeposits = Optional.empty();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">      if (depositsValidator instanceof DepositsValidator.AllowedDeposits</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">          &amp;&amp; depositContractAddress.isPresent()) {</span>
<span class="fc" id="L253">        maybeDeposits = Optional.of(findDepositsFromReceipts(transactionResults));</span>
      }

<span class="fc" id="L256">      throwIfStopped();</span>

      // TODO implement logic to retrieve validator exits from precompile
      // https://github.com/hyperledger/besu/issues/6800
<span class="fc" id="L260">      final ValidatorExitsValidator exitsValidator = newProtocolSpec.getExitsValidator();</span>
<span class="fc" id="L261">      Optional&lt;List&lt;ValidatorExit&gt;&gt; maybeExits = Optional.empty();</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">      if (exitsValidator instanceof ValidatorExitsValidator.AllowedExits) {</span>
<span class="nc" id="L263">        maybeExits = Optional.of(List.of());</span>
      }

<span class="fc" id="L266">      throwIfStopped();</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">      if (rewardCoinbase</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">          &amp;&amp; !rewardBeneficiary(</span>
              disposableWorldState,
              processableBlockHeader,
              ommers,
              miningBeneficiary,
<span class="fc" id="L274">              newProtocolSpec.getBlockReward(),</span>
<span class="fc" id="L275">              newProtocolSpec.isSkipZeroBlockRewards(),</span>
              newProtocolSpec)) {
<span class="nc" id="L277">        LOG.trace(&quot;Failed to apply mining reward, exiting.&quot;);</span>
<span class="nc" id="L278">        throw new RuntimeException(&quot;Failed to apply mining reward.&quot;);</span>
      }

<span class="fc" id="L281">      throwIfStopped();</span>

<span class="fc" id="L283">      final GasUsage usage = computeExcessBlobGas(transactionResults, newProtocolSpec);</span>

<span class="fc" id="L285">      throwIfStopped();</span>

      BlockHeaderBuilder builder =
<span class="fc" id="L288">          BlockHeaderBuilder.create()</span>
<span class="fc" id="L289">              .populateFrom(processableBlockHeader)</span>
<span class="fc" id="L290">              .ommersHash(BodyValidation.ommersHash(ommers))</span>
<span class="fc" id="L291">              .stateRoot(disposableWorldState.rootHash())</span>
<span class="fc" id="L292">              .transactionsRoot(</span>
<span class="fc" id="L293">                  BodyValidation.transactionsRoot(transactionResults.getSelectedTransactions()))</span>
<span class="fc" id="L294">              .receiptsRoot(BodyValidation.receiptsRoot(transactionResults.getReceipts()))</span>
<span class="fc" id="L295">              .logsBloom(BodyValidation.logsBloom(transactionResults.getReceipts()))</span>
<span class="fc" id="L296">              .gasUsed(transactionResults.getCumulativeGasUsed())</span>
<span class="fc" id="L297">              .extraData(extraDataCalculator.get(parentHeader))</span>
<span class="fc" id="L298">              .withdrawalsRoot(</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                  withdrawalsCanBeProcessed</span>
<span class="fc" id="L300">                      ? BodyValidation.withdrawalsRoot(maybeWithdrawals.get())</span>
<span class="fc" id="L301">                      : null)</span>
<span class="fc" id="L302">              .depositsRoot(maybeDeposits.map(BodyValidation::depositsRoot).orElse(null))</span>
<span class="fc" id="L303">              .exitsRoot(maybeExits.map(BodyValidation::exitsRoot).orElse(null));</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">      if (usage != null) {</span>
<span class="nc" id="L305">        builder.blobGasUsed(usage.used.toLong()).excessBlobGas(usage.excessBlobGas);</span>
      }

<span class="fc" id="L308">      final SealableBlockHeader sealableBlockHeader = builder.buildSealableBlockHeader();</span>

<span class="fc" id="L310">      final BlockHeader blockHeader = createFinalBlockHeader(sealableBlockHeader);</span>

      final Optional&lt;List&lt;Withdrawal&gt;&gt; withdrawals =
<span class="fc bfc" id="L313" title="All 2 branches covered.">          withdrawalsCanBeProcessed ? maybeWithdrawals : Optional.empty();</span>
<span class="fc" id="L314">      final BlockBody blockBody =</span>
          new BlockBody(
<span class="fc" id="L316">              transactionResults.getSelectedTransactions(),</span>
              ommers,
              withdrawals,
              maybeDeposits,
              maybeExits);
<span class="fc" id="L321">      final Block block = new Block(blockHeader, blockBody);</span>

<span class="fc" id="L323">      operationTracer.traceEndBlock(blockHeader, blockBody);</span>
<span class="fc" id="L324">      timings.register(&quot;blockAssembled&quot;);</span>
<span class="fc" id="L325">      return new BlockCreationResult(block, transactionResults, timings);</span>
<span class="nc" id="L326">    } catch (final SecurityModuleException ex) {</span>
<span class="nc" id="L327">      throw new IllegalStateException(&quot;Failed to create block signature&quot;, ex);</span>
<span class="fc" id="L328">    } catch (final CancellationException | StorageException ex) {</span>
<span class="fc" id="L329">      throw ex;</span>
<span class="nc" id="L330">    } catch (final Exception ex) {</span>
<span class="nc" id="L331">      throw new IllegalStateException(</span>
          &quot;Block creation failed unexpectedly. Will restart on next block added to chain.&quot;, ex);
    }
  }

  @VisibleForTesting
  List&lt;Deposit&gt; findDepositsFromReceipts(final TransactionSelectionResults transactionResults) {
<span class="fc" id="L338">    return transactionResults.getReceipts().stream()</span>
<span class="fc" id="L339">        .flatMap(receipt -&gt; receipt.getLogsList().stream())</span>
<span class="fc" id="L340">        .filter(log -&gt; depositContractAddress.get().equals(log.getLogger()))</span>
<span class="fc" id="L341">        .map(DepositDecoder::decodeFromLog)</span>
<span class="fc" id="L342">        .toList();</span>
  }

<span class="nc" id="L345">  record GasUsage(BlobGas excessBlobGas, BlobGas used) {}</span>

  private GasUsage computeExcessBlobGas(
      final TransactionSelectionResults transactionResults, final ProtocolSpec newProtocolSpec) {

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">    if (newProtocolSpec.getFeeMarket().implementsDataFee()) {</span>
<span class="nc" id="L351">      final var gasCalculator = newProtocolSpec.getGasCalculator();</span>
<span class="nc" id="L352">      final int newBlobsCount =</span>
<span class="nc" id="L353">          transactionResults.getTransactionsByType(TransactionType.BLOB).stream()</span>
<span class="nc" id="L354">              .map(tx -&gt; tx.getVersionedHashes().orElseThrow())</span>
<span class="nc" id="L355">              .mapToInt(List::size)</span>
<span class="nc" id="L356">              .sum();</span>
      // casting parent excess blob gas to long since for the moment it should be well below that
      // limit
<span class="nc" id="L359">      BlobGas excessBlobGas =</span>
<span class="nc" id="L360">          ExcessBlobGasCalculator.calculateExcessBlobGasForParent(newProtocolSpec, parentHeader);</span>
<span class="nc" id="L361">      BlobGas used = BlobGas.of(gasCalculator.blobGasCost(newBlobsCount));</span>
<span class="nc" id="L362">      return new GasUsage(excessBlobGas, used);</span>
    }
<span class="fc" id="L364">    return null;</span>
  }

  private TransactionSelectionResults selectTransactions(
      final ProcessableBlockHeader processableBlockHeader,
      final MutableWorldState disposableWorldState,
      final Optional&lt;List&lt;Transaction&gt;&gt; transactions,
      final Address miningBeneficiary,
      final ProtocolSpec protocolSpec,
      final PluginTransactionSelector pluginTransactionSelector)
      throws RuntimeException {
<span class="fc" id="L375">    final MainnetTransactionProcessor transactionProcessor = protocolSpec.getTransactionProcessor();</span>

<span class="fc" id="L377">    final AbstractBlockProcessor.TransactionReceiptFactory transactionReceiptFactory =</span>
<span class="fc" id="L378">        protocolSpec.getTransactionReceiptFactory();</span>

<span class="fc" id="L380">    Wei blobGasPrice =</span>
        protocolSpec
<span class="fc" id="L382">            .getFeeMarket()</span>
<span class="fc" id="L383">            .blobGasPricePerGas(calculateExcessBlobGasForParent(protocolSpec, parentHeader));</span>

<span class="fc" id="L385">    final BlockTransactionSelector selector =</span>
        new BlockTransactionSelector(
            miningParameters,
            transactionProcessor,
<span class="fc" id="L389">            protocolContext.getBlockchain(),</span>
            disposableWorldState,
            transactionPool,
            processableBlockHeader,
            transactionReceiptFactory,
<span class="fc" id="L394">            isCancelled::get,</span>
            miningBeneficiary,
            blobGasPrice,
<span class="fc" id="L397">            protocolSpec.getFeeMarket(),</span>
<span class="fc" id="L398">            protocolSpec.getGasCalculator(),</span>
<span class="fc" id="L399">            protocolSpec.getGasLimitCalculator(),</span>
            pluginTransactionSelector,
            ethScheduler);

<span class="fc bfc" id="L403" title="All 2 branches covered.">    if (transactions.isPresent()) {</span>
<span class="fc" id="L404">      return selector.evaluateTransactions(transactions.get());</span>
    } else {
<span class="fc" id="L406">      return selector.buildTransactionListForBlock();</span>
    }
  }

  private MutableWorldState duplicateWorldStateAtParent() {
<span class="fc" id="L411">    final Hash parentStateRoot = parentHeader.getStateRoot();</span>
<span class="fc" id="L412">    return protocolContext</span>
<span class="fc" id="L413">        .getWorldStateArchive()</span>
<span class="fc" id="L414">        .getMutable(parentHeader, false)</span>
<span class="fc" id="L415">        .orElseThrow(</span>
            () -&gt; {
<span class="nc" id="L417">              LOG.info(&quot;Unable to create block because world state is not available&quot;);</span>
<span class="nc" id="L418">              return new CancellationException(</span>
                  &quot;World state not available for block &quot;
<span class="nc" id="L420">                      + parentHeader.getNumber()</span>
                      + &quot; with state root &quot;
                      + parentStateRoot);
            });
  }

  private List&lt;BlockHeader&gt; selectOmmers() {
<span class="fc" id="L427">    return Lists.newArrayList();</span>
  }

  private ProcessableBlockHeader createPendingBlockHeader(
      final long timestamp,
      final Optional&lt;Bytes32&gt; maybePrevRandao,
      final Optional&lt;Bytes32&gt; maybeParentBeaconBlockRoot,
      final ProtocolSpec protocolSpec) {
<span class="fc" id="L435">    final long newBlockNumber = parentHeader.getNumber() + 1;</span>
<span class="fc" id="L436">    long gasLimit =</span>
        protocolSpec
<span class="fc" id="L438">            .getGasLimitCalculator()</span>
<span class="fc" id="L439">            .nextGasLimit(</span>
<span class="fc" id="L440">                parentHeader.getGasLimit(),</span>
<span class="fc" id="L441">                miningParameters.getTargetGasLimit().orElse(parentHeader.getGasLimit()),</span>
                newBlockNumber);

<span class="fc" id="L444">    final DifficultyCalculator difficultyCalculator = protocolSpec.getDifficultyCalculator();</span>
<span class="fc" id="L445">    final BigInteger difficulty =</span>
<span class="fc" id="L446">        difficultyCalculator.nextDifficulty(timestamp, parentHeader, protocolContext);</span>

<span class="fc" id="L448">    final Wei baseFee =</span>
<span class="fc" id="L449">        Optional.of(protocolSpec.getFeeMarket())</span>
<span class="fc" id="L450">            .filter(FeeMarket::implementsBaseFee)</span>
<span class="fc" id="L451">            .map(BaseFeeMarket.class::cast)</span>
<span class="fc" id="L452">            .map(</span>
                feeMarket -&gt;
<span class="fc" id="L454">                    feeMarket.computeBaseFee(</span>
                        newBlockNumber,
<span class="fc" id="L456">                        parentHeader.getBaseFee().orElse(Wei.ZERO),</span>
<span class="fc" id="L457">                        parentHeader.getGasUsed(),</span>
<span class="fc" id="L458">                        feeMarket.targetGasUsed(parentHeader)))</span>
<span class="fc" id="L459">            .orElse(null);</span>

<span class="fc" id="L461">    final Bytes32 prevRandao = maybePrevRandao.orElse(null);</span>
<span class="fc" id="L462">    final Bytes32 parentBeaconBlockRoot = maybeParentBeaconBlockRoot.orElse(null);</span>
<span class="fc" id="L463">    return BlockHeaderBuilder.create()</span>
<span class="fc" id="L464">        .parentHash(parentHeader.getHash())</span>
<span class="fc" id="L465">        .coinbase(miningParameters.getCoinbase().orElseThrow())</span>
<span class="fc" id="L466">        .difficulty(Difficulty.of(difficulty))</span>
<span class="fc" id="L467">        .number(newBlockNumber)</span>
<span class="fc" id="L468">        .gasLimit(gasLimit)</span>
<span class="fc" id="L469">        .timestamp(timestamp)</span>
<span class="fc" id="L470">        .baseFee(baseFee)</span>
<span class="fc" id="L471">        .prevRandao(prevRandao)</span>
<span class="fc" id="L472">        .parentBeaconBlockRoot(parentBeaconBlockRoot)</span>
<span class="fc" id="L473">        .buildProcessableBlockHeader();</span>
  }

  @Override
  public void cancel() {
<span class="fc" id="L478">    isCancelled.set(true);</span>
<span class="fc" id="L479">  }</span>

  @Override
  public boolean isCancelled() {
<span class="nc" id="L483">    return isCancelled.get();</span>
  }

  private void throwIfStopped() throws CancellationException {
<span class="fc bfc" id="L487" title="All 2 branches covered.">    if (isCancelled.get()) {</span>
<span class="fc" id="L488">      throw new CancellationException();</span>
    }
<span class="fc" id="L490">  }</span>

  /* Copied from BlockProcessor (with modifications). */
  boolean rewardBeneficiary(
      final MutableWorldState worldState,
      final ProcessableBlockHeader header,
      final List&lt;BlockHeader&gt; ommers,
      final Address miningBeneficiary,
      final Wei blockReward,
      final boolean skipZeroBlockRewards,
      final ProtocolSpec protocolSpec) {

    // TODO(tmm): Added to make this work, should come from blockProcessor.
<span class="fc" id="L503">    final int MAX_GENERATION = 6;</span>
<span class="fc bfc" id="L504" title="All 4 branches covered.">    if (skipZeroBlockRewards &amp;&amp; blockReward.isZero()) {</span>
<span class="fc" id="L505">      return true;</span>
    }

<span class="fc" id="L508">    final Wei coinbaseReward =</span>
        protocolSpec
<span class="fc" id="L510">            .getBlockProcessor()</span>
<span class="fc" id="L511">            .getCoinbaseReward(blockReward, header.getNumber(), ommers.size());</span>
<span class="fc" id="L512">    final WorldUpdater updater = worldState.updater();</span>
<span class="fc" id="L513">    final MutableAccount beneficiary = updater.getOrCreate(miningBeneficiary);</span>

<span class="fc" id="L515">    beneficiary.incrementBalance(coinbaseReward);</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">    for (final BlockHeader ommerHeader : ommers) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">      if (ommerHeader.getNumber() - header.getNumber() &gt; MAX_GENERATION) {</span>
<span class="nc" id="L518">        LOG.trace(</span>
            &quot;Block processing error: ommer block number {} more than {} generations current block number {}&quot;,
<span class="nc" id="L520">            ommerHeader.getNumber(),</span>
<span class="nc" id="L521">            MAX_GENERATION,</span>
<span class="nc" id="L522">            header.getNumber());</span>
<span class="nc" id="L523">        return false;</span>
      }

<span class="nc" id="L526">      final MutableAccount ommerCoinbase = updater.getOrCreate(ommerHeader.getCoinbase());</span>
<span class="nc" id="L527">      final Wei ommerReward =</span>
          protocolSpec
<span class="nc" id="L529">              .getBlockProcessor()</span>
<span class="nc" id="L530">              .getOmmerReward(blockReward, header.getNumber(), ommerHeader.getNumber());</span>
<span class="nc" id="L531">      ommerCoinbase.incrementBalance(ommerReward);</span>
<span class="nc" id="L532">    }</span>

<span class="fc" id="L534">    updater.commit();</span>

<span class="fc" id="L536">    return true;</span>
  }

  protected abstract BlockHeader createFinalBlockHeader(
      final SealableBlockHeader sealableBlockHeader);

  @FunctionalInterface
  protected interface MiningBeneficiaryCalculator {
    Address getMiningBeneficiary(long blockNumber);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>