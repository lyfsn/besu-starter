<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageFrame.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.evm.frame</a> &gt; <span class="el_source">MessageFrame.java</span></div><h1>MessageFrame.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.evm.frame;

import static com.google.common.base.Preconditions.checkState;
import static java.util.Collections.emptySet;

import org.hyperledger.besu.collections.trie.BytesTrieSet;
import org.hyperledger.besu.collections.undo.UndoSet;
import org.hyperledger.besu.collections.undo.UndoTable;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.datatypes.VersionedHash;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.evm.Code;
import org.hyperledger.besu.evm.code.CodeSection;
import org.hyperledger.besu.evm.internal.MemoryEntry;
import org.hyperledger.besu.evm.internal.OperandStack;
import org.hyperledger.besu.evm.internal.ReturnStack;
import org.hyperledger.besu.evm.internal.StorageEntry;
import org.hyperledger.besu.evm.internal.UnderflowException;
import org.hyperledger.besu.evm.log.Log;
import org.hyperledger.besu.evm.operation.Operation;
import org.hyperledger.besu.evm.worldstate.WorldUpdater;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import com.google.common.base.Suppliers;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Table;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.apache.tuweni.bytes.MutableBytes;
import org.apache.tuweni.units.bigints.UInt256;

/**
 * A container object for all the states associated with a message.
 *
 * &lt;p&gt;A message corresponds to an interaction between two accounts. A Transaction spawns at least
 * one message when it's processed. Messages can also spawn messages depending on the code executed
 * within a message.
 *
 * &lt;p&gt;Note that there is no specific Message object in the code base. Instead, message executions
 * correspond to a {@code MessageFrame} and a specific AbstractMessageProcessor. Currently, there
 * are two such AbstractMessageProcessor types:
 *
 * &lt;p&gt;&lt;b&gt;Message Call ({@code MESSAGE_CALL})&lt;/b&gt;
 *
 * &lt;p&gt;A message call consists of applying a set of changes to an account on behalf of another
 * account. At the minimal end of changes is a value transfer between a sender and recipient
 * account. If the recipient account contains code, that code is also executed.
 *
 * &lt;p&gt;&lt;b&gt;Contract Creation ({@code CONTRACT_CREATION})&lt;/b&gt;
 *
 * &lt;p&gt;A contract creation, as its name suggests, creates contract accounts. Contract initialization
 * code and a value are supplied to initialize the contract account code and balance, respectively.
 */
public class MessageFrame {

  /**
   * Message Frame State.
   *
   * &lt;h2&gt;Message Frame Lifecycle&lt;/h2&gt;
   *
   * &lt;p&gt;The diagram below presents the message frame lifecycle:
   *
   * &lt;pre&gt;
   *            ------------------------------------------------------
   *            |                                                    |
   *            |                                                    v
   *            |               ---------------------     ---------------------
   *            |               |                   |     |                   |
   *            |               |    CODE_SUCCESS   | --&amp;gt; | COMPLETED_SUCCESS |
   *            |               |                   |     |                   |
   *            |               ---------------------     ---------------------
   *            |                         ^
   *            |                         |
   *  ---------------------     ---------------------     ---------------------
   *  |                   |     |                   | --&amp;gt; |                   |
   *  |    NOT_STARTED    | --&amp;gt; |   CODE_EXECUTING  |     |   CODE_SUSPENDED  |
   *  |                   |     |                   | &amp;lt;-- |                   |
   *  ---------------------     ---------------------     ---------------------
   *            |                         |
   *            |                         |
   *            |                         |                 ---------------------
   *            |                         |                 |                   |
   *            |                         |------------&amp;gt; |      REVERTED     |
   *            |                         |                 |                   |
   *            |                         |                 ---------------------
   *            |                         |
   *            |                         v
   *            |               ---------------------     ---------------------
   *            |               |                   |     |                   |
   *            |-------------&amp;gt; |  EXCEPTIONAL_HALT | --&amp;gt; | COMPLETED_FAILURE |
   *                            |                   |     |                   |
   *                            ---------------------     ---------------------
   * &lt;/pre&gt;
   *
   * &lt;b&gt;Message Not Started ({@link #NOT_STARTED})&lt;/b&gt;
   *
   * &lt;p&gt;The message has not begun to execute yet.
   *
   * &lt;p&gt;&lt;b&gt;Code Executing ({@link #CODE_EXECUTING})&lt;/b&gt;
   *
   * &lt;p&gt;The message contains code and has begun executing it. The execution will continue until it
   * is halted due to (1) spawning a child message (2) encountering an exceptional halting condition
   * (2) completing successfully.
   *
   * &lt;p&gt;&lt;b&gt;Code Suspended Execution ({@link #CODE_SUSPENDED})&lt;/b&gt;
   *
   * &lt;p&gt;The message has spawned a child message and has suspended its execution until the child
   * message has completed and notified its parent message. The message will then continue executing
   * code ({@link #CODE_EXECUTING}) again.
   *
   * &lt;p&gt;&lt;b&gt;Code Execution Completed Successfully ({@link #CODE_SUSPENDED})&lt;/b&gt;
   *
   * &lt;p&gt;The code within the message has executed to completion successfully.
   *
   * &lt;p&gt;&lt;b&gt;Message Exceptionally Halted ({@link #EXCEPTIONAL_HALT})&lt;/b&gt;
   *
   * &lt;p&gt;The message execution has encountered an exceptional halting condition at some point during
   * its execution.
   *
   * &lt;p&gt;&lt;b&gt;Message Reverted ({@link #REVERT})&lt;/b&gt;
   *
   * &lt;p&gt;The message execution has requested to revert state during execution.
   *
   * &lt;p&gt;&lt;b&gt;Message Execution Failed ({@link #COMPLETED_FAILED})&lt;/b&gt;
   *
   * &lt;p&gt;The message execution failed to execute successfully; most likely due to encountering an
   * exceptional halting condition. At this point the message frame is finalized and the parent is
   * notified.
   *
   * &lt;p&gt;&lt;b&gt;Message Execution Completed Successfully ({@link #COMPLETED_SUCCESS})&lt;/b&gt;
   *
   * &lt;p&gt;The message execution completed successfully and needs to finalized and propagated to the
   * parent message that spawned it.
   */
<span class="fc" id="L163">  public enum State {</span>

    /** Message execution has not started. */
<span class="fc" id="L166">    NOT_STARTED,</span>

    /** Code execution within the message is in progress. */
<span class="fc" id="L169">    CODE_EXECUTING,</span>

    /** Code execution within the message has finished successfully. */
<span class="fc" id="L172">    CODE_SUCCESS,</span>

    /** Code execution within the message has been suspended. */
<span class="fc" id="L175">    CODE_SUSPENDED,</span>

    /** An exceptional halting condition has occurred. */
<span class="fc" id="L178">    EXCEPTIONAL_HALT,</span>

    /** State changes were reverted during execution. */
<span class="fc" id="L181">    REVERT,</span>

    /** The message execution has failed to complete successfully. */
<span class="fc" id="L184">    COMPLETED_FAILED,</span>

    /** The message execution has completed successfully. */
<span class="fc" id="L187">    COMPLETED_SUCCESS,</span>
  }

  /** The message type the frame corresponds to. */
<span class="fc" id="L191">  public enum Type {</span>

    /** A Contract creation message. */
<span class="fc" id="L194">    CONTRACT_CREATION,</span>

    /** A message call message. */
<span class="fc" id="L197">    MESSAGE_CALL,</span>
  }

  /** The constant DEFAULT_MAX_STACK_SIZE. */
  public static final int DEFAULT_MAX_STACK_SIZE = 1024;

  // Global data fields.
  private final WorldUpdater worldUpdater;

  // Metadata fields.
  private final Type type;
<span class="fc" id="L208">  private State state = State.NOT_STARTED;</span>

  // Machine state fields.
  private long gasRemaining;
  private int pc;
<span class="fc" id="L213">  private int section = 0;</span>
<span class="fc" id="L214">  private final Memory memory = new Memory();</span>
  private final OperandStack stack;
  private final Supplier&lt;ReturnStack&gt; returnStack;
<span class="fc" id="L217">  private Bytes output = Bytes.EMPTY;</span>
<span class="fc" id="L218">  private Bytes returnData = Bytes.EMPTY;</span>
  private final boolean isStatic;

  // Transaction state fields.
<span class="fc" id="L222">  private final List&lt;Log&gt; logs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L223">  private long gasRefund = 0L;</span>
<span class="fc" id="L224">  private final Map&lt;Address, Wei&gt; refunds = new HashMap&lt;&gt;();</span>

  // Execution Environment fields.
  private final Address recipient;
  private final Address contract;
  private final Bytes inputData;
  private final Address sender;
  private final Wei value;
  private final Wei apparentValue;
  private final Code code;

  private Optional&lt;Bytes&gt; revertReason;

  private final Map&lt;String, Object&gt; contextVariables;

<span class="fc" id="L239">  private Optional&lt;ExceptionalHaltReason&gt; exceptionalHaltReason = Optional.empty();</span>
  private Operation currentOperation;
  private final Consumer&lt;MessageFrame&gt; completer;
<span class="fc" id="L242">  private Optional&lt;MemoryEntry&gt; maybeUpdatedMemory = Optional.empty();</span>
<span class="fc" id="L243">  private Optional&lt;StorageEntry&gt; maybeUpdatedStorage = Optional.empty();</span>

  private final TxValues txValues;

  /** The mark of the undoable collections at the creation of this message frame */
  private final long undoMark;

  /**
   * Builder builder.
   *
   * @return the builder
   */
  public static Builder builder() {
<span class="fc" id="L256">    return new Builder();</span>
  }

  private MessageFrame(
      final Type type,
      final WorldUpdater worldUpdater,
      final long initialGas,
      final Address recipient,
      final Address contract,
      final Bytes inputData,
      final Address sender,
      final Wei value,
      final Wei apparentValue,
      final Code code,
      final boolean isStatic,
      final Consumer&lt;MessageFrame&gt; completer,
      final Map&lt;String, Object&gt; contextVariables,
      final Optional&lt;Bytes&gt; revertReason,
<span class="fc" id="L274">      final TxValues txValues) {</span>

<span class="fc" id="L276">    this.txValues = txValues;</span>
<span class="fc" id="L277">    this.type = type;</span>
<span class="fc" id="L278">    this.worldUpdater = worldUpdater;</span>
<span class="fc" id="L279">    this.gasRemaining = initialGas;</span>
<span class="fc" id="L280">    this.stack = new OperandStack(txValues.maxStackSize());</span>
<span class="fc" id="L281">    this.returnStack =</span>
<span class="fc" id="L282">        Suppliers.memoize(</span>
            () -&gt; {
<span class="fc" id="L284">              var rStack = new ReturnStack();</span>
<span class="fc" id="L285">              rStack.push(new ReturnStack.ReturnStackItem(0, 0, 0));</span>
<span class="fc" id="L286">              return rStack;</span>
            });
<span class="fc bfc" id="L288" title="All 2 branches covered.">    this.pc = code.isValid() ? code.getCodeSection(0).getEntryPoint() : 0;</span>
<span class="fc" id="L289">    this.recipient = recipient;</span>
<span class="fc" id="L290">    this.contract = contract;</span>
<span class="fc" id="L291">    this.inputData = inputData;</span>
<span class="fc" id="L292">    this.sender = sender;</span>
<span class="fc" id="L293">    this.value = value;</span>
<span class="fc" id="L294">    this.apparentValue = apparentValue;</span>
<span class="fc" id="L295">    this.code = code;</span>
<span class="fc" id="L296">    this.isStatic = isStatic;</span>
<span class="fc" id="L297">    this.completer = completer;</span>
<span class="fc" id="L298">    this.contextVariables = contextVariables;</span>
<span class="fc" id="L299">    this.revertReason = revertReason;</span>

<span class="fc" id="L301">    this.undoMark = txValues.transientStorage().mark();</span>
<span class="fc" id="L302">  }</span>

  /**
   * Return the program counter.
   *
   * @return the program counter
   */
  public int getPC() {
<span class="fc" id="L310">    return pc;</span>
  }

  /**
   * Set the program counter.
   *
   * @param pc The new program counter value
   */
  public void setPC(final int pc) {
<span class="fc" id="L319">    this.pc = pc;</span>
<span class="fc" id="L320">  }</span>

  /**
   * Set the code section index.
   *
   * @param section the code section index
   */
  public void setSection(final int section) {
<span class="fc" id="L328">    this.section = section;</span>
<span class="fc" id="L329">  }</span>

  /**
   * Return the current code section. Always zero for legacy code.
   *
   * @return the current code section
   */
  public int getSection() {
<span class="fc" id="L337">    return section;</span>
  }

  /**
   * Call function and return exceptional halt reason.
   *
   * @param calledSection the called section
   * @return the exceptional halt reason
   */
  public ExceptionalHaltReason callFunction(final int calledSection) {
<span class="fc" id="L347">    CodeSection info = code.getCodeSection(calledSection);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">    if (info == null) {</span>
<span class="fc" id="L349">      return ExceptionalHaltReason.CODE_SECTION_MISSING;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">    } else if (stack.size() + info.getMaxStackHeight() &gt; txValues.maxStackSize()) {</span>
<span class="fc" id="L351">      return ExceptionalHaltReason.TOO_MANY_STACK_ITEMS;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">    } else if (stack.size() &lt; info.getInputs()) {</span>
<span class="fc" id="L353">      return ExceptionalHaltReason.TOO_FEW_INPUTS_FOR_CODE_SECTION;</span>
    } else {
<span class="fc" id="L355">      returnStack</span>
<span class="fc" id="L356">          .get()</span>
<span class="fc" id="L357">          .push(new ReturnStack.ReturnStackItem(section, pc + 2, stack.size() - info.getInputs()));</span>
<span class="fc" id="L358">      pc = info.getEntryPoint() - 1; // will be +1ed at end of operations loop</span>
<span class="fc" id="L359">      this.section = calledSection;</span>
<span class="fc" id="L360">      return null;</span>
    }
  }

  /**
   * Execute the mechanics of the JUMPF operation.
   *
   * @param section the section
   * @return the exceptional halt reason, if the jump failed
   */
  public ExceptionalHaltReason jumpFunction(final int section) {
<span class="fc" id="L371">    CodeSection info = code.getCodeSection(section);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">    if (info == null) {</span>
<span class="fc" id="L373">      return ExceptionalHaltReason.CODE_SECTION_MISSING;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">    } else if (stackSize() != peekReturnStack().getStackHeight() + info.getInputs()) {</span>
<span class="fc" id="L375">      return ExceptionalHaltReason.JUMPF_STACK_MISMATCH;</span>
    } else {
<span class="fc" id="L377">      pc = -1; // will be +1ed at end of operations loop</span>
<span class="fc" id="L378">      this.section = section;</span>
<span class="fc" id="L379">      return null;</span>
    }
  }

  /**
   * Return function exceptional halt reason.
   *
   * @return the exceptional halt reason
   */
  public ExceptionalHaltReason returnFunction() {
<span class="fc" id="L389">    CodeSection thisInfo = code.getCodeSection(this.section);</span>
<span class="fc" id="L390">    var rStack = returnStack.get();</span>
<span class="fc" id="L391">    var returnInfo = rStack.pop();</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">    if ((returnInfo.getStackHeight() + thisInfo.getOutputs()) != stack.size()) {</span>
<span class="fc" id="L393">      return ExceptionalHaltReason.INCORRECT_CODE_SECTION_RETURN_OUTPUTS;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">    } else if (rStack.isEmpty()) {</span>
<span class="fc" id="L395">      setState(MessageFrame.State.CODE_SUCCESS);</span>
<span class="fc" id="L396">      setOutputData(Bytes.EMPTY);</span>
<span class="fc" id="L397">      return null;</span>
    } else {
<span class="fc" id="L399">      this.pc = returnInfo.getPC();</span>
<span class="fc" id="L400">      this.section = returnInfo.getCodeSectionIndex();</span>
<span class="fc" id="L401">      return null;</span>
    }
  }

  /** Deducts the remaining gas. */
  public void clearGasRemaining() {
<span class="fc" id="L407">    this.gasRemaining = 0L;</span>
<span class="fc" id="L408">  }</span>

  /**
   * Decrement the amount of remaining gas.
   *
   * @param amount The amount of gas to deduct
   * @return the amount of gas available, after deductions.
   */
  public long decrementRemainingGas(final long amount) {
<span class="fc" id="L417">    return this.gasRemaining -= amount;</span>
  }

  /**
   * Return the amount of remaining gas.
   *
   * @return the amount of remaining gas
   */
  public long getRemainingGas() {
<span class="fc" id="L426">    return gasRemaining;</span>
  }

  /**
   * Increment the amount of remaining gas.
   *
   * @param amount The amount of gas to increment
   */
  public void incrementRemainingGas(final long amount) {
<span class="fc" id="L435">    this.gasRemaining += amount;</span>
<span class="fc" id="L436">  }</span>

  /**
   * Set the amount of remaining gas.
   *
   * @param amount The amount of remaining gas
   */
  public void setGasRemaining(final long amount) {
<span class="fc" id="L444">    this.gasRemaining = amount;</span>
<span class="fc" id="L445">  }</span>

  /**
   * Return the output data.
   *
   * @return the output data
   */
  public Bytes getOutputData() {
<span class="fc" id="L453">    return output;</span>
  }

  /**
   * Set the output data.
   *
   * @param output The output data
   */
  public void setOutputData(final Bytes output) {
<span class="fc" id="L462">    this.output = output;</span>
<span class="fc" id="L463">  }</span>

  /** Clears the output data buffer. */
  public void clearOutputData() {
<span class="fc" id="L467">    setOutputData(Bytes.EMPTY);</span>
<span class="fc" id="L468">  }</span>

  /**
   * Return the return data.
   *
   * @return the return data
   */
  public Bytes getReturnData() {
<span class="fc" id="L476">    return returnData;</span>
  }

  /**
   * Set the return data.
   *
   * @param returnData The return data
   */
  public void setReturnData(final Bytes returnData) {
<span class="fc" id="L485">    this.returnData = returnData;</span>
<span class="fc" id="L486">  }</span>

  /** Clear the return data buffer. */
  public void clearReturnData() {
<span class="fc" id="L490">    setReturnData(Bytes.EMPTY);</span>
<span class="fc" id="L491">  }</span>

  /**
   * Returns the item at the specified offset in the stack.
   *
   * @param offset The item's position relative to the top of the stack
   * @return The item at the specified offset in the stack
   * @throws UnderflowException if the offset is out of range
   */
  public Bytes getStackItem(final int offset) {
<span class="fc" id="L501">    return stack.get(offset);</span>
  }

  /**
   * Removes the item at the top of the stack.
   *
   * @return the item at the top of the stack
   * @throws UnderflowException if the stack is empty
   */
  public Bytes popStackItem() {
<span class="fc" id="L511">    return stack.pop();</span>
  }

  /**
   * Removes the corresponding number of items from the top of the stack.
   *
   * @param n The number of items to pop off the stack
   */
  public void popStackItems(final int n) {
<span class="fc" id="L520">    stack.bulkPop(n);</span>
<span class="fc" id="L521">  }</span>

  /**
   * Pushes the corresponding item onto the top of the stack
   *
   * @param value The value to push onto the stack.
   */
  public void pushStackItem(final Bytes value) {
<span class="fc" id="L529">    stack.push(value);</span>
<span class="fc" id="L530">  }</span>

  /**
   * Sets the stack item at the specified offset from the top of the stack to the value
   *
   * @param offset The item's position relative to the top of the stack
   * @param value The value to set the stack item to
   * @throws IllegalStateException if the stack is too small
   */
  public void setStackItem(final int offset, final Bytes value) {
<span class="fc" id="L540">    stack.set(offset, value);</span>
<span class="fc" id="L541">  }</span>

  /**
   * Return the current stack size.
   *
   * @return The current stack size
   */
  public int stackSize() {
<span class="fc" id="L549">    return stack.size();</span>
  }

  /**
   * Return the current return stack size.
   *
   * @return The current return stack size
   */
  public int returnStackSize() {
<span class="fc" id="L558">    return returnStack.get().size();</span>
  }

  /**
   * The top item of the return stack
   *
   * @return The top item of the return stack, or null if the stack is empty
   */
  public ReturnStack.ReturnStackItem peekReturnStack() {
<span class="fc" id="L567">    return returnStack.get().peek();</span>
  }

  /**
   * Pushes a new return stack item onto the return stack
   *
   * @param returnStackItem item to be pushed
   */
  public void pushReturnStackItem(final ReturnStack.ReturnStackItem returnStackItem) {
<span class="fc" id="L576">    returnStack.get().push(returnStackItem);</span>
<span class="fc" id="L577">  }</span>

  /**
   * Returns whether the message frame is static or not.
   *
   * @return {@code} true if the frame is static; otherwise {@code false}
   */
  public boolean isStatic() {
<span class="fc" id="L585">    return isStatic;</span>
  }

  /**
   * Returns the memory size for specified memory access.
   *
   * @param offset The offset in memory
   * @param length The length of the memory access
   * @return the memory size for specified memory access
   */
  public long calculateMemoryExpansion(final long offset, final long length) {
<span class="fc" id="L596">    return memory.calculateNewActiveWords(offset, length);</span>
  }

  /**
   * Expands memory to accommodate the specified memory access.
   *
   * @param offset The offset in memory
   * @param length The length of the memory access
   */
  public void expandMemory(final long offset, final long length) {
<span class="fc" id="L606">    memory.ensureCapacityForBytes(offset, length);</span>
<span class="fc" id="L607">  }</span>

  /**
   * Returns the number of bytes in memory.
   *
   * @return the number of bytes in memory
   */
  public long memoryByteSize() {
<span class="fc" id="L615">    return memory.getActiveBytes();</span>
  }

  /**
   * Returns the number of words in memory.
   *
   * @return the number of words in memory
   */
  public int memoryWordSize() {
<span class="fc" id="L624">    return memory.getActiveWords();</span>
  }

  /**
   * Returns the revertReason as string
   *
   * @return the revertReason string
   */
  public Optional&lt;Bytes&gt; getRevertReason() {
<span class="fc" id="L633">    return revertReason;</span>
  }

  /**
   * Sets revert reason.
   *
   * @param revertReason the revert reason
   */
  public void setRevertReason(final Bytes revertReason) {
<span class="fc" id="L642">    this.revertReason = Optional.ofNullable(revertReason);</span>
<span class="fc" id="L643">  }</span>

  /**
   * Read bytes in memory as mutable. Contents should not be considered stable outside the scope of
   * the current operation.
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to read
   * @return The bytes in the specified range
   */
  public MutableBytes readMutableMemory(final long offset, final long length) {
<span class="fc" id="L654">    return readMutableMemory(offset, length, false);</span>
  }

  /**
   * Read bytes in memory without expanding the word capacity.
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to read
   * @return The bytes in the specified range
   */
  public Bytes shadowReadMemory(final long offset, final long length) {
<span class="fc" id="L665">    return memory.getBytesWithoutGrowth(offset, length);</span>
  }

  /**
   * Read bytes in memory .
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to read
   * @return The bytes in the specified range
   */
  public Bytes readMemory(final long offset, final long length) {
<span class="fc" id="L676">    return readMutableMemory(offset, length, false).copy();</span>
  }

  /**
   * Read bytes in memory. Contents should not be considered stable outside the scope of the current
   * operation.
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to read
   * @param explicitMemoryRead true if triggered by a memory opcode, false otherwise
   * @return The bytes in the specified range
   */
  public MutableBytes readMutableMemory(
      final long offset, final long length, final boolean explicitMemoryRead) {
<span class="fc" id="L690">    final MutableBytes memBytes = memory.getMutableBytes(offset, length);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">    if (explicitMemoryRead) {</span>
<span class="fc" id="L692">      setUpdatedMemory(offset, memBytes);</span>
    }
<span class="fc" id="L694">    return memBytes;</span>
  }

  /**
   * Write byte to memory
   *
   * @param offset The offset in memory
   * @param value The value to set in memory
   * @param explicitMemoryUpdate true if triggered by a memory opcode, false otherwise
   */
  public void writeMemory(final long offset, final byte value, final boolean explicitMemoryUpdate) {
<span class="fc" id="L705">    memory.setByte(offset, value);</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">    if (explicitMemoryUpdate) {</span>
<span class="fc" id="L707">      setUpdatedMemory(offset, Bytes.of(value));</span>
    }
<span class="fc" id="L709">  }</span>

  /**
   * Write bytes to memory
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to write
   * @param value The value to write
   */
  public void writeMemory(final long offset, final long length, final Bytes value) {
<span class="fc" id="L719">    writeMemory(offset, length, value, false);</span>
<span class="fc" id="L720">  }</span>

  /**
   * Write bytes to memory
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to write
   * @param value The value to write
   * @param explicitMemoryUpdate true if triggered by a memory opcode, false otherwise
   */
  public void writeMemory(
      final long offset, final long length, final Bytes value, final boolean explicitMemoryUpdate) {
<span class="fc" id="L732">    memory.setBytes(offset, length, value);</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">    if (explicitMemoryUpdate) {</span>
<span class="fc" id="L734">      setUpdatedMemory(offset, 0, length, value);</span>
    }
<span class="fc" id="L736">  }</span>

  /**
   * Copy the bytes from the value param into memory at the specified offset. In cases where the
   * value does not have numBytes bytes the appropriate amount of zero bytes will be added before
   * writing the value bytes.
   *
   * @param offset The offset in memory
   * @param length The length of the bytes to write
   * @param value The value to write
   * @param explicitMemoryUpdate true if triggered by a memory opcode, false otherwise
   */
  public void writeMemoryRightAligned(
      final long offset, final long length, final Bytes value, final boolean explicitMemoryUpdate) {
<span class="fc" id="L750">    memory.setBytesRightAligned(offset, length, value);</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">    if (explicitMemoryUpdate) {</span>
<span class="fc" id="L752">      setUpdatedMemoryRightAligned(offset, length, value);</span>
    }
<span class="fc" id="L754">  }</span>

  /**
   * Write bytes to memory
   *
   * @param offset The offset in memory to start writing
   * @param sourceOffset The offset in the source value to start writing
   * @param length The length of the bytes to write
   * @param value The value to write
   */
  public void writeMemory(
      final long offset, final long sourceOffset, final long length, final Bytes value) {
<span class="fc" id="L766">    writeMemory(offset, sourceOffset, length, value, false);</span>
<span class="fc" id="L767">  }</span>

  /**
   * Write bytes to memory
   *
   * @param offset The offset in memory to start writing
   * @param sourceOffset The offset in the source value to start writing
   * @param length The length of the bytes to write
   * @param value The value to write
   * @param explicitMemoryUpdate true if triggered by a memory opcode, false otherwise
   */
  public void writeMemory(
      final long offset,
      final long sourceOffset,
      final long length,
      final Bytes value,
      final boolean explicitMemoryUpdate) {
<span class="fc" id="L784">    memory.setBytes(offset, sourceOffset, length, value);</span>
<span class="fc bfc" id="L785" title="All 4 branches covered.">    if (explicitMemoryUpdate &amp;&amp; length &gt; 0) {</span>
<span class="fc" id="L786">      setUpdatedMemory(offset, sourceOffset, length, value);</span>
    }
<span class="fc" id="L788">  }</span>

  /**
   * Copies bytes within memory.
   *
   * &lt;p&gt;Copying behaves as if the values are copied to an intermediate buffer before writing.
   *
   * @param dst The destination address
   * @param src The source address
   * @param length the number of bytes to copy
   * @param explicitMemoryUpdate true if triggered by a memory opcode, false otherwise
   */
  public void copyMemory(
      final long dst, final long src, final long length, final boolean explicitMemoryUpdate) {
<span class="fc bfc" id="L802" title="All 2 branches covered.">    if (length &gt; 0) {</span>
<span class="fc" id="L803">      memory.copy(dst, src, length);</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">      if (explicitMemoryUpdate) {</span>
<span class="fc" id="L805">        setUpdatedMemory(dst, memory.getBytes(dst, length));</span>
      }
    }
<span class="fc" id="L808">  }</span>

  private void setUpdatedMemory(
      final long offset, final long sourceOffset, final long length, final Bytes value) {
<span class="fc" id="L812">    final long endIndex = sourceOffset + length;</span>
<span class="pc bpc" id="L813" title="1 of 4 branches missed.">    if (sourceOffset &gt;= 0 &amp;&amp; endIndex &gt; 0) {</span>
<span class="fc" id="L814">      final int srcSize = value.size();</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">      if (endIndex &gt; srcSize) {</span>
<span class="fc" id="L816">        final MutableBytes paddedAnswer = MutableBytes.create((int) length);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (sourceOffset &lt; srcSize) {</span>
<span class="fc" id="L818">          value.slice((int) sourceOffset, (int) (srcSize - sourceOffset)).copyTo(paddedAnswer, 0);</span>
        }
<span class="fc" id="L820">        setUpdatedMemory(offset, paddedAnswer.copy());</span>
<span class="fc" id="L821">      } else {</span>
<span class="fc" id="L822">        setUpdatedMemory(offset, value.slice((int) sourceOffset, (int) length).copy());</span>
      }
    }
<span class="fc" id="L825">  }</span>

  private void setUpdatedMemoryRightAligned(
      final long offset, final long length, final Bytes value) {
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">    if (length &gt; 0) {</span>
<span class="fc" id="L830">      final int srcSize = value.size();</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">      if (length &gt; srcSize) {</span>
<span class="fc" id="L832">        final MutableBytes paddedAnswer = MutableBytes.create((int) length);</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">        if ((long) 0 &lt; srcSize) {</span>
<span class="fc" id="L834">          value.slice(0, srcSize).copyTo(paddedAnswer, (int) (length - srcSize));</span>
        }
<span class="fc" id="L836">        setUpdatedMemory(offset, paddedAnswer.copy());</span>
<span class="fc" id="L837">      } else {</span>
<span class="fc" id="L838">        setUpdatedMemory(offset, value.slice(0, (int) length).copy());</span>
      }
    }
<span class="fc" id="L841">  }</span>

  private void setUpdatedMemory(final long offset, final Bytes value) {
<span class="fc" id="L844">    maybeUpdatedMemory = Optional.of(new MemoryEntry(offset, value));</span>
<span class="fc" id="L845">  }</span>

  /**
   * Storage was updated.
   *
   * @param storageAddress the storage address
   * @param value the value
   */
  public void storageWasUpdated(final UInt256 storageAddress, final Bytes value) {
<span class="fc" id="L854">    maybeUpdatedStorage = Optional.of(new StorageEntry(storageAddress, value));</span>
<span class="fc" id="L855">  }</span>

  /**
   * Accumulate a log.
   *
   * @param log The log to accumulate
   */
  public void addLog(final Log log) {
<span class="fc" id="L863">    logs.add(log);</span>
<span class="fc" id="L864">  }</span>

  /**
   * Accumulate logs.
   *
   * @param logs The logs to accumulate
   */
  public void addLogs(final List&lt;Log&gt; logs) {
<span class="fc" id="L872">    this.logs.addAll(logs);</span>
<span class="fc" id="L873">  }</span>

  /** Clear the accumulated logs. */
  public void clearLogs() {
<span class="fc" id="L877">    logs.clear();</span>
<span class="fc" id="L878">  }</span>

  /**
   * Return the accumulated logs.
   *
   * @return the accumulated logs
   */
  public List&lt;Log&gt; getLogs() {
<span class="fc" id="L886">    return logs;</span>
  }

  /**
   * Increment the gas refund.
   *
   * @param amount The amount to increment the refund
   */
  public void incrementGasRefund(final long amount) {
<span class="fc" id="L895">    this.gasRefund += amount;</span>
<span class="fc" id="L896">  }</span>

  /** Clear the accumulated gas refund. */
  public void clearGasRefund() {
<span class="fc" id="L900">    gasRefund = 0L;</span>
<span class="fc" id="L901">  }</span>

  /**
   * Return the accumulated gas refund.
   *
   * @return accumulated gas refund
   */
  public long getGasRefund() {
<span class="fc" id="L909">    return gasRefund;</span>
  }

  /**
   * Add recipient to the self-destruct set if not already present.
   *
   * @param address The recipient to self-destruct
   */
  public void addSelfDestruct(final Address address) {
<span class="fc" id="L918">    txValues.selfDestructs().add(address);</span>
<span class="fc" id="L919">  }</span>

  /**
   * Add addresses to the self-destruct set if they are not already present.
   *
   * @param addresses The addresses to self-destruct
   */
  public void addSelfDestructs(final Set&lt;Address&gt; addresses) {
<span class="fc" id="L927">    txValues.selfDestructs().addAll(addresses);</span>
<span class="fc" id="L928">  }</span>

  /**
   * Returns the self-destruct set.
   *
   * @return the self-destruct set
   */
  public Set&lt;Address&gt; getSelfDestructs() {
<span class="fc" id="L936">    return txValues.selfDestructs();</span>
  }

  /**
   * Add recipient to the create set if not already present.
   *
   * @param address The recipient to create
   */
  public void addCreate(final Address address) {
<span class="fc" id="L945">    txValues.creates().add(address);</span>
<span class="fc" id="L946">  }</span>
  /**
   * Add addresses to the create set if they are not already present.
   *
   * @param addresses The addresses to create
   */
  public void addCreates(final Set&lt;Address&gt; addresses) {
<span class="fc" id="L953">    txValues.creates().addAll(addresses);</span>
<span class="fc" id="L954">  }</span>

  /**
   * Returns the create set.
   *
   * @return the create set
   */
  public Set&lt;Address&gt; getCreates() {
<span class="fc" id="L962">    return txValues.creates();</span>
  }

  /**
   * Was the account at this address created in this transaction? (in any of the previously executed
   * message frames in this transaction).
   *
   * @param address the address to check
   * @return true if the account was created in any parent or prior message frame in this
   *     transaction. False if the account existed in the world state at the beginning of the
   *     transaction.
   */
  public boolean wasCreatedInTransaction(final Address address) {
<span class="fc" id="L975">    return txValues.creates().contains((address));</span>
  }

  /**
   * Add refund to the refunds map if not already present.
   *
   * @param beneficiary the beneficiary of the refund.
   * @param amount the amount of the refund.
   */
  public void addRefund(final Address beneficiary, final Wei amount) {
<span class="fc" id="L985">    refunds.put(beneficiary, amount);</span>
<span class="fc" id="L986">  }</span>

  /**
   * Returns the refunds map.
   *
   * @return the refunds map
   */
  public Map&lt;Address, Wei&gt; getRefunds() {
<span class="fc" id="L994">    return refunds;</span>
  }

  /**
   * &quot;Warms up&quot; the address as per EIP-2929
   *
   * @param address the address to warm up
   * @return true if the address was already warmed up
   */
  public boolean warmUpAddress(final Address address) {
<span class="fc bfc" id="L1004" title="All 2 branches covered.">    return !txValues.warmedUpAddresses().add(address);</span>
  }

  /**
   * Returns whether an address has been warmed up. Is deliberately publicly exposed for access from
   * tracers.
   *
   * @param address the address context
   * @return whether the address has been warmed up
   */
  public boolean isAddressWarm(final Address address) {
<span class="nc" id="L1015">    return txValues.warmedUpAddresses().contains(address);</span>
  }

  /**
   * &quot;Warms up&quot; the storage slot as per EIP-2929
   *
   * @param address the address whose storage is being warmed up
   * @param slot the slot being warmed up
   * @return true if the storage slot was already warmed up
   */
  public boolean warmUpStorage(final Address address, final Bytes32 slot) {
<span class="fc bfc" id="L1026" title="All 2 branches covered.">    return txValues.warmedUpStorage().put(address, slot, Boolean.TRUE) != null;</span>
  }

  /**
   * Returns whether an address' slot is warmed up. Is deliberately publicly exposed for access from
   * trace
   *
   * @param address the address context
   * @param slot the slot to query
   * @return whether the address/slot couple is warmed up
   */
  public boolean isStorageWarm(final Address address, final Bytes32 slot) {
<span class="nc" id="L1038">    return this.txValues.warmedUpStorage().contains(address, slot);</span>
  }

  /**
   * Return the world state.
   *
   * @return the world state
   */
  public WorldUpdater getWorldUpdater() {
<span class="fc" id="L1047">    return worldUpdater;</span>
  }

  /**
   * Returns the message frame type.
   *
   * @return the message frame type
   */
  public Type getType() {
<span class="fc" id="L1056">    return type;</span>
  }

  /**
   * Returns the current execution state.
   *
   * @return the current execution state
   */
  public State getState() {
<span class="fc" id="L1065">    return state;</span>
  }

  /**
   * Sets the current execution state.
   *
   * @param state The new execution state
   */
  public void setState(final State state) {
<span class="fc" id="L1074">    this.state = state;</span>
<span class="fc" id="L1075">  }</span>

  /**
   * Returns the code currently being executed.
   *
   * @return the code currently being executed
   */
  public Code getCode() {
<span class="fc" id="L1083">    return code;</span>
  }

  /**
   * Returns the current input data.
   *
   * @return the current input data
   */
  public Bytes getInputData() {
<span class="fc" id="L1092">    return inputData;</span>
  }

  /**
   * Returns the recipient account recipient
   *
   * @return the callee account recipient
   */
  public Address getRecipientAddress() {
<span class="fc" id="L1101">    return recipient;</span>
  }

  /**
   * Returns the message stack size.
   *
   * @return the message stack size
   */
  public int getMessageStackSize() {
<span class="fc" id="L1110">    return txValues.messageFrameStack().size();</span>
  }

  /**
   * Returns the Call Depth, where the rootmost call is depth 0
   *
   * @return the call depth
   */
  public int getDepth() {
<span class="fc" id="L1119">    return getMessageStackSize() - 1;</span>
  }
  /**
   * Returns the recipient that originated the message.
   *
   * @return the recipient that originated the message
   */
  public Address getOriginatorAddress() {
<span class="fc" id="L1127">    return txValues.originator();</span>
  }

  /**
   * Returns the recipient of the code currently executing.
   *
   * @return the recipient of the code currently executing
   */
  public Address getContractAddress() {
<span class="fc" id="L1136">    return contract;</span>
  }

  /**
   * Returns the current gas price.
   *
   * @return the current gas price
   */
  public Wei getGasPrice() {
<span class="fc" id="L1145">    return txValues.gasPrice();</span>
  }

  /**
   * Returns the current blob gas price.
   *
   * @return the current blob gas price
   */
  public Wei getBlobGasPrice() {
<span class="fc" id="L1154">    return txValues.blobGasPrice();</span>
  }

  /**
   * Returns the recipient of the sender.
   *
   * @return the recipient of the sender
   */
  public Address getSenderAddress() {
<span class="fc" id="L1163">    return sender;</span>
  }

  /**
   * Returns the value being transferred.
   *
   * @return the value being transferred
   */
  public Wei getValue() {
<span class="fc" id="L1172">    return value;</span>
  }

  /**
   * Returns the apparent value being transferred.
   *
   * @return the apparent value being transferred
   */
  public Wei getApparentValue() {
<span class="fc" id="L1181">    return apparentValue;</span>
  }

  /**
   * Returns the current block header.
   *
   * @return the current block header
   */
  public BlockValues getBlockValues() {
<span class="fc" id="L1190">    return txValues.blockValues();</span>
  }

  /** Performs updates based on the message frame's execution. */
  public void notifyCompletion() {
<span class="fc" id="L1195">    completer.accept(this);</span>
<span class="fc" id="L1196">  }</span>

  /**
   * Returns the current message frame stack.
   *
   * @return the current message frame stack
   */
  public Deque&lt;MessageFrame&gt; getMessageFrameStack() {
<span class="fc" id="L1204">    return txValues.messageFrameStack();</span>
  }

  /**
   * Sets exceptional halt reason.
   *
   * @param exceptionalHaltReason the exceptional halt reason
   */
  public void setExceptionalHaltReason(
      final Optional&lt;ExceptionalHaltReason&gt; exceptionalHaltReason) {
<span class="fc" id="L1214">    this.exceptionalHaltReason = exceptionalHaltReason;</span>
<span class="fc" id="L1215">  }</span>

  /**
   * Gets exceptional halt reason.
   *
   * @return the exceptional halt reason
   */
  public Optional&lt;ExceptionalHaltReason&gt; getExceptionalHaltReason() {
<span class="fc" id="L1223">    return exceptionalHaltReason;</span>
  }

  /**
   * Returns the current miningBeneficiary (aka coinbase)
   *
   * @return the current mining beneficiary
   */
  public Address getMiningBeneficiary() {
<span class="fc" id="L1232">    return txValues.miningBeneficiary();</span>
  }

  /**
   * Gets block hash lookup.
   *
   * @return the block hash lookup
   */
  public Function&lt;Long, Hash&gt; getBlockHashLookup() {
<span class="fc" id="L1241">    return txValues.blockHashLookup();</span>
  }

  /**
   * Gets current operation.
   *
   * @return the current operation
   */
  public Operation getCurrentOperation() {
<span class="fc" id="L1250">    return currentOperation;</span>
  }

  /**
   * Gets max stack size.
   *
   * @return the max stack size
   */
  public int getMaxStackSize() {
<span class="fc" id="L1259">    return txValues.maxStackSize();</span>
  }

  /**
   * Gets context variable.
   *
   * @param &lt;T&gt; the type parameter
   * @param name the name
   * @return the context variable
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;TypeParameterUnusedInFormals&quot;})
  public &lt;T&gt; T getContextVariable(final String name) {
<span class="fc" id="L1271">    return (T) contextVariables.get(name);</span>
  }

  /**
   * Gets context variable.
   *
   * @param &lt;T&gt; the type parameter
   * @param name the name
   * @param defaultValue the default value
   * @return the context variable
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public &lt;T&gt; T getContextVariable(final String name, final T defaultValue) {
<span class="fc" id="L1284">    return (T) contextVariables.getOrDefault(name, defaultValue);</span>
  }

  /**
   * Has context variable.
   *
   * @param name the name
   * @return the boolean
   */
  public boolean hasContextVariable(final String name) {
<span class="fc" id="L1294">    return contextVariables.containsKey(name);</span>
  }

  /**
   * Sets current operation.
   *
   * @param currentOperation the current operation
   */
  public void setCurrentOperation(final Operation currentOperation) {
<span class="fc" id="L1303">    this.currentOperation = currentOperation;</span>
<span class="fc" id="L1304">  }</span>

  /**
   * Gets warmedUp Storage.
   *
   * @return the warmed up storage
   */
  public Table&lt;Address, Bytes32, Boolean&gt; getWarmedUpStorage() {
<span class="nc" id="L1312">    return txValues.warmedUpStorage();</span>
  }

  /**
   * Gets maybe updated memory.
   *
   * @return the maybe updated memory
   */
  public Optional&lt;MemoryEntry&gt; getMaybeUpdatedMemory() {
<span class="fc" id="L1321">    return maybeUpdatedMemory;</span>
  }

  /**
   * Gets maybe updated storage.
   *
   * @return the maybe updated storage
   */
  public Optional&lt;StorageEntry&gt; getMaybeUpdatedStorage() {
<span class="fc" id="L1330">    return maybeUpdatedStorage;</span>
  }

  /**
   * Gets the transient storage value, including values from parent frames if not set
   *
   * @param accountAddress The address of the executing context
   * @param slot the slot to retrieve
   * @return the data value read
   */
  public Bytes32 getTransientStorageValue(final Address accountAddress, final Bytes32 slot) {
<span class="fc" id="L1341">    Bytes32 v = txValues.transientStorage().get(accountAddress, slot);</span>
<span class="fc bfc" id="L1342" title="All 2 branches covered.">    return v == null ? Bytes32.ZERO : v;</span>
  }

  /**
   * Gets the transient storage value, including values from parent frames if not set
   *
   * @param accountAddress The address of the executing context
   * @param slot the slot to set
   * @param value the value to set in the transient store
   */
  public void setTransientStorageValue(
      final Address accountAddress, final Bytes32 slot, final Bytes32 value) {
<span class="fc" id="L1354">    txValues.transientStorage().put(accountAddress, slot, value);</span>
<span class="fc" id="L1355">  }</span>

  /** Undo all the changes done by this message frame, such as when a revert is called for. */
  public void rollback() {
<span class="fc" id="L1359">    txValues.undoChanges(undoMark);</span>
<span class="fc" id="L1360">  }</span>

  /**
   * Accessor for versionedHashes, if present.
   *
   * @return optional list of hashes
   */
  public Optional&lt;List&lt;VersionedHash&gt;&gt; getVersionedHashes() {
<span class="fc" id="L1368">    return txValues.versionedHashes();</span>
  }

  /** Reset. */
  public void reset() {
<span class="fc" id="L1373">    maybeUpdatedMemory = Optional.empty();</span>
<span class="fc" id="L1374">    maybeUpdatedStorage = Optional.empty();</span>
<span class="fc" id="L1375">  }</span>

  /** The MessageFrame Builder. */
<span class="fc" id="L1378">  public static class Builder {</span>

    private MessageFrame parentMessageFrame;
    private Type type;
    private WorldUpdater worldUpdater;
    private Long initialGas;
    private Address address;
    private Address originator;
    private Address contract;
    private Wei gasPrice;
<span class="fc" id="L1388">    private Wei blobGasPrice = Wei.ZERO;</span>
    private Bytes inputData;
    private Address sender;
    private Wei value;
    private Wei apparentValue;
    private Code code;
    private BlockValues blockValues;
<span class="fc" id="L1395">    private int maxStackSize = DEFAULT_MAX_STACK_SIZE;</span>
<span class="fc" id="L1396">    private boolean isStatic = false;</span>
    private Consumer&lt;MessageFrame&gt; completer;
    private Address miningBeneficiary;
    private Function&lt;Long, Hash&gt; blockHashLookup;
    private Map&lt;String, Object&gt; contextVariables;
<span class="fc" id="L1401">    private Optional&lt;Bytes&gt; reason = Optional.empty();</span>
<span class="fc" id="L1402">    private Set&lt;Address&gt; accessListWarmAddresses = emptySet();</span>
<span class="fc" id="L1403">    private Multimap&lt;Address, Bytes32&gt; accessListWarmStorage = HashMultimap.create();</span>

<span class="fc" id="L1405">    private Optional&lt;List&lt;VersionedHash&gt;&gt; versionedHashes = Optional.empty();</span>

    /**
     * The &quot;parent&quot; message frame. When present some fields will be populated from the parent and
     * ignored if passed in via builder
     *
     * @param parentMessageFrame the parent message frame
     * @return the builder
     */
    public Builder parentMessageFrame(final MessageFrame parentMessageFrame) {
<span class="fc" id="L1415">      this.parentMessageFrame = parentMessageFrame;</span>
<span class="fc" id="L1416">      return this;</span>
    }

    /**
     * Sets Type.
     *
     * @param type the type
     * @return the builder
     */
    public Builder type(final Type type) {
<span class="fc" id="L1426">      this.type = type;</span>
<span class="fc" id="L1427">      return this;</span>
    }

    /**
     * Sets World updater.
     *
     * @param worldUpdater the world updater
     * @return the builder
     */
    public Builder worldUpdater(final WorldUpdater worldUpdater) {
<span class="fc" id="L1437">      this.worldUpdater = worldUpdater;</span>
<span class="fc" id="L1438">      return this;</span>
    }

    /**
     * Sets Initial gas.
     *
     * @param initialGas the initial gas
     * @return the builder
     */
    public Builder initialGas(final long initialGas) {
<span class="fc" id="L1448">      this.initialGas = initialGas;</span>
<span class="fc" id="L1449">      return this;</span>
    }

    /**
     * Sets Address.
     *
     * @param address the address
     * @return the builder
     */
    public Builder address(final Address address) {
<span class="fc" id="L1459">      this.address = address;</span>
<span class="fc" id="L1460">      return this;</span>
    }

    /**
     * Sets Originator.
     *
     * @param originator the originator
     * @return the builder
     */
    public Builder originator(final Address originator) {
<span class="fc" id="L1470">      this.originator = originator;</span>
<span class="fc" id="L1471">      return this;</span>
    }

    /**
     * Sets Contract.
     *
     * @param contract the contract
     * @return the builder
     */
    public Builder contract(final Address contract) {
<span class="fc" id="L1481">      this.contract = contract;</span>
<span class="fc" id="L1482">      return this;</span>
    }

    /**
     * Sets Gas price.
     *
     * @param gasPrice the gas price
     * @return the builder
     */
    public Builder gasPrice(final Wei gasPrice) {
<span class="fc" id="L1492">      this.gasPrice = gasPrice;</span>
<span class="fc" id="L1493">      return this;</span>
    }

    /**
     * Sets Blob Gas price.
     *
     * @param blobGasPrice the blob gas price
     * @return the builder
     */
    public Builder blobGasPrice(final Wei blobGasPrice) {
<span class="fc" id="L1503">      this.blobGasPrice = blobGasPrice;</span>
<span class="fc" id="L1504">      return this;</span>
    }

    /**
     * Sets Input data.
     *
     * @param inputData the input data
     * @return the builder
     */
    public Builder inputData(final Bytes inputData) {
<span class="fc" id="L1514">      this.inputData = inputData;</span>
<span class="fc" id="L1515">      return this;</span>
    }

    /**
     * Sets Sender address.
     *
     * @param sender the sender
     * @return the builder
     */
    public Builder sender(final Address sender) {
<span class="fc" id="L1525">      this.sender = sender;</span>
<span class="fc" id="L1526">      return this;</span>
    }

    /**
     * Sets Value.
     *
     * @param value the value
     * @return the builder
     */
    public Builder value(final Wei value) {
<span class="fc" id="L1536">      this.value = value;</span>
<span class="fc" id="L1537">      return this;</span>
    }

    /**
     * Sets Apparent value.
     *
     * @param apparentValue the apparent value
     * @return the builder
     */
    public Builder apparentValue(final Wei apparentValue) {
<span class="fc" id="L1547">      this.apparentValue = apparentValue;</span>
<span class="fc" id="L1548">      return this;</span>
    }

    /**
     * Sets Code.
     *
     * @param code the code
     * @return the builder
     */
    public Builder code(final Code code) {
<span class="fc" id="L1558">      this.code = code;</span>
<span class="fc" id="L1559">      return this;</span>
    }

    /**
     * Sets Block values.
     *
     * @param blockValues the block values
     * @return the builder
     */
    public Builder blockValues(final BlockValues blockValues) {
<span class="fc" id="L1569">      this.blockValues = blockValues;</span>
<span class="fc" id="L1570">      return this;</span>
    }

    /**
     * Sets Is static.
     *
     * @param isStatic the is static
     * @return the builder
     */
    public Builder isStatic(final boolean isStatic) {
<span class="fc" id="L1580">      this.isStatic = isStatic;</span>
<span class="fc" id="L1581">      return this;</span>
    }

    /**
     * Sets Max stack size.
     *
     * @param maxStackSize the max stack size
     * @return the builder
     */
    public Builder maxStackSize(final int maxStackSize) {
<span class="fc" id="L1591">      this.maxStackSize = maxStackSize;</span>
<span class="fc" id="L1592">      return this;</span>
    }

    /**
     * Sets Completer.
     *
     * @param completer the completer
     * @return the builder
     */
    public Builder completer(final Consumer&lt;MessageFrame&gt; completer) {
<span class="fc" id="L1602">      this.completer = completer;</span>
<span class="fc" id="L1603">      return this;</span>
    }

    /**
     * Sets Mining beneficiary.
     *
     * @param miningBeneficiary the mining beneficiary
     * @return the builder
     */
    public Builder miningBeneficiary(final Address miningBeneficiary) {
<span class="fc" id="L1613">      this.miningBeneficiary = miningBeneficiary;</span>
<span class="fc" id="L1614">      return this;</span>
    }

    /**
     * Sets Block hash lookup.
     *
     * @param blockHashLookup the block hash lookup
     * @return the builder
     */
    public Builder blockHashLookup(final Function&lt;Long, Hash&gt; blockHashLookup) {
<span class="fc" id="L1624">      this.blockHashLookup = blockHashLookup;</span>
<span class="fc" id="L1625">      return this;</span>
    }

    /**
     * Sets Context variables.
     *
     * @param contextVariables the context variables
     * @return the builder
     */
    public Builder contextVariables(final Map&lt;String, Object&gt; contextVariables) {
<span class="fc" id="L1635">      this.contextVariables = contextVariables;</span>
<span class="fc" id="L1636">      return this;</span>
    }

    /**
     * Sets Reason.
     *
     * @param reason the reason
     * @return the builder
     */
    public Builder reason(final Bytes reason) {
<span class="nc" id="L1646">      this.reason = Optional.ofNullable(reason);</span>
<span class="nc" id="L1647">      return this;</span>
    }

    /**
     * Sets Access list warm addresses.
     *
     * @param accessListWarmAddresses the access list warm addresses
     * @return the builder
     */
    public Builder accessListWarmAddresses(final Set&lt;Address&gt; accessListWarmAddresses) {
<span class="fc" id="L1657">      this.accessListWarmAddresses = accessListWarmAddresses;</span>
<span class="fc" id="L1658">      return this;</span>
    }

    /**
     * Sets Access list warm storage.
     *
     * @param accessListWarmStorage the access list warm storage
     * @return the builder
     */
    public Builder accessListWarmStorage(final Multimap&lt;Address, Bytes32&gt; accessListWarmStorage) {
<span class="fc" id="L1668">      this.accessListWarmStorage = accessListWarmStorage;</span>
<span class="fc" id="L1669">      return this;</span>
    }

    /**
     * Sets versioned hashes list.
     *
     * @param versionedHashes the Optional list of versioned hashes
     * @return the builder
     */
    public Builder versionedHashes(final Optional&lt;List&lt;VersionedHash&gt;&gt; versionedHashes) {
<span class="fc" id="L1679">      this.versionedHashes = versionedHashes;</span>
<span class="fc" id="L1680">      return this;</span>
    }

    private void validate() {
<span class="fc bfc" id="L1684" title="All 2 branches covered.">      if (parentMessageFrame == null) {</span>
<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">        checkState(worldUpdater != null, &quot;Missing message frame world updater&quot;);</span>
<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">        checkState(originator != null, &quot;Missing message frame originator&quot;);</span>
<span class="pc bpc" id="L1687" title="1 of 2 branches missed.">        checkState(gasPrice != null, &quot;Missing message frame getGasRemaining price&quot;);</span>
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">        checkState(blobGasPrice != null, &quot;Missing message frame blob gas price&quot;);</span>
<span class="pc bpc" id="L1689" title="1 of 2 branches missed.">        checkState(blockValues != null, &quot;Missing message frame block header&quot;);</span>
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">        checkState(miningBeneficiary != null, &quot;Missing mining beneficiary&quot;);</span>
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">        checkState(blockHashLookup != null, &quot;Missing block hash lookup&quot;);</span>
      }
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">      checkState(type != null, &quot;Missing message frame type&quot;);</span>
<span class="pc bpc" id="L1694" title="1 of 2 branches missed.">      checkState(initialGas != null, &quot;Missing message frame initial getGasRemaining&quot;);</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">      checkState(address != null, &quot;Missing message frame recipient&quot;);</span>
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">      checkState(contract != null, &quot;Missing message frame contract&quot;);</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">      checkState(inputData != null, &quot;Missing message frame input data&quot;);</span>
<span class="pc bpc" id="L1698" title="1 of 2 branches missed.">      checkState(sender != null, &quot;Missing message frame sender&quot;);</span>
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">      checkState(value != null, &quot;Missing message frame value&quot;);</span>
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">      checkState(apparentValue != null, &quot;Missing message frame apparent value&quot;);</span>
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">      checkState(code != null, &quot;Missing message frame code&quot;);</span>
<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">      checkState(completer != null, &quot;Missing message frame completer&quot;);</span>
<span class="fc" id="L1703">    }</span>

    /**
     * Build MessageFrame.
     *
     * @return instance of MessageFrame
     */
    public MessageFrame build() {
<span class="fc" id="L1711">      validate();</span>

      WorldUpdater updater;
      boolean newStatic;
      TxValues newTxValues;
<span class="fc bfc" id="L1716" title="All 2 branches covered.">      if (parentMessageFrame == null) {</span>
<span class="fc" id="L1717">        newTxValues =</span>
            new TxValues(
                blockHashLookup,
                maxStackSize,
<span class="fc" id="L1721">                UndoSet.of(new BytesTrieSet&lt;&gt;(Address.SIZE)),</span>
<span class="fc" id="L1722">                UndoTable.of(HashBasedTable.create()),</span>
                originator,
                gasPrice,
                blobGasPrice,
                blockValues,
                new ArrayDeque&lt;&gt;(),
                miningBeneficiary,
                versionedHashes,
<span class="fc" id="L1730">                UndoTable.of(HashBasedTable.create()),</span>
<span class="fc" id="L1731">                UndoSet.of(new BytesTrieSet&lt;&gt;(Address.SIZE)),</span>
<span class="fc" id="L1732">                UndoSet.of(new BytesTrieSet&lt;&gt;(Address.SIZE)));</span>
<span class="fc" id="L1733">        updater = worldUpdater;</span>
<span class="fc" id="L1734">        newStatic = isStatic;</span>
      } else {
<span class="fc" id="L1736">        newTxValues = parentMessageFrame.txValues;</span>
<span class="fc" id="L1737">        updater = parentMessageFrame.worldUpdater.updater();</span>
<span class="pc bpc" id="L1738" title="1 of 4 branches missed.">        newStatic = isStatic || parentMessageFrame.isStatic;</span>
      }

<span class="fc" id="L1741">      MessageFrame messageFrame =</span>
          new MessageFrame(
              type,
              updater,
<span class="fc" id="L1745">              initialGas,</span>
              address,
              contract,
              inputData,
              sender,
              value,
              apparentValue,
              code,
              newStatic,
              completer,
<span class="fc bfc" id="L1755" title="All 2 branches covered.">              contextVariables == null ? Map.of() : contextVariables,</span>
              reason,
              newTxValues);
<span class="fc" id="L1758">      newTxValues.messageFrameStack().addFirst(messageFrame);</span>
<span class="fc" id="L1759">      messageFrame.warmUpAddress(sender);</span>
<span class="fc" id="L1760">      messageFrame.warmUpAddress(contract);</span>
<span class="fc bfc" id="L1761" title="All 2 branches covered.">      for (Address a : accessListWarmAddresses) {</span>
<span class="fc" id="L1762">        messageFrame.warmUpAddress(a);</span>
<span class="fc" id="L1763">      }</span>
<span class="fc bfc" id="L1764" title="All 2 branches covered.">      for (var e : accessListWarmStorage.entries()) {</span>
<span class="fc" id="L1765">        messageFrame.warmUpStorage(e.getKey(), e.getValue());</span>
<span class="fc" id="L1766">      }</span>
<span class="fc" id="L1767">      return messageFrame;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>