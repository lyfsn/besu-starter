<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NoOpMetricsSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.metrics.noop</a> &gt; <span class="el_source">NoOpMetricsSystem.java</span></div><h1>NoOpMetricsSystem.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.metrics.noop;

import org.hyperledger.besu.metrics.ObservableMetricsSystem;
import org.hyperledger.besu.metrics.Observation;
import org.hyperledger.besu.plugin.services.metrics.Counter;
import org.hyperledger.besu.plugin.services.metrics.LabelledGauge;
import org.hyperledger.besu.plugin.services.metrics.LabelledMetric;
import org.hyperledger.besu.plugin.services.metrics.MetricCategory;
import org.hyperledger.besu.plugin.services.metrics.OperationTimer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.function.DoubleSupplier;
import java.util.stream.Stream;

import com.google.common.base.Preconditions;

/** The NoOp metrics system. */
<span class="fc" id="L35">public class NoOpMetricsSystem implements ObservableMetricsSystem {</span>

  /** The constant NO_OP_COUNTER. */
<span class="fc" id="L38">  public static final Counter NO_OP_COUNTER = new NoOpCounter();</span>

  /** The constant NO_OP_GAUGE. */
<span class="fc" id="L41">  public static final LabelledGauge NO_OP_GAUGE = new NoOpValueCollector();</span>

<span class="fc" id="L43">  private static final OperationTimer.TimingContext NO_OP_TIMING_CONTEXT = () -&gt; 0;</span>

  /** The constant NO_OP_OPERATION_TIMER. */
<span class="fc" id="L46">  public static final OperationTimer NO_OP_OPERATION_TIMER = () -&gt; NO_OP_TIMING_CONTEXT;</span>

  /** The constant NO_OP_LABELLED_1_COUNTER. */
<span class="fc" id="L49">  public static final LabelledMetric&lt;Counter&gt; NO_OP_LABELLED_1_COUNTER =</span>
      new LabelCountingNoOpMetric&lt;&gt;(1, NO_OP_COUNTER);

  /** The constant NO_OP_LABELLED_2_COUNTER. */
<span class="fc" id="L53">  public static final LabelledMetric&lt;Counter&gt; NO_OP_LABELLED_2_COUNTER =</span>
      new LabelCountingNoOpMetric&lt;&gt;(2, NO_OP_COUNTER);

  /** The constant NO_OP_LABELLED_3_COUNTER. */
<span class="fc" id="L57">  public static final LabelledMetric&lt;Counter&gt; NO_OP_LABELLED_3_COUNTER =</span>
      new LabelCountingNoOpMetric&lt;&gt;(3, NO_OP_COUNTER);

  /** The constant NO_OP_LABELLED_1_OPERATION_TIMER. */
<span class="fc" id="L61">  public static final LabelledMetric&lt;OperationTimer&gt; NO_OP_LABELLED_1_OPERATION_TIMER =</span>
      new LabelCountingNoOpMetric&lt;&gt;(1, NO_OP_OPERATION_TIMER);

  /** The constant NO_OP_LABELLED_1_GAUGE. */
<span class="fc" id="L65">  public static final LabelledGauge NO_OP_LABELLED_1_GAUGE =</span>
      new LabelledGaugeNoOpMetric(1, NO_OP_GAUGE);

  /** The constant NO_OP_LABELLED_2_GAUGE. */
<span class="fc" id="L69">  public static final LabelledGauge NO_OP_LABELLED_2_GAUGE =</span>
      new LabelledGaugeNoOpMetric(2, NO_OP_GAUGE);

  /** The constant NO_OP_LABELLED_3_GAUGE. */
<span class="fc" id="L73">  public static final LabelledGauge NO_OP_LABELLED_3_GAUGE =</span>
      new LabelledGaugeNoOpMetric(3, NO_OP_GAUGE);

  @Override
  public LabelledMetric&lt;Counter&gt; createLabelledCounter(
      final MetricCategory category,
      final String name,
      final String help,
      final String... labelNames) {
<span class="fc" id="L82">    return getCounterLabelledMetric(labelNames.length);</span>
  }

  /**
   * Gets counter labelled metric.
   *
   * @param labelCount the label count
   * @return the counter labelled metric
   */
  public static LabelledMetric&lt;Counter&gt; getCounterLabelledMetric(final int labelCount) {
<span class="fc bfc" id="L92" title="All 4 branches covered.">    switch (labelCount) {</span>
      case 1:
<span class="fc" id="L94">        return NO_OP_LABELLED_1_COUNTER;</span>
      case 2:
<span class="fc" id="L96">        return NO_OP_LABELLED_2_COUNTER;</span>
      case 3:
<span class="fc" id="L98">        return NO_OP_LABELLED_3_COUNTER;</span>
      default:
<span class="fc" id="L100">        return new LabelCountingNoOpMetric&lt;&gt;(labelCount, NO_OP_COUNTER);</span>
    }
  }

  @Override
  public LabelledMetric&lt;OperationTimer&gt; createLabelledTimer(
      final MetricCategory category,
      final String name,
      final String help,
      final String... labelNames) {
<span class="fc" id="L110">    return getOperationTimerLabelledMetric(labelNames.length);</span>
  }

  /**
   * Gets operation timer labelled metric.
   *
   * @param labelCount the label count
   * @return the operation timer labelled metric
   */
  public static LabelledMetric&lt;OperationTimer&gt; getOperationTimerLabelledMetric(
      final int labelCount) {
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (labelCount == 1) {</span>
<span class="fc" id="L122">      return NO_OP_LABELLED_1_OPERATION_TIMER;</span>
    } else {
<span class="fc" id="L124">      return new LabelCountingNoOpMetric&lt;&gt;(labelCount, NO_OP_OPERATION_TIMER);</span>
    }
  }

  @Override
  public void createGauge(
      final MetricCategory category,
      final String name,
      final String help,
<span class="fc" id="L133">      final DoubleSupplier valueSupplier) {}</span>

  @Override
  public LabelledGauge createLabelledGauge(
      final MetricCategory category,
      final String name,
      final String help,
      final String... labelNames) {
<span class="fc" id="L141">    return getLabelledGauge(labelNames.length);</span>
  }

  /**
   * Gets labelled gauge.
   *
   * @param labelCount the label count
   * @return the labelled gauge
   */
  public static LabelledGauge getLabelledGauge(final int labelCount) {
<span class="pc bpc" id="L151" title="2 of 4 branches missed.">    switch (labelCount) {</span>
      case 1:
<span class="fc" id="L153">        return NO_OP_LABELLED_1_GAUGE;</span>
      case 2:
<span class="fc" id="L155">        return NO_OP_LABELLED_2_GAUGE;</span>
      case 3:
<span class="nc" id="L157">        return NO_OP_LABELLED_3_GAUGE;</span>
      default:
<span class="nc" id="L159">        return new LabelledGaugeNoOpMetric(labelCount, NO_OP_GAUGE);</span>
    }
  }

  @Override
  public Stream&lt;Observation&gt; streamObservations(final MetricCategory category) {
<span class="nc" id="L165">    return Stream.empty();</span>
  }

  @Override
  public Stream&lt;Observation&gt; streamObservations() {
<span class="nc" id="L170">    return Stream.empty();</span>
  }

  @Override
  public Set&lt;MetricCategory&gt; getEnabledCategories() {
<span class="nc" id="L175">    return Collections.emptySet();</span>
  }

  /**
   * The Label counting NoOp metric.
   *
   * @param &lt;T&gt; the type parameter
   */
  public static class LabelCountingNoOpMetric&lt;T&gt; implements LabelledMetric&lt;T&gt; {

    /** The Label count. */
    final int labelCount;

    /** The Fake metric. */
    final T fakeMetric;

    /**
     * Instantiates a new Label counting NoOp metric.
     *
     * @param labelCount the label count
     * @param fakeMetric the fake metric
     */
<span class="fc" id="L197">    LabelCountingNoOpMetric(final int labelCount, final T fakeMetric) {</span>
<span class="fc" id="L198">      this.labelCount = labelCount;</span>
<span class="fc" id="L199">      this.fakeMetric = fakeMetric;</span>
<span class="fc" id="L200">    }</span>

    @Override
    public T labels(final String... labels) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">      Preconditions.checkArgument(</span>
          labels.length == labelCount,
          &quot;The count of labels used must match the count of labels expected.&quot;);
<span class="fc" id="L207">      return fakeMetric;</span>
    }
  }

  /** The Labelled gauge NoOp metric. */
  public static class LabelledGaugeNoOpMetric implements LabelledGauge {
    /** The Label count. */
    final int labelCount;

    /** The Label values cache. */
<span class="fc" id="L217">    final List&lt;String&gt; labelValuesCache = new ArrayList&lt;&gt;();</span>

    /**
     * Instantiates a new Labelled gauge NoOp metric.
     *
     * @param labelCount the label count
     * @param fakeMetric the fake metric
     */
<span class="fc" id="L225">    public LabelledGaugeNoOpMetric(final int labelCount, final LabelledGauge fakeMetric) {</span>
<span class="fc" id="L226">      this.labelCount = labelCount;</span>
<span class="fc" id="L227">      this.fakeMetric = fakeMetric;</span>
<span class="fc" id="L228">    }</span>

    /** The Fake metric. */
    final LabelledGauge fakeMetric;

    @Override
    public void labels(final DoubleSupplier valueSupplier, final String... labelValues) {
<span class="fc" id="L235">      final String labelValuesString = String.join(&quot;,&quot;, labelValues);</span>
<span class="fc" id="L236">      Preconditions.checkArgument(</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">          !labelValuesCache.contains(labelValuesString),</span>
          &quot;Received label values that were already in use &quot; + labelValuesString);
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">      Preconditions.checkArgument(</span>
          labelValues.length == labelCount,
          &quot;The count of labels used must match the count of labels expected.&quot;);
<span class="fc" id="L242">      Preconditions.checkNotNull(valueSupplier, &quot;No valueSupplier specified&quot;);</span>
<span class="fc" id="L243">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>