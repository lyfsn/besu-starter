<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TrieNodeHealingRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.sync.snapsync.request.heal</a> &gt; <span class="el_source">TrieNodeHealingRequest.java</span></div><h1>TrieNodeHealingRequest.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.sync.snapsync.request.heal;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.hyperledger.besu.ethereum.eth.sync.snapsync.RequestType.TRIE_NODE;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapSyncConfiguration;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapSyncProcessState;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapWorldDownloadState;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.request.SnapDataRequest;
import org.hyperledger.besu.ethereum.trie.Node;
import org.hyperledger.besu.ethereum.trie.patricia.TrieNodeDecoder;
import org.hyperledger.besu.ethereum.worldstate.WorldStateKeyValueStorage;
import org.hyperledger.besu.ethereum.worldstate.WorldStateStorageCoordinator;
import org.hyperledger.besu.services.tasks.TasksPriorityProvider;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;

public abstract class TrieNodeHealingRequest extends SnapDataRequest
    implements TasksPriorityProvider {

  private final Bytes32 nodeHash;
  private final Bytes location;
  protected Bytes data;

<span class="fc" id="L47">  protected boolean requiresPersisting = true;</span>

  protected TrieNodeHealingRequest(final Hash nodeHash, final Hash rootHash, final Bytes location) {
<span class="fc" id="L50">    super(TRIE_NODE, rootHash);</span>
<span class="fc" id="L51">    this.nodeHash = nodeHash;</span>
<span class="fc" id="L52">    this.location = location;</span>
<span class="fc" id="L53">    this.data = Bytes.EMPTY;</span>
<span class="fc" id="L54">  }</span>

  @Override
  public int persist(
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final WorldStateKeyValueStorage.Updater updater,
      final SnapWorldDownloadState downloadState,
      final SnapSyncProcessState snapSyncState,
      final SnapSyncConfiguration snapSyncConfiguration) {
<span class="pc bpc" id="L63" title="2 of 4 branches missed.">    if (isExpired(snapSyncState) || pendingChildren.get() &gt; 0) {</span>
      // we do nothing. Our last child will eventually persist us.
<span class="nc" id="L65">      return 0;</span>
    }
<span class="fc" id="L67">    int saved = 0;</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">    if (requiresPersisting) {</span>
<span class="nc" id="L69">      checkNotNull(data, &quot;Must set data before node can be persisted.&quot;);</span>
<span class="nc" id="L70">      saved =</span>
<span class="nc" id="L71">          doPersist(</span>
              worldStateStorageCoordinator,
              updater,
              downloadState,
              snapSyncState,
              snapSyncConfiguration);
    }
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">    if (possibleParent.isPresent()) {</span>
<span class="nc" id="L79">      return possibleParent</span>
<span class="nc" id="L80">              .get()</span>
<span class="nc" id="L81">              .saveParent(</span>
                  worldStateStorageCoordinator,
                  updater,
                  downloadState,
                  snapSyncState,
                  snapSyncConfiguration)
          + saved;
    }
<span class="fc" id="L89">    return saved;</span>
  }

  @Override
  public Stream&lt;SnapDataRequest&gt; getChildRequests(
      final SnapWorldDownloadState downloadState,
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final SnapSyncProcessState snapSyncState) {
<span class="nc bnc" id="L97" title="All 2 branches missed.">    if (!isResponseReceived()) {</span>
      // If this node hasn't been downloaded yet, we can't return any child data
<span class="nc" id="L99">      return Stream.empty();</span>
    }

<span class="nc" id="L102">    final List&lt;Node&lt;Bytes&gt;&gt; nodes = TrieNodeDecoder.decodeNodes(location, data);</span>
<span class="nc" id="L103">    return nodes.stream()</span>
<span class="nc" id="L104">        .flatMap(</span>
            node -&gt; {
<span class="nc bnc" id="L106" title="All 2 branches missed.">              if (nodeIsHashReferencedDescendant(node)) {</span>
<span class="nc" id="L107">                return Stream.of(</span>
<span class="nc" id="L108">                    createChildNodeDataRequest(</span>
<span class="nc" id="L109">                        Hash.wrap(node.getHash()), node.getLocation().orElse(Bytes.EMPTY)));</span>
              } else {
<span class="nc" id="L111">                return node.getValue()</span>
<span class="nc" id="L112">                    .map(</span>
                        value -&gt;
<span class="nc" id="L114">                            getRequestsFromTrieNodeValue(</span>
                                worldStateStorageCoordinator,
                                downloadState,
<span class="nc" id="L117">                                node.getLocation().orElse(Bytes.EMPTY),</span>
<span class="nc" id="L118">                                node.getPath(),</span>
                                value))
<span class="nc" id="L120">                    .orElseGet(Stream::empty);</span>
              }
            })
<span class="nc" id="L123">        .peek(request -&gt; request.registerParent(this));</span>
  }

  public boolean isRoot() {
<span class="nc" id="L127">    return possibleParent.isEmpty();</span>
  }

  @Override
  public boolean isResponseReceived() {
<span class="pc bpc" id="L132" title="1 of 4 branches missed.">    return !data.isEmpty() &amp;&amp; Hash.hash(data).equals(getNodeHash());</span>
  }

  @Override
  public void clear() {
<span class="nc" id="L137">    setData(Bytes.EMPTY);</span>
<span class="nc" id="L138">  }</span>

  @Override
  public boolean isExpired(final SnapSyncProcessState snapSyncState) {
<span class="fc" id="L142">    return snapSyncState.isExpired(this);</span>
  }

  public boolean isRequiresPersisting() {
<span class="nc" id="L146">    return requiresPersisting;</span>
  }

  public Bytes32 getNodeHash() {
<span class="fc" id="L150">    return nodeHash;</span>
  }

  public Bytes getLocation() {
<span class="fc" id="L154">    return location;</span>
  }

  @Override
  public int getDepth() {
<span class="fc" id="L159">    return depth;</span>
  }

  @Override
  public long getPriority() {
<span class="fc" id="L164">    return priority;</span>
  }

  public Bytes getPathId() {
<span class="nc" id="L168">    return Bytes.concatenate(new ArrayList&lt;&gt;(getTrieNodePath()));</span>
  }

  public void setData(final Bytes data) {
<span class="fc" id="L172">    this.data = data;</span>
<span class="fc" id="L173">  }</span>

  public void setRequiresPersisting(final boolean requiresPersisting) {
<span class="fc" id="L176">    this.requiresPersisting = requiresPersisting;</span>
<span class="fc" id="L177">  }</span>

  private boolean nodeIsHashReferencedDescendant(final Node&lt;Bytes&gt; node) {
<span class="nc bnc" id="L180" title="All 4 branches missed.">    return !Objects.equals(node.getHash(), nodeHash) &amp;&amp; node.isReferencedByHash();</span>
  }

  public abstract Optional&lt;Bytes&gt; getExistingData(
      final WorldStateStorageCoordinator worldStateStorageCoordinator);

  public abstract List&lt;Bytes&gt; getTrieNodePath();

  protected abstract SnapDataRequest createChildNodeDataRequest(
      final Hash childHash, final Bytes location);

  public Stream&lt;SnapDataRequest&gt; getRootStorageRequests(
      final WorldStateStorageCoordinator worldStateStorageCoordinator) {
<span class="nc" id="L193">    return Stream.empty();</span>
  }

  protected abstract Stream&lt;SnapDataRequest&gt; getRequestsFromTrieNodeValue(
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final SnapWorldDownloadState downloadState,
      final Bytes location,
      final Bytes path,
      final Bytes value);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>