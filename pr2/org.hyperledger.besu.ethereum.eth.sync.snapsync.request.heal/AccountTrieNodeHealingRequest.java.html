<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccountTrieNodeHealingRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.sync.snapsync.request.heal</a> &gt; <span class="el_source">AccountTrieNodeHealingRequest.java</span></div><h1>AccountTrieNodeHealingRequest.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.sync.snapsync.request.heal;

import static org.hyperledger.besu.ethereum.eth.sync.snapsync.request.SnapDataRequest.createAccountTrieNodeDataRequest;
import static org.hyperledger.besu.ethereum.worldstate.WorldStateStorageCoordinator.applyForStrategy;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapSyncConfiguration;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapSyncProcessState;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapWorldDownloadState;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.request.SnapDataRequest;
import org.hyperledger.besu.ethereum.rlp.RLP;
import org.hyperledger.besu.ethereum.trie.CompactEncoding;
import org.hyperledger.besu.ethereum.trie.MerkleTrie;
import org.hyperledger.besu.ethereum.trie.patricia.StoredMerklePatriciaTrie;
import org.hyperledger.besu.ethereum.worldstate.StateTrieAccountValue;
import org.hyperledger.besu.ethereum.worldstate.WorldStateKeyValueStorage;
import org.hyperledger.besu.ethereum.worldstate.WorldStateStorageCoordinator;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Stream;

import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;

/** Represents a healing request for an account trie node. */
public class AccountTrieNodeHealingRequest extends TrieNodeHealingRequest {

  private final Set&lt;Bytes&gt; inconsistentAccounts;

  public AccountTrieNodeHealingRequest(
      final Hash hash,
      final Hash originalRootHash,
      final Bytes location,
      final Set&lt;Bytes&gt; inconsistentAccounts) {
<span class="fc" id="L54">    super(hash, originalRootHash, location);</span>
<span class="fc" id="L55">    this.inconsistentAccounts = inconsistentAccounts;</span>
<span class="fc" id="L56">  }</span>

  @Override
  protected int doPersist(
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final WorldStateKeyValueStorage.Updater updater,
      final SnapWorldDownloadState downloadState,
      final SnapSyncProcessState snapSyncState,
      final SnapSyncConfiguration snapSyncConfiguration) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (isRoot()) {</span>
<span class="nc" id="L66">      downloadState.setRootNodeData(data);</span>
    }
<span class="nc" id="L68">    applyForStrategy(</span>
        updater,
        onBonsai -&gt; {
<span class="nc" id="L71">          onBonsai.putAccountStateTrieNode(getLocation(), getNodeHash(), data);</span>
<span class="nc" id="L72">        },</span>
        onForest -&gt; {
<span class="nc" id="L74">          onForest.putAccountStateTrieNode(getNodeHash(), data);</span>
<span class="nc" id="L75">        });</span>
<span class="nc" id="L76">    return 1;</span>
  }

  @Override
  public Optional&lt;Bytes&gt; getExistingData(
      final WorldStateStorageCoordinator worldStateStorageCoordinator) {
<span class="fc" id="L82">    return worldStateStorageCoordinator</span>
<span class="fc" id="L83">        .getAccountStateTrieNode(getLocation(), getNodeHash())</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        .filter(data -&gt; !getLocation().isEmpty());</span>
  }

  @Override
  protected SnapDataRequest createChildNodeDataRequest(final Hash childHash, final Bytes location) {
<span class="nc" id="L89">    return createAccountTrieNodeDataRequest(</span>
<span class="nc" id="L90">        childHash, getRootHash(), location, getSubLocation(location));</span>
  }

  private Set&lt;Bytes&gt; getSubLocation(final Bytes location) {
<span class="nc" id="L94">    final HashSet&lt;Bytes&gt; foundAccountsToHeal = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">    for (Bytes account : inconsistentAccounts) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">      if (account.commonPrefixLength(location) == location.size()) {</span>
<span class="nc" id="L97">        foundAccountsToHeal.add(account);</span>
      }
<span class="nc" id="L99">    }</span>
<span class="nc" id="L100">    return foundAccountsToHeal;</span>
  }

  @Override
  public Stream&lt;SnapDataRequest&gt; getRootStorageRequests(
      final WorldStateStorageCoordinator worldStateStorageCoordinator) {
<span class="fc" id="L106">    final List&lt;SnapDataRequest&gt; requests = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L107">    final StoredMerklePatriciaTrie&lt;Bytes, Bytes&gt; accountTrie =</span>
        new StoredMerklePatriciaTrie&lt;&gt;(
<span class="fc" id="L109">            worldStateStorageCoordinator::getAccountStateTrieNode,</span>
<span class="fc" id="L110">            Hash.hash(data),</span>
<span class="fc" id="L111">            getLocation(),</span>
<span class="fc" id="L112">            Function.identity(),</span>
<span class="fc" id="L113">            Function.identity());</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    for (Bytes account : inconsistentAccounts) {</span>
<span class="nc" id="L115">      final Bytes32 accountHash = Bytes32.wrap(CompactEncoding.pathToBytes(account));</span>
<span class="nc" id="L116">      accountTrie</span>
<span class="nc" id="L117">          .getPath(</span>
<span class="nc" id="L118">              Bytes.wrap(</span>
<span class="nc" id="L119">                  account.toArrayUnsafe(),</span>
<span class="nc" id="L120">                  getLocation().size(),</span>
<span class="nc" id="L121">                  account.size() - getLocation().size()))</span>
<span class="nc" id="L122">          .map(RLP::input)</span>
<span class="nc" id="L123">          .map(StateTrieAccountValue::readFrom)</span>
<span class="nc" id="L124">          .filter(</span>
              stateTrieAccountValue -&gt;
                  // We need to ensure that the accounts to be healed do not have empty storage.
                  // Therefore, it is unnecessary to create trie heal requests for storage in this
                  // case.
                  // If we were to do so, we would be attempting to request storage that does not
                  // exist from our peers,
                  // which would cause sync issues.
<span class="nc bnc" id="L132" title="All 2 branches missed.">                  !stateTrieAccountValue.getStorageRoot().equals(MerkleTrie.EMPTY_TRIE_NODE_HASH))</span>
<span class="nc" id="L133">          .ifPresent(</span>
              stateTrieAccountValue -&gt; {
                // an account need a heal step
<span class="nc" id="L136">                requests.add(</span>
<span class="nc" id="L137">                    createStorageTrieNodeDataRequest(</span>
<span class="nc" id="L138">                        stateTrieAccountValue.getStorageRoot(),</span>
<span class="nc" id="L139">                        Hash.wrap(accountHash),</span>
<span class="nc" id="L140">                        getRootHash(),</span>
                        Bytes.EMPTY));
<span class="nc" id="L142">              });</span>
<span class="nc" id="L143">    }</span>
<span class="fc" id="L144">    return requests.stream();</span>
  }

  @Override
  protected Stream&lt;SnapDataRequest&gt; getRequestsFromTrieNodeValue(
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final SnapWorldDownloadState downloadState,
      final Bytes location,
      final Bytes path,
      final Bytes value) {
<span class="nc" id="L154">    final Stream.Builder&lt;SnapDataRequest&gt; builder = Stream.builder();</span>
<span class="nc" id="L155">    final StateTrieAccountValue accountValue = StateTrieAccountValue.readFrom(RLP.input(value));</span>

    // Retrieve account hash
<span class="nc" id="L158">    final Hash accountHash =</span>
<span class="nc" id="L159">        Hash.wrap(</span>
<span class="nc" id="L160">            Bytes32.wrap(CompactEncoding.pathToBytes(Bytes.concatenate(getLocation(), path))));</span>

    // update the flat db only for bonsai
<span class="nc" id="L163">    worldStateStorageCoordinator.applyWhenFlatModeEnabled(</span>
        onBonsai -&gt; {
<span class="nc" id="L165">          onBonsai.updater().putAccountInfoState(accountHash, value).commit();</span>
<span class="nc" id="L166">        });</span>

    // Add code, if appropriate
<span class="nc bnc" id="L169" title="All 2 branches missed.">    if (!accountValue.getCodeHash().equals(Hash.EMPTY)) {</span>
<span class="nc" id="L170">      builder.add(createBytecodeRequest(accountHash, getRootHash(), accountValue.getCodeHash()));</span>
    }

    // Retrieve the storage root from the database, if available
<span class="nc" id="L174">    final Hash storageRootFoundInDb =</span>
        worldStateStorageCoordinator
<span class="nc" id="L176">            .getTrieNodeUnsafe(Bytes.concatenate(accountHash, Bytes.EMPTY))</span>
<span class="nc" id="L177">            .map(Hash::hash)</span>
<span class="nc" id="L178">            .orElse(Hash.wrap(MerkleTrie.EMPTY_TRIE_NODE_HASH));</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (!storageRootFoundInDb.equals(accountValue.getStorageRoot())) {</span>
      // If the storage root is not found in the database, add the account to the list of accounts
      // to be repaired
<span class="nc" id="L182">      downloadState.addAccountToHealingList(CompactEncoding.bytesToPath(accountHash));</span>
      // If the account's storage root is not empty,
      // fill it with trie heal before completing with a flat heal
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (!accountValue.getStorageRoot().equals(MerkleTrie.EMPTY_TRIE_NODE_HASH)) {</span>
<span class="nc" id="L186">        SnapDataRequest storageTrieRequest =</span>
<span class="nc" id="L187">            createStorageTrieNodeDataRequest(</span>
<span class="nc" id="L188">                accountValue.getStorageRoot(), accountHash, getRootHash(), Bytes.EMPTY);</span>
<span class="nc" id="L189">        builder.add(storageTrieRequest);</span>
      }
    }
<span class="nc" id="L192">    return builder.build();</span>
  }

  @Override
  public List&lt;Bytes&gt; getTrieNodePath() {
<span class="nc" id="L197">    return List.of(CompactEncoding.encode(getLocation()));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>