<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergeMiningCoordinator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.merge.blockcreation</a> &gt; <span class="el_source">MergeMiningCoordinator.java</span></div><h1>MergeMiningCoordinator.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.merge.blockcreation;

import static org.hyperledger.besu.consensus.merge.blockcreation.MergeMiningCoordinator.ForkchoiceResult.Status.IGNORE_UPDATE_TO_OLD_HEAD;
import static org.hyperledger.besu.consensus.merge.blockcreation.MergeMiningCoordinator.ForkchoiceResult.Status.VALID;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.BlockProcessingResult;
import org.hyperledger.besu.ethereum.blockcreation.MiningCoordinator;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.Withdrawal;
import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import org.apache.tuweni.bytes.Bytes32;

/** The interface Merge mining coordinator. */
public interface MergeMiningCoordinator extends MiningCoordinator {
  /**
   * Prepare payload identifier.
   *
   * @param parentHeader the parent header
   * @param timestamp the timestamp
   * @param prevRandao the prev randao
   * @param feeRecipient the fee recipient
   * @param withdrawals the optional list of withdrawals
   * @param parentBeaconBlockRoot optional root hash of the parent beacon block
   * @return the payload identifier
   */
  PayloadIdentifier preparePayload(
      final BlockHeader parentHeader,
      final Long timestamp,
      final Bytes32 prevRandao,
      final Address feeRecipient,
      final Optional&lt;List&lt;Withdrawal&gt;&gt; withdrawals,
      final Optional&lt;Bytes32&gt; parentBeaconBlockRoot);

  @Override
  default boolean isCompatibleWithEngineApi() {
<span class="nc" id="L58">    return true;</span>
  }

  /**
   * Remember block.
   *
   * @param block the block
   * @return the block processing result
   */
  BlockProcessingResult rememberBlock(final Block block);

  /**
   * Validate block.
   *
   * @param block the block
   * @return the block processing result
   */
  BlockProcessingResult validateBlock(final Block block);

  /**
   * Update fork choice.
   *
   * @param newHead the new head
   * @param finalizedBlockHash the finalized block hash
   * @param safeBlockHash the safe block hash
   * @return the forkchoice result
   */
  ForkchoiceResult updateForkChoice(
      final BlockHeader newHead, final Hash finalizedBlockHash, final Hash safeBlockHash);

  /**
   * Gets latest valid ancestor.
   *
   * @param blockHash the block hash
   * @return the latest valid ancestor
   */
  Optional&lt;Hash&gt; getLatestValidAncestor(Hash blockHash);

  /**
   * Gets latest valid ancestor.
   *
   * @param blockheader the blockheader
   * @return the latest valid ancestor
   */
  Optional&lt;Hash&gt; getLatestValidAncestor(BlockHeader blockheader);

  /**
   * Checks if a block descends from another
   *
   * @param ancestorBlock the ancestor block
   * @param newBlock the block we want to check if it is descendant
   * @return true if newBlock is a descendant of ancestorBlock
   */
  boolean isDescendantOf(final BlockHeader ancestorBlock, final BlockHeader newBlock);

  /**
   * Is backward syncing.
   *
   * @return the boolean
   */
  boolean isBackwardSyncing();

  /**
   * Append new payload to sync.
   *
   * @param newPayload the new payload
   * @return the completable future
   */
  CompletableFuture&lt;Void&gt; appendNewPayloadToSync(Block newPayload);

  /**
   * Gets or sync head by hash.
   *
   * @param headHash the head hash
   * @param finalizedHash the finalized hash
   * @return the or sync head by hash
   */
  Optional&lt;BlockHeader&gt; getOrSyncHeadByHash(Hash headHash, Hash finalizedHash);

  /**
   * Is mining before merge enabled.
   *
   * @return the boolean
   */
  boolean isMiningBeforeMerge();

  /**
   * Is bad block.
   *
   * @param blockHash the block hash
   * @return the boolean
   */
  boolean isBadBlock(Hash blockHash);

  /**
   * Gets latest valid hash of bad block.
   *
   * @param blockHash the block hash
   * @return the latest valid hash of bad block
   */
  Optional&lt;Hash&gt; getLatestValidHashOfBadBlock(final Hash blockHash);

  /**
   * Finalize proposal by id.
   *
   * @param payloadId the payload id
   */
  void finalizeProposalById(final PayloadIdentifier payloadId);

  /**
   * Return the scheduler
   *
   * @return the instance of the scheduler
   */
  EthScheduler getEthScheduler();

  /** The type Forkchoice result. */
  class ForkchoiceResult {
    /** The enum Status. */
<span class="fc" id="L177">    public enum Status {</span>
      /** Valid status. */
<span class="fc" id="L179">      VALID,</span>
      /** Invalid status. */
<span class="fc" id="L181">      INVALID,</span>
      /** Invalid payload attributes status. */
<span class="fc" id="L183">      INVALID_PAYLOAD_ATTRIBUTES,</span>
      /** Ignore update to old head status. */
<span class="fc" id="L185">      IGNORE_UPDATE_TO_OLD_HEAD</span>
    }

    private final Status status;
    private final Optional&lt;String&gt; errorMessage;
    private final Optional&lt;BlockHeader&gt; newFinalized;
    private final Optional&lt;BlockHeader&gt; newHead;
    private final Optional&lt;Hash&gt; latestValid;

    private ForkchoiceResult(
        final Status status,
        final Optional&lt;String&gt; errorMessage,
        final Optional&lt;BlockHeader&gt; newFinalized,
        final Optional&lt;BlockHeader&gt; newHead,
<span class="fc" id="L199">        final Optional&lt;Hash&gt; latestValid) {</span>
<span class="fc" id="L200">      this.status = status;</span>
<span class="fc" id="L201">      this.errorMessage = errorMessage;</span>
<span class="fc" id="L202">      this.newFinalized = newFinalized;</span>
<span class="fc" id="L203">      this.newHead = newHead;</span>
<span class="fc" id="L204">      this.latestValid = latestValid;</span>
<span class="fc" id="L205">    }</span>

    /**
     * Create forkchoice result with failure.
     *
     * @param status the status
     * @param errorMessage the error message
     * @param latestValid the latest valid
     * @return the forkchoice result
     */
    public static ForkchoiceResult withFailure(
        final Status status, final String errorMessage, final Optional&lt;Hash&gt; latestValid) {
<span class="fc" id="L217">      return new ForkchoiceResult(</span>
          status,
<span class="fc" id="L219">          Optional.ofNullable(errorMessage),</span>
<span class="fc" id="L220">          Optional.empty(),</span>
<span class="fc" id="L221">          Optional.empty(),</span>
          latestValid);
    }

    /**
     * Create forkchoice result with ignore update to old head.
     *
     * @param oldHead the old head
     * @return the forkchoice result
     */
    public static ForkchoiceResult withIgnoreUpdateToOldHead(final BlockHeader oldHead) {
<span class="fc" id="L232">      return new ForkchoiceResult(</span>
          IGNORE_UPDATE_TO_OLD_HEAD,
<span class="fc" id="L234">          Optional.empty(),</span>
<span class="fc" id="L235">          Optional.empty(),</span>
<span class="fc" id="L236">          Optional.empty(),</span>
<span class="fc" id="L237">          Optional.of(oldHead.getHash()));</span>
    }

    /**
     * Create forkchoice result with result.
     *
     * @param newFinalized the new finalized
     * @param newHead the new head
     * @return the forkchoice result
     */
    public static ForkchoiceResult withResult(
        final Optional&lt;BlockHeader&gt; newFinalized, final Optional&lt;BlockHeader&gt; newHead) {
<span class="fc" id="L249">      return new ForkchoiceResult(VALID, Optional.empty(), newFinalized, newHead, Optional.empty());</span>
    }

    /**
     * Gets status.
     *
     * @return the status
     */
    public Status getStatus() {
<span class="fc" id="L258">      return status;</span>
    }

    /**
     * Gets error message.
     *
     * @return the error message
     */
    public Optional&lt;String&gt; getErrorMessage() {
<span class="fc" id="L267">      return errorMessage;</span>
    }

    /**
     * Gets new finalized.
     *
     * @return the new finalized
     */
    public Optional&lt;BlockHeader&gt; getNewFinalized() {
<span class="nc" id="L276">      return newFinalized;</span>
    }

    /**
     * Gets new head.
     *
     * @return the new head
     */
    public Optional&lt;BlockHeader&gt; getNewHead() {
<span class="fc" id="L285">      return newHead;</span>
    }

    /**
     * Gets latest valid.
     *
     * @return the latest valid
     */
    public Optional&lt;Hash&gt; getLatestValid() {
<span class="fc" id="L294">      return latestValid;</span>
    }

    /**
     * Is valid.
     *
     * @return the boolean
     */
    public boolean shouldNotProceedToPayloadBuildProcess() {
<span class="fc bfc" id="L303" title="All 2 branches covered.">      return status != VALID;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>