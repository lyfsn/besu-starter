<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EnodeURLImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.p2p.peers</a> &gt; <span class="el_source">EnodeURLImpl.java</span></div><h1>EnodeURLImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.p2p.peers;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;

import org.hyperledger.besu.plugin.data.EnodeURL;
import org.hyperledger.besu.util.NetworkUtility;

import java.net.InetAddress;
import java.net.URI;
import java.net.UnknownHostException;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.net.InetAddresses;
import com.google.common.primitives.Ints;
import org.apache.tuweni.bytes.Bytes;

public class EnodeURLImpl implements EnodeURL {

  public static final int DEFAULT_LISTENING_PORT = 30303;
  public static final int NODE_ID_SIZE = 64;
<span class="fc" id="L41">  private static final Pattern DISCPORT_QUERY_STRING_REGEX =</span>
<span class="fc" id="L42">      Pattern.compile(&quot;^discport=([0-9]{1,5})$&quot;);</span>
<span class="fc" id="L43">  private static final Pattern NODE_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]{128}$&quot;);</span>

  private final Bytes nodeId;
  private InetAddress ip;
  private final Optional&lt;String&gt; maybeHostname;
  private final Optional&lt;Integer&gt; listeningPort;
  private final Optional&lt;Integer&gt; discoveryPort;

  private EnodeURLImpl(
      final Bytes nodeId,
      final InetAddress address,
      final Optional&lt;String&gt; maybeHostname,
      final Optional&lt;Integer&gt; listeningPort,
<span class="fc" id="L56">      final Optional&lt;Integer&gt; discoveryPort) {</span>
<span class="fc" id="L57">    checkArgument(</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        nodeId.size() == NODE_ID_SIZE,</span>
<span class="fc" id="L59">        &quot;Invalid node id of length &quot; + nodeId.size() + &quot;.  Expected id of length: 64 bytes.&quot;);</span>
<span class="fc" id="L60">    listeningPort.ifPresent(port -&gt; NetworkUtility.checkPort(port, &quot;listening&quot;));</span>
<span class="fc" id="L61">    discoveryPort.ifPresent(port -&gt; NetworkUtility.checkPort(port, &quot;discovery&quot;));</span>

<span class="fc" id="L63">    this.nodeId = nodeId;</span>
<span class="fc" id="L64">    this.ip = address;</span>
<span class="fc" id="L65">    this.maybeHostname = maybeHostname;</span>
<span class="fc" id="L66">    this.listeningPort = listeningPort;</span>
<span class="fc" id="L67">    this.discoveryPort = discoveryPort;</span>
<span class="fc" id="L68">  }</span>

  public static Builder builder() {
<span class="fc" id="L71">    return new Builder();</span>
  }

  public static EnodeURL fromString(final String value) {
<span class="fc" id="L75">    return fromString(value, EnodeDnsConfiguration.dnsDisabled());</span>
  }

  public static EnodeURL fromString(
      final String value, final EnodeDnsConfiguration enodeDnsConfiguration) {
    try {
<span class="fc" id="L81">      checkStringArgumentNotEmpty(value, &quot;Invalid empty value.&quot;);</span>
<span class="fc" id="L82">      return fromURI(URI.create(value), enodeDnsConfiguration);</span>
<span class="fc" id="L83">    } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L84">      String message = &quot;&quot;;</span>
<span class="fc bfc" id="L85" title="All 4 branches covered.">      if (enodeDnsConfiguration.dnsEnabled() &amp;&amp; !enodeDnsConfiguration.updateEnabled()) {</span>
<span class="fc" id="L86">        message =</span>
<span class="fc" id="L87">            String.format(</span>
                &quot;Invalid IP address '%s' (or DNS query resolved an invalid IP). --Xdns-enabled is true but --Xdns-update-enabled flag is false.&quot;,
                value);
      } else {
<span class="fc" id="L91">        message =</span>
<span class="fc" id="L92">            String.format(</span>
                &quot;Invalid enode URL syntax '%s'. Enode URL should have the following format 'enode://&lt;node_id&gt;@&lt;ip&gt;:&lt;listening_port&gt;[?discport=&lt;discovery_port&gt;]'.&quot;,
                value);
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (e.getMessage() != null) {</span>
<span class="fc" id="L96">          message += &quot; &quot; + e.getMessage();</span>
        }
      }

<span class="fc" id="L100">      throw new IllegalArgumentException(message, e);</span>
    }
  }

  public static EnodeURL fromURI(final URI uri) {
<span class="nc" id="L105">    return fromURI(uri, EnodeDnsConfiguration.dnsDisabled());</span>
  }

  public static EnodeURL fromURI(final URI uri, final EnodeDnsConfiguration enodeDnsConfiguration) {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">    checkArgument(uri != null, &quot;URI cannot be null&quot;);</span>
<span class="fc" id="L110">    checkStringArgumentNotEmpty(uri.getScheme(), &quot;Missing 'enode' scheme.&quot;);</span>
<span class="fc" id="L111">    checkStringArgumentNotEmpty(uri.getHost(), &quot;Missing or invalid host or ip address.&quot;);</span>
<span class="fc" id="L112">    checkStringArgumentNotEmpty(uri.getUserInfo(), &quot;Missing node ID.&quot;);</span>

<span class="fc" id="L114">    checkArgument(</span>
<span class="fc" id="L115">        uri.getScheme().equalsIgnoreCase(&quot;enode&quot;), &quot;Invalid URI scheme (must equal \&quot;enode\&quot;).&quot;);</span>
<span class="fc" id="L116">    checkArgument(</span>
<span class="fc" id="L117">        NODE_ID_PATTERN.matcher(uri.getUserInfo()).matches(),</span>
        &quot;Invalid node ID: node ID must have exactly 128 hexadecimal characters and should not include any '0x' hex prefix.&quot;);

<span class="fc" id="L120">    final Bytes id = Bytes.fromHexString(uri.getUserInfo());</span>
<span class="fc" id="L121">    String host = uri.getHost();</span>
<span class="fc" id="L122">    int tcpPort = uri.getPort();</span>

    // Parse discport if it exists
<span class="fc" id="L125">    Optional&lt;Integer&gt; discoveryPort = Optional.empty();</span>
<span class="fc" id="L126">    String query = uri.getQuery();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">    if (query != null) {</span>
<span class="fc" id="L128">      final Matcher discPortMatcher = DISCPORT_QUERY_STRING_REGEX.matcher(query);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">      if (discPortMatcher.matches()) {</span>
<span class="fc" id="L130">        discoveryPort = Optional.ofNullable(Ints.tryParse(discPortMatcher.group(1)));</span>
      }
<span class="fc" id="L132">      checkArgument(discoveryPort.isPresent(), &quot;Invalid discovery port: '&quot; + query + &quot;'.&quot;);</span>
<span class="fc" id="L133">    } else {</span>
<span class="fc" id="L134">      discoveryPort = Optional.of(tcpPort);</span>
    }

<span class="fc" id="L137">    return builder()</span>
<span class="fc" id="L138">        .ipAddress(host, enodeDnsConfiguration)</span>
<span class="fc" id="L139">        .nodeId(id)</span>
<span class="fc" id="L140">        .listeningPort(tcpPort)</span>
<span class="fc" id="L141">        .discoveryPort(discoveryPort)</span>
<span class="fc" id="L142">        .build();</span>
  }

  private static void checkStringArgumentNotEmpty(final String argument, final String message) {
<span class="fc bfc" id="L146" title="All 4 branches covered.">    checkArgument(argument != null &amp;&amp; !argument.trim().isEmpty(), message);</span>
<span class="fc" id="L147">  }</span>

  public static boolean sameListeningEndpoint(final EnodeURL enodeA, final EnodeURL enodeB) {
<span class="pc bpc" id="L150" title="2 of 4 branches missed.">    if (enodeA == null || enodeB == null) {</span>
<span class="nc" id="L151">      return false;</span>
    }

<span class="fc bfc" id="L154" title="All 2 branches covered.">    return Objects.equals(enodeA.getNodeId(), enodeB.getNodeId())</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">        &amp;&amp; Objects.equals(enodeA.getIp(), enodeB.getIp())</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        &amp;&amp; Objects.equals(enodeA.getListeningPort(), enodeB.getListeningPort());</span>
  }

  public static Bytes parseNodeId(final String nodeId) {
<span class="fc" id="L160">    int expectedSize = EnodeURLImpl.NODE_ID_SIZE * 2;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (nodeId.toLowerCase(Locale.ROOT).startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L162">      expectedSize += 2;</span>
    }
<span class="fc" id="L164">    checkArgument(</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        nodeId.length() == expectedSize,</span>
        &quot;Expected &quot; + EnodeURLImpl.NODE_ID_SIZE + &quot; bytes in &quot; + nodeId);
<span class="fc" id="L167">    return Bytes.fromHexString(nodeId, NODE_ID_SIZE);</span>
  }

  @Override
  public URI toURI() {

<span class="fc" id="L173">    final String uri =</span>
<span class="fc" id="L174">        String.format(</span>
            &quot;enode://%s@%s:%d&quot;,
<span class="fc" id="L176">            nodeId.toUnprefixedHexString(),</span>
<span class="fc" id="L177">            maybeHostname.orElse(InetAddresses.toUriString(getIp())),</span>
<span class="fc" id="L178">            getListeningPortOrZero());</span>
<span class="fc" id="L179">    final OptionalInt discPort = getDiscPortQueryParam();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    if (discPort.isPresent()) {</span>
<span class="fc" id="L181">      return URI.create(uri + String.format(&quot;?discport=%d&quot;, discPort.getAsInt()));</span>
    } else {
<span class="fc" id="L183">      return URI.create(uri);</span>
    }
  }

  @Override
  public URI toURIWithoutDiscoveryPort() {
<span class="fc" id="L189">    final String uri =</span>
<span class="fc" id="L190">        String.format(</span>
            &quot;enode://%s@%s:%d&quot;,
<span class="fc" id="L192">            nodeId.toUnprefixedHexString(),</span>
<span class="fc" id="L193">            maybeHostname.orElse(InetAddresses.toUriString(getIp())),</span>
<span class="fc" id="L194">            getListeningPortOrZero());</span>

<span class="fc" id="L196">    return URI.create(uri);</span>
  }

  /**
   * Returns the discovery port only if it differs from the listening port
   *
   * @return The port, as an optional.
   */
  private OptionalInt getDiscPortQueryParam() {
<span class="fc" id="L205">    final int listeningPort = getListeningPortOrZero();</span>
<span class="fc" id="L206">    final int discoveryPort = getDiscoveryPortOrZero();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">    if (listeningPort == discoveryPort) {</span>
<span class="fc" id="L208">      return OptionalInt.empty();</span>
    }
<span class="fc" id="L210">    return OptionalInt.of(discoveryPort);</span>
  }

  public static URI asURI(final String url) {
<span class="nc" id="L214">    return asURI(url, EnodeDnsConfiguration.dnsDisabled());</span>
  }

  public static URI asURI(final String url, final EnodeDnsConfiguration enodeDnsConfiguration) {
<span class="nc" id="L218">    return fromString(url, enodeDnsConfiguration).toURI();</span>
  }

  @Override
  public Bytes getNodeId() {
<span class="fc" id="L223">    return nodeId;</span>
  }

  @Override
  public String getIpAsString() {
<span class="fc" id="L228">    return getIp().getHostAddress();</span>
  }

  /**
   * Get IP of the EnodeURL
   *
   * &lt;p&gt;If &quot;dns&quot; and &quot;dns-update&quot; are enabled -&amp;gt; DNS lookup every time to have the IP up to date
   * and not to rely on an invalid cache
   *
   * &lt;p&gt;If the &quot;dns&quot; is enabled but &quot;dns-update&quot; is disabled -&amp;gt; IP is retrieved only one time and
   * the hostname is no longer stored (maybeHostname is empty).
   *
   * @return ip
   */
  @Override
  public InetAddress getIp() {
<span class="fc" id="L244">    this.ip =</span>
        maybeHostname
<span class="fc" id="L246">            .map(</span>
                hostname -&gt; {
                  try {
<span class="fc" id="L249">                    return InetAddress.getByName(hostname);</span>
<span class="nc" id="L250">                  } catch (final UnknownHostException e) {</span>
<span class="nc" id="L251">                    return ip;</span>
                  }
                })
<span class="fc" id="L254">            .orElse(ip);</span>
<span class="fc" id="L255">    return ip;</span>
  }

  @Override
  public boolean isListening() {
<span class="fc" id="L260">    return listeningPort.isPresent();</span>
  }

  @Override
  public boolean isRunningDiscovery() {
<span class="fc" id="L265">    return discoveryPort.isPresent();</span>
  }

  @Override
  public Optional&lt;Integer&gt; getListeningPort() {
<span class="fc" id="L270">    return listeningPort;</span>
  }

  @Override
  public int getListeningPortOrZero() {
<span class="fc" id="L275">    return listeningPort.orElse(0);</span>
  }

  @Override
  public Optional&lt;Integer&gt; getDiscoveryPort() {
<span class="fc" id="L280">    return discoveryPort;</span>
  }

  @Override
  public int getDiscoveryPortOrZero() {
<span class="fc" id="L285">    return discoveryPort.orElse(0);</span>
  }

  @Override
  public String getHost() {
<span class="fc" id="L290">    final URI uriWithoutDiscoveryPort = toURIWithoutDiscoveryPort();</span>
<span class="fc" id="L291">    String host = uriWithoutDiscoveryPort.getHost();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">    if (host == null) {</span>
<span class="fc" id="L293">      host = &quot;&quot;;</span>
<span class="fc" id="L294">      final String uriString = uriWithoutDiscoveryPort.toString();</span>
<span class="fc" id="L295">      int indexOfAt = uriString.indexOf(&quot;@&quot;);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">      if (indexOfAt &gt; -1) {</span>
<span class="fc" id="L297">        int lastIndexOfColon = uriString.lastIndexOf(&quot;:&quot;);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (lastIndexOfColon &gt; indexOfAt) {</span>
<span class="fc" id="L299">          host = uriString.substring(indexOfAt + 1, lastIndexOfColon);</span>
        }
      }
    }
<span class="fc" id="L303">    return host;</span>
  }

  @Override
  public boolean equals(final Object o) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">    if (this == o) {</span>
<span class="fc" id="L309">      return true;</span>
    }
<span class="pc bpc" id="L311" title="2 of 4 branches missed.">    if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L312">      return false;</span>
    }
<span class="fc" id="L314">    final EnodeURL enodeURL = (EnodeURL) o;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">    return Objects.equals(getNodeId(), enodeURL.getNodeId())</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        &amp;&amp; Objects.equals(getIp(), enodeURL.getIp())</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        &amp;&amp; Objects.equals(getListeningPort(), enodeURL.getListeningPort())</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        &amp;&amp; Objects.equals(getDiscoveryPort(), enodeURL.getDiscoveryPort());</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L323">    return Objects.hash(getNodeId(), getIp(), getListeningPort(), getDiscoveryPort());</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L328">    return this.toURI().toString();</span>
  }

  public static class Builder {

    private Bytes nodeId;
    private Optional&lt;Integer&gt; listeningPort;
    private Optional&lt;Integer&gt; discoveryPort;
<span class="fc" id="L336">    private Optional&lt;String&gt; maybeHostname = Optional.empty();</span>
    private InetAddress ip;

<span class="fc" id="L339">    private Builder() {}</span>

    public EnodeURL build() {
<span class="fc" id="L342">      validate();</span>
<span class="fc" id="L343">      return new EnodeURLImpl(nodeId, ip, maybeHostname, listeningPort, discoveryPort);</span>
    }

    private void validate() {
<span class="fc bfc" id="L347" title="All 2 branches covered.">      checkState(nodeId != null, &quot;Node id must be configured.&quot;);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">      checkState(listeningPort != null, &quot;Listening port must be configured.&quot;);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">      checkState(discoveryPort != null, &quot;Discovery port must be configured.&quot;);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">      checkState(ip != null, &quot;Ip address must be configured.&quot;);</span>
<span class="fc" id="L351">    }</span>

    public Builder configureFromEnode(final EnodeURL enode) {
<span class="fc" id="L354">      return this.nodeId(enode.getNodeId())</span>
<span class="fc" id="L355">          .listeningPort(enode.getListeningPort())</span>
<span class="fc" id="L356">          .discoveryPort(enode.getDiscoveryPort())</span>
<span class="fc" id="L357">          .ipAddress(enode.getIp());</span>
    }

    public Builder nodeId(final Bytes nodeId) {
<span class="fc" id="L361">      this.nodeId = nodeId;</span>
<span class="fc" id="L362">      return this;</span>
    }

    public Builder nodeId(final byte[] nodeId) {
<span class="fc" id="L366">      this.nodeId = Bytes.wrap(nodeId);</span>
<span class="fc" id="L367">      return this;</span>
    }

    public Builder nodeId(final String nodeId) {
<span class="fc" id="L371">      this.nodeId = Bytes.fromHexString(nodeId);</span>
<span class="fc" id="L372">      return this;</span>
    }

    public Builder ipAddress(final InetAddress ip) {
<span class="fc" id="L376">      this.ip = ip;</span>
<span class="fc" id="L377">      return this;</span>
    }

    public Builder ipAddress(final String ip) {
<span class="fc" id="L381">      return ipAddress(ip, EnodeDnsConfiguration.dnsDisabled());</span>
    }

    public Builder ipAddress(final String ip, final EnodeDnsConfiguration enodeDnsConfiguration) {
<span class="fc bfc" id="L385" title="All 2 branches covered.">      if (enodeDnsConfiguration.dnsEnabled()) {</span>
        try {
<span class="fc" id="L387">          this.ip = InetAddress.getByName(ip);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">          if (enodeDnsConfiguration.updateEnabled()) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            if (this.ip.isLoopbackAddress()) {</span>
<span class="fc" id="L390">              this.ip = InetAddress.getLocalHost();</span>
            }
<span class="fc" id="L392">            this.maybeHostname = Optional.of(this.ip.getHostName());</span>
          }
<span class="fc" id="L394">        } catch (final UnknownHostException e) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">          if (!enodeDnsConfiguration.updateEnabled()) {</span>
<span class="fc" id="L396">            throw new IllegalArgumentException(&quot;Invalid ip address or hostname.&quot;);</span>
          } else {
<span class="fc" id="L398">            this.ip = InetAddresses.forString(&quot;127.0.0.1&quot;);</span>
          }
<span class="fc" id="L400">        }</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">      } else if (InetAddresses.isUriInetAddress(ip)) {</span>
<span class="fc" id="L402">        this.ip = InetAddresses.forUriString(ip);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">      } else if (InetAddresses.isInetAddress(ip)) {</span>
<span class="nc" id="L404">        this.ip = InetAddresses.forString(ip);</span>
      } else {
<span class="fc" id="L406">        throw new IllegalArgumentException(&quot;Invalid ip address.&quot;);</span>
      }
<span class="fc" id="L408">      return this;</span>
    }

    public Builder discoveryAndListeningPorts(final int listeningAndDiscoveryPorts) {
<span class="fc" id="L412">      listeningPort(listeningAndDiscoveryPorts);</span>
<span class="fc" id="L413">      discoveryPort(listeningAndDiscoveryPorts);</span>
<span class="fc" id="L414">      return this;</span>
    }

    public Builder disableListening() {
<span class="fc" id="L418">      this.listeningPort = Optional.empty();</span>
<span class="fc" id="L419">      return this;</span>
    }

    public Builder disableDiscovery() {
<span class="fc" id="L423">      this.discoveryPort = Optional.empty();</span>
<span class="fc" id="L424">      return this;</span>
    }

    public Builder useDefaultPorts() {
<span class="fc" id="L428">      discoveryAndListeningPorts(EnodeURLImpl.DEFAULT_LISTENING_PORT);</span>
<span class="fc" id="L429">      return this;</span>
    }

    /**
     * An optional listening port value. If the value is empty of equal to 0, the listening port
     * will be empty - indicating the corresponding node is not listening.
     *
     * @param maybeListeningPort If non-empty represents the port to listen on, if empty means the
     *     node is not listening
     * @return The modified builder
     */
    public Builder listeningPort(final Optional&lt;Integer&gt; maybeListeningPort) {
<span class="fc bfc" id="L441" title="All 2 branches covered.">      this.listeningPort = maybeListeningPort.filter(port -&gt; port != 0);</span>
<span class="fc" id="L442">      return this;</span>
    }

    /**
     * An listening port value. A value of 0 means the node is not listening.
     *
     * @param listeningPort If non-zero, represents the port on which to listen for connections. A
     *     value of 0 means the node is not listening for connections.
     * @return The modified builder
     */
    public Builder listeningPort(final int listeningPort) {
<span class="fc" id="L453">      return listeningPort(Optional.of(listeningPort));</span>
    }

    /**
     * The port on which to listen for discovery messages. A value that is empty or equal to 0,
     * indicates that the node is not listening for discovery messages.
     *
     * @param maybeDiscoveryPort If non-empty and non-zero, represents the port on which to listen
     *     for discovery messages. Otherwise, indicates that the node is not running discovery.
     * @return The modified builder
     */
    public Builder discoveryPort(final Optional&lt;Integer&gt; maybeDiscoveryPort) {
<span class="fc bfc" id="L465" title="All 2 branches covered.">      this.discoveryPort = maybeDiscoveryPort.filter(port -&gt; port != 0);</span>
<span class="fc" id="L466">      return this;</span>
    }

    /**
     * The port on which to listen for discovery messages. A value that is equal to 0, indicates
     * that the node is not listening for discovery messages.
     *
     * @param discoveryPort If non-zero, represents the port on which to listen for discovery
     *     messages. Otherwise, indicates that the node is not running discovery.
     * @return The modified builder
     */
    public Builder discoveryPort(final int discoveryPort) {
<span class="fc" id="L478">      return discoveryPort(Optional.of(discoveryPort));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>