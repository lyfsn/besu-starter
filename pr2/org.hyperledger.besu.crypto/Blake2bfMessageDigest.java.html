<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Blake2bfMessageDigest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.crypto</a> &gt; <span class="el_source">Blake2bfMessageDigest.java</span></div><h1>Blake2bfMessageDigest.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.crypto;

import static java.util.Arrays.copyOfRange;

import org.hyperledger.besu.nativelib.blake2bf.LibBlake2bf;

import org.bouncycastle.crypto.Digest;
import org.bouncycastle.jcajce.provider.digest.BCMessageDigest;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The type Blake2bf message digest. */
public class Blake2bfMessageDigest extends BCMessageDigest implements Cloneable {
<span class="fc" id="L30">  private static final Logger LOG = LoggerFactory.getLogger(Blake2bfMessageDigest.class);</span>

  /** Instantiates a new Blake2bf message digest. */
  public Blake2bfMessageDigest() {
<span class="fc" id="L34">    super(new Blake2bfDigest());</span>
<span class="fc" id="L35">  }</span>

  /**
   * Implementation of the `F` compression function of the Blake2b cryptographic hash function.
   *
   * &lt;p&gt;RFC - https://tools.ietf.org/html/rfc7693
   *
   * &lt;p&gt;Adapted from - https://github.com/keep-network/blake2b/blob/master/compression/f.go
   *
   * &lt;p&gt;Optimized for 64-bit platforms
   */
  public static class Blake2bfDigest implements Digest {
    /** The constant MESSAGE_LENGTH_BYTES. */
    public static final int MESSAGE_LENGTH_BYTES = 213;

<span class="fc" id="L50">    private static final long[] IV = {</span>
      0x6a09e667f3bcc908L, 0xbb67ae8584caa73bL, 0x3c6ef372fe94f82bL,
      0xa54ff53a5f1d36f1L, 0x510e527fade682d1L, 0x9b05688c2b3e6c1fL,
      0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
    };

<span class="fc" id="L56">    private static final byte[][] PRECOMPUTED = {</span>
      {0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15},
      {14, 4, 9, 13, 10, 8, 15, 6, 1, 0, 11, 5, 12, 2, 7, 3},
      {11, 12, 5, 15, 8, 0, 2, 13, 10, 3, 7, 9, 14, 6, 1, 4},
      {7, 3, 13, 11, 9, 1, 12, 14, 2, 5, 4, 15, 6, 10, 0, 8},
      {9, 5, 2, 10, 0, 7, 4, 15, 14, 11, 6, 3, 1, 12, 8, 13},
      {2, 6, 0, 8, 12, 10, 11, 3, 4, 7, 15, 1, 13, 5, 14, 9},
      {12, 1, 14, 4, 5, 15, 13, 10, 0, 6, 9, 8, 7, 3, 2, 11},
      {13, 7, 12, 3, 11, 14, 1, 9, 5, 15, 8, 2, 0, 4, 6, 10},
      {6, 14, 11, 0, 15, 9, 3, 8, 12, 13, 1, 10, 2, 7, 4, 5},
      {10, 8, 7, 1, 2, 4, 6, 5, 15, 9, 3, 13, 11, 14, 12, 0}
    };

    private static final int DIGEST_LENGTH = 64;

    // buffer which holds serialized input for this compression function
    // [ 4 bytes for rounds ][ 64 bytes for h ][ 128 bytes for m ]
    // [ 8 bytes for t_0 ][ 8 bytes for t_1 ][ 1 byte for f ]
    private final byte[] buffer;

    private int bufferPos;

    // deserialized inputs for f compression
    private final long[] h;
    private final long[] m;
    private final long[] t;
    private boolean f;
    private long rounds; // unsigned integer represented as long

    private final long[] v;
    private static boolean useNative;

    static {
      try {
<span class="fc" id="L90">        useNative = LibBlake2bf.ENABLED;</span>
<span class="nc" id="L91">      } catch (UnsatisfiedLinkError ule) {</span>
<span class="nc" id="L92">        LOG.info(&quot;blake2bf native precompile not available: {}&quot;, ule.getMessage());</span>
<span class="nc" id="L93">        useNative = false;</span>
<span class="fc" id="L94">      }</span>
<span class="fc" id="L95">    }</span>

    /** Instantiates a new Blake2bf digest. */
<span class="fc" id="L98">    Blake2bfDigest() {</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">      if (!useNative) {</span>
<span class="fc" id="L100">        LOG.info(&quot;Native blake2bf not available&quot;);</span>
      }

<span class="fc" id="L103">      buffer = new byte[MESSAGE_LENGTH_BYTES];</span>
<span class="fc" id="L104">      bufferPos = 0;</span>

<span class="fc" id="L106">      h = new long[8];</span>
<span class="fc" id="L107">      m = new long[16];</span>
<span class="fc" id="L108">      t = new long[2];</span>
<span class="fc" id="L109">      f = false;</span>
<span class="fc" id="L110">      rounds = 12;</span>

<span class="fc" id="L112">      v = new long[16];</span>
<span class="fc" id="L113">    }</span>

    /** Disable native. */
    public static void disableNative() {
<span class="fc" id="L117">      useNative = false;</span>
<span class="fc" id="L118">    }</span>

    /**
     * Is native.
     *
     * @return the boolean
     */
    public static boolean isNative() {
<span class="fc" id="L126">      return useNative;</span>
    }

    @Override
    public String getAlgorithmName() {
<span class="fc" id="L131">      return &quot;BLAKE2f&quot;;</span>
    }

    @Override
    public int getDigestSize() {
<span class="fc" id="L136">      return DIGEST_LENGTH;</span>
    }

    /**
     * update the message digest with a single byte.
     *
     * @param in the input byte to be entered.
     */
    @Override
    public void update(final byte in) {
<span class="fc" id="L146">      checkSize(1);</span>
<span class="fc" id="L147">      buffer[bufferPos] = in;</span>
<span class="fc" id="L148">      bufferPos++;</span>
<span class="fc" id="L149">      maybeInitialize();</span>
<span class="fc" id="L150">    }</span>

    /**
     * update the message digest with a block of bytes.
     *
     * @param in the byte array containing the data.
     * @param offset the offset into the byte array where the data starts.
     * @param len the length of the data.
     */
    @Override
    public void update(final byte[] in, final int offset, final int len) {
<span class="pc bpc" id="L161" title="2 of 4 branches missed.">      if (in == null || len == 0) {</span>
<span class="nc" id="L162">        return;</span>
      }

<span class="fc" id="L165">      checkSize(len);</span>

<span class="fc" id="L167">      System.arraycopy(in, offset, buffer, bufferPos, len);</span>
<span class="fc" id="L168">      bufferPos += len;</span>

<span class="fc" id="L170">      maybeInitialize();</span>
<span class="fc" id="L171">    }</span>

    private void checkSize(final int len) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">      if (len &gt; MESSAGE_LENGTH_BYTES - bufferPos) {</span>
<span class="fc" id="L175">        throw new IllegalArgumentException(</span>
            &quot;Attempting to update buffer with &quot;
                + len
                + &quot; byte(s) but there is &quot;
                + (MESSAGE_LENGTH_BYTES - bufferPos)
                + &quot; byte(s) left to fill&quot;);
      }
<span class="fc" id="L182">    }</span>

    private void maybeInitialize() {
<span class="pc bpc" id="L185" title="1 of 4 branches missed.">      if (!useNative &amp;&amp; bufferPos == MESSAGE_LENGTH_BYTES) {</span>
<span class="fc" id="L186">        initialize();</span>
      }
<span class="fc" id="L188">    }</span>

    /**
     * close the digest, producing the final digest value. The doFinal call leaves the digest reset.
     *
     * @param out the array the digest is to be copied into.
     * @param offset the offset into the out array the digest is to start at.
     */
    @Override
    public int doFinal(final byte[] out, final int offset) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">      if (bufferPos != 213) {</span>
<span class="fc" id="L199">        throw new IllegalStateException(&quot;The buffer must be filled with 213 bytes&quot;);</span>
      }

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">      if (useNative) {</span>
<span class="nc" id="L203">        LibBlake2bf.blake2bf_eip152(out, buffer);</span>
      } else {
<span class="fc" id="L205">        compress();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; h.length; i++) {</span>
<span class="fc" id="L207">          System.arraycopy(Pack.longToLittleEndian(h[i]), 0, out, i * 8, 8);</span>
        }
      }

<span class="fc" id="L211">      reset();</span>

<span class="fc" id="L213">      return 0;</span>
    }

    /** Reset the digest back to it's initial state. */
    @Override
    public void reset() {
<span class="fc" id="L219">      bufferPos = 0;</span>
<span class="fc" id="L220">      Arrays.fill(buffer, (byte) 0);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">      if (!useNative) {</span>
<span class="fc" id="L222">        Arrays.fill(h, 0);</span>
<span class="fc" id="L223">        Arrays.fill(m, (byte) 0);</span>
<span class="fc" id="L224">        Arrays.fill(t, 0);</span>
<span class="fc" id="L225">        f = false;</span>
<span class="fc" id="L226">        rounds = 12;</span>
<span class="fc" id="L227">        Arrays.fill(v, 0);</span>
      }
<span class="fc" id="L229">    }</span>

    private void initialize() {
<span class="fc" id="L232">      rounds = Integer.toUnsignedLong(bytesToInt(copyOfRange(buffer, 0, 4)));</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">      for (int i = 0; i &lt; h.length; i++) {</span>
<span class="fc" id="L235">        final int offset = 4 + i * 8;</span>
<span class="fc" id="L236">        h[i] = bytesToLong((copyOfRange(buffer, offset, offset + 8)));</span>
      }

<span class="fc bfc" id="L239" title="All 2 branches covered.">      for (int i = 0; i &lt; 16; i++) {</span>
<span class="fc" id="L240">        final int offset = 68 + i * 8;</span>
<span class="fc" id="L241">        m[i] = bytesToLong(copyOfRange(buffer, offset, offset + 8));</span>
      }

<span class="fc" id="L244">      t[0] = bytesToLong(copyOfRange(buffer, 196, 204));</span>
<span class="fc" id="L245">      t[1] = bytesToLong(copyOfRange(buffer, 204, 212));</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">      f = buffer[212] != 0;</span>
<span class="fc" id="L248">    }</span>

    private int bytesToInt(final byte[] bytes) {
<span class="fc" id="L251">      return Pack.bigEndianToInt(bytes, 0);</span>
    }

    private long bytesToLong(final byte[] bytes) {
<span class="fc" id="L255">      return Pack.littleEndianToLong(bytes, 0);</span>
    }

    /**
     * F is a compression function for BLAKE2b. It takes as an argument the state vector `h`,
     * message block vector `m`, offset counter `t`, final block indicator flag `f`, and number of
     * rounds `rounds`. The state vector provided as the first parameter is modified by the
     * function.
     */
    private void compress() {

<span class="fc" id="L266">      long t0 = t[0];</span>
<span class="fc" id="L267">      long t1 = t[1];</span>

<span class="fc" id="L269">      System.arraycopy(h, 0, v, 0, 8);</span>
<span class="fc" id="L270">      System.arraycopy(IV, 0, v, 8, 8);</span>

<span class="fc" id="L272">      v[12] ^= t0;</span>
<span class="fc" id="L273">      v[13] ^= t1;</span>

<span class="fc bfc" id="L275" title="All 2 branches covered.">      if (f) {</span>
<span class="fc" id="L276">        v[14] ^= 0xffffffffffffffffL;</span>
      }

<span class="fc bfc" id="L279" title="All 2 branches covered.">      for (long j = 0; j &lt; rounds; ++j) {</span>
<span class="fc" id="L280">        byte[] s = PRECOMPUTED[(int) (j % 10)];</span>

<span class="fc" id="L282">        mix(m[s[0]], m[s[4]], 0, 4, 8, 12);</span>
<span class="fc" id="L283">        mix(m[s[1]], m[s[5]], 1, 5, 9, 13);</span>
<span class="fc" id="L284">        mix(m[s[2]], m[s[6]], 2, 6, 10, 14);</span>
<span class="fc" id="L285">        mix(m[s[3]], m[s[7]], 3, 7, 11, 15);</span>
<span class="fc" id="L286">        mix(m[s[8]], m[s[12]], 0, 5, 10, 15);</span>
<span class="fc" id="L287">        mix(m[s[9]], m[s[13]], 1, 6, 11, 12);</span>
<span class="fc" id="L288">        mix(m[s[10]], m[s[14]], 2, 7, 8, 13);</span>
<span class="fc" id="L289">        mix(m[s[11]], m[s[15]], 3, 4, 9, 14);</span>
      }

      // update h:
<span class="fc bfc" id="L293" title="All 2 branches covered.">      for (int offset = 0; offset &lt; h.length; offset++) {</span>
<span class="fc" id="L294">        h[offset] ^= v[offset] ^ v[offset + 8];</span>
      }
<span class="fc" id="L296">    }</span>

    private void mix(
        final long a, final long b, final int i, final int j, final int k, final int l) {
<span class="fc" id="L300">      v[i] += a + v[j];</span>
<span class="fc" id="L301">      v[l] = Long.rotateLeft(v[l] ^ v[i], -32);</span>
<span class="fc" id="L302">      v[k] += v[l];</span>
<span class="fc" id="L303">      v[j] = Long.rotateLeft(v[j] ^ v[k], -24);</span>

<span class="fc" id="L305">      v[i] += b + v[j];</span>
<span class="fc" id="L306">      v[l] = Long.rotateLeft(v[l] ^ v[i], -16);</span>
<span class="fc" id="L307">      v[k] += v[l];</span>
<span class="fc" id="L308">      v[j] = Long.rotateLeft(v[j] ^ v[k], -63);</span>
<span class="fc" id="L309">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>