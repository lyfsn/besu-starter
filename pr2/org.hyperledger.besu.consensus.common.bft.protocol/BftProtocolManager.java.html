<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BftProtocolManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.common.bft.protocol</a> &gt; <span class="el_source">BftProtocolManager.java</span></div><h1>BftProtocolManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.common.bft.protocol;

import org.hyperledger.besu.consensus.common.bft.BftEventQueue;
import org.hyperledger.besu.consensus.common.bft.events.BftEvent;
import org.hyperledger.besu.consensus.common.bft.events.BftEvents;
import org.hyperledger.besu.consensus.common.bft.network.PeerConnectionTracker;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.ethereum.p2p.network.ProtocolManager;
import org.hyperledger.besu.ethereum.p2p.peers.Peer;
import org.hyperledger.besu.ethereum.p2p.rlpx.connections.PeerConnection;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Message;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.MessageData;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.messages.DisconnectMessage.DisconnectReason;

import java.util.Arrays;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Bft protocol manager. */
public class BftProtocolManager implements ProtocolManager {
<span class="fc" id="L38">  private static final Logger LOG = LoggerFactory.getLogger(BftProtocolManager.class);</span>

  private final BftEventQueue bftEventQueue;
  private final PeerConnectionTracker peers;
  private final Capability supportedCapability;
  private final String subProtocolName;

  /**
   * Constructor for the ibft protocol manager
   *
   * @param bftEventQueue Entry point into the ibft event processor
   * @param peers Used to track all connected IBFT peers.
   * @param supportedCapability The capability offered by this protocol manager
   * @param subProtocolName The name of the protocol being supported
   */
  public BftProtocolManager(
      final BftEventQueue bftEventQueue,
      final PeerConnectionTracker peers,
      final Capability supportedCapability,
<span class="fc" id="L57">      final String subProtocolName) {</span>
<span class="fc" id="L58">    this.bftEventQueue = bftEventQueue;</span>
<span class="fc" id="L59">    this.peers = peers;</span>
<span class="fc" id="L60">    this.supportedCapability = supportedCapability;</span>
<span class="fc" id="L61">    this.subProtocolName = subProtocolName;</span>
<span class="fc" id="L62">  }</span>

  @Override
  public String getSupportedProtocol() {
<span class="nc" id="L66">    return subProtocolName;</span>
  }

  @Override
  public List&lt;Capability&gt; getSupportedCapabilities() {
<span class="fc" id="L71">    return Arrays.asList(supportedCapability);</span>
  }

  @Override
<span class="fc" id="L75">  public void stop() {}</span>

  @Override
<span class="fc" id="L78">  public void awaitStop() throws InterruptedException {}</span>

  /**
   * This function is called by the P2P framework when an &quot;IBF&quot; message has been received. This
   * function is responsible for:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Determining if the message was from a current validator (discard if not)
   *   &lt;li&gt;Determining if the message received was for the 'current round', discarding if old and
   *       buffering for the future if ahead of current state.
   *   &lt;li&gt;If the received message is otherwise valid, it is sent to the state machine which is
   *       responsible for determining how to handle the message given its internal state.
   * &lt;/ul&gt;
   *
   * @param cap The capability under which the message was transmitted.
   * @param message The message to be decoded.
   */
  @Override
  public void processMessage(final Capability cap, final Message message) {
<span class="nc" id="L97">    final MessageData messageData = message.getData();</span>
<span class="nc" id="L98">    final int code = messageData.getCode();</span>
<span class="nc" id="L99">    final Address address = message.getConnection().getPeerInfo().getAddress();</span>
<span class="nc" id="L100">    LOG.trace(&quot;Process message {}, {}, from = {}&quot;, cap, code, address);</span>

<span class="nc" id="L102">    final BftEvent messageEvent = BftEvents.fromMessage(message);</span>
<span class="nc" id="L103">    bftEventQueue.add(messageEvent);</span>
<span class="nc" id="L104">  }</span>

  @Override
  public void handleNewConnection(final PeerConnection peerConnection) {
<span class="nc" id="L108">    peers.add(peerConnection);</span>
<span class="nc" id="L109">  }</span>

  @Override
  public boolean shouldConnect(final Peer peer, final boolean incoming) {
<span class="nc" id="L113">    return false; // for now the EthProtocolManager takes care of this</span>
  }

  @Override
  public void handleDisconnect(
      final PeerConnection peerConnection,
      final DisconnectReason disconnectReason,
      final boolean initiatedByPeer) {
<span class="nc" id="L121">    peers.remove(peerConnection);</span>
<span class="nc" id="L122">  }</span>

  @Override
  public int getHighestProtocolVersion() {
<span class="nc" id="L126">    return supportedCapability.getVersion();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>