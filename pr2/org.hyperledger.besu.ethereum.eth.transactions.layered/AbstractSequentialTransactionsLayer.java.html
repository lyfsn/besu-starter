<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractSequentialTransactionsLayer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.transactions.layered</a> &gt; <span class="el_source">AbstractSequentialTransactionsLayer.java</span></div><h1>AbstractSequentialTransactionsLayer.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.transactions.layered;

import static org.hyperledger.besu.ethereum.eth.transactions.layered.TransactionsLayer.RemovalReason.EVICTED;
import static org.hyperledger.besu.ethereum.eth.transactions.layered.TransactionsLayer.RemovalReason.FOLLOW_INVALIDATED;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.ethereum.eth.transactions.BlobCache;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransaction;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolConfiguration;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolMetrics;

import java.util.Map;
import java.util.NavigableMap;
import java.util.OptionalLong;
import java.util.Set;
import java.util.function.BiFunction;

<span class="fc" id="L32">public abstract class AbstractSequentialTransactionsLayer extends AbstractTransactionsLayer {</span>

  public AbstractSequentialTransactionsLayer(
      final TransactionPoolConfiguration poolConfig,
      final TransactionsLayer nextLayer,
      final BiFunction&lt;PendingTransaction, PendingTransaction, Boolean&gt;
          transactionReplacementTester,
      final TransactionPoolMetrics metrics,
      final BlobCache blobCache) {
<span class="fc" id="L41">    super(poolConfig, nextLayer, transactionReplacementTester, metrics, blobCache);</span>
<span class="fc" id="L42">  }</span>

  @Override
  public void remove(final PendingTransaction invalidatedTx, final RemovalReason reason) {
<span class="fc" id="L46">    nextLayer.remove(invalidatedTx, reason);</span>

<span class="fc" id="L48">    final var senderTxs = txsBySender.get(invalidatedTx.getSender());</span>
<span class="fc" id="L49">    final long invalidNonce = invalidatedTx.getNonce();</span>
<span class="fc bfc" id="L50" title="All 4 branches covered.">    if (senderTxs != null &amp;&amp; Long.compareUnsigned(invalidNonce, senderTxs.lastKey()) &lt;= 0) {</span>
      // on sequential layers we need to push to next layer all the txs following the invalid one,
      // even if it belongs to a previous layer

<span class="fc bfc" id="L54" title="All 2 branches covered.">      if (senderTxs.remove(invalidNonce) != null) {</span>
        // invalid tx removed in this layer
<span class="fc" id="L56">        processRemove(senderTxs, invalidatedTx.getTransaction(), reason);</span>
      }

      // push following to next layer
<span class="fc" id="L60">      pushDown(senderTxs, invalidNonce, 1);</span>

<span class="fc bfc" id="L62" title="All 2 branches covered.">      if (senderTxs.isEmpty()) {</span>
<span class="fc" id="L63">        txsBySender.remove(invalidatedTx.getSender());</span>
      }
    }
<span class="fc" id="L66">  }</span>

  private void pushDown(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final long afterNonce,
      final int gap) {
<span class="fc" id="L72">    senderTxs.tailMap(afterNonce, false).values().stream().toList().stream()</span>
<span class="fc" id="L73">        .peek(</span>
            txToRemove -&gt; {
<span class="fc" id="L75">              senderTxs.remove(txToRemove.getNonce());</span>
<span class="fc" id="L76">              processRemove(senderTxs, txToRemove.getTransaction(), FOLLOW_INVALIDATED);</span>
<span class="fc" id="L77">            })</span>
<span class="fc" id="L78">        .forEach(followingTx -&gt; nextLayer.add(followingTx, gap));</span>
<span class="fc" id="L79">  }</span>

  @Override
  protected boolean gapsAllowed() {
<span class="fc" id="L83">    return false;</span>
  }

  @Override
  protected void internalConfirmed(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final Address sender,
      final long maxConfirmedNonce,
      final PendingTransaction highestNonceRemovedTx) {
    // no -op
<span class="fc" id="L93">  }</span>

  @Override
  protected void internalEvict(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs, final PendingTransaction evictedTx) {
<span class="fc" id="L98">    internalRemove(senderTxs, evictedTx, EVICTED);</span>
<span class="fc" id="L99">  }</span>

  @Override
  public OptionalLong getNextNonceFor(final Address sender) {
<span class="fc" id="L103">    final OptionalLong nextLayerRes = nextLayer.getNextNonceFor(sender);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">    if (nextLayerRes.isEmpty()) {</span>
<span class="fc" id="L105">      final var senderTxs = txsBySender.get(sender);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">      if (senderTxs != null) {</span>
<span class="fc" id="L107">        return OptionalLong.of(senderTxs.lastKey() + 1);</span>
      }
    }
<span class="fc" id="L110">    return nextLayerRes;</span>
  }

  @Override
  public OptionalLong getCurrentNonceFor(final Address sender) {
<span class="fc" id="L115">    final var senderTxs = txsBySender.get(sender);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">    if (senderTxs != null) {</span>
<span class="fc" id="L117">      return OptionalLong.of(senderTxs.firstKey());</span>
    }
<span class="fc" id="L119">    return nextLayer.getCurrentNonceFor(sender);</span>
  }

  @Override
  protected void internalNotifyAdded(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final PendingTransaction pendingTransaction) {
    // no-op
<span class="nc" id="L127">  }</span>

  protected boolean hasExpectedNonce(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final PendingTransaction pendingTransaction,
      final long gap) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">    if (senderTxs == null) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">      return gap == 0;</span>
    }

    // true if prepend or append
<span class="fc bfc" id="L138" title="All 2 branches covered.">    return (senderTxs.lastKey() + 1) == pendingTransaction.getNonce()</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        || (senderTxs.firstKey() - 1) == pendingTransaction.getNonce();</span>
  }

  @Override
  protected void internalConsistencyCheck(
      final Map&lt;Address, NavigableMap&lt;Long, PendingTransaction&gt;&gt; prevLayerTxsBySender) {
<span class="nc" id="L145">    txsBySender.values().stream()</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        .filter(senderTxs -&gt; senderTxs.size() &gt; 1)</span>
<span class="nc" id="L147">        .map(NavigableMap::entrySet)</span>
<span class="nc" id="L148">        .map(Set::iterator)</span>
<span class="nc" id="L149">        .forEach(</span>
            itNonce -&gt; {
<span class="nc" id="L151">              PendingTransaction firstTx = itNonce.next().getValue();</span>

<span class="nc" id="L153">              prevLayerTxsBySender.computeIfPresent(</span>
<span class="nc" id="L154">                  firstTx.getSender(),</span>
                  (sender, txsByNonce) -&gt; {
<span class="nc bnc" id="L156" title="All 2 branches missed.">                    assert txsByNonce.lastKey() + 1 == firstTx.getNonce()</span>
                        : &quot;first nonce is not sequential with previous layer last nonce&quot;;
<span class="nc" id="L158">                    return txsByNonce;</span>
                  });

<span class="nc" id="L161">              long prevNonce = firstTx.getNonce();</span>

<span class="nc bnc" id="L163" title="All 2 branches missed.">              while (itNonce.hasNext()) {</span>
<span class="nc" id="L164">                final long currNonce = itNonce.next().getKey();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                assert prevNonce + 1 == currNonce : &quot;non sequential nonce&quot;;</span>
<span class="nc" id="L166">                prevNonce = currNonce;</span>
<span class="nc" id="L167">              }</span>
<span class="nc" id="L168">            });</span>
<span class="nc" id="L169">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>