<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LayeredPendingTransactions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.transactions.layered</a> &gt; <span class="el_source">LayeredPendingTransactions.java</span></div><h1>LayeredPendingTransactions.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.transactions.layered;

import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.mapping;
import static java.util.stream.Collectors.reducing;
import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.ALREADY_KNOWN;
import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.INTERNAL_ERROR;
import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.NONCE_TOO_FAR_IN_FUTURE_FOR_SENDER;
import static org.hyperledger.besu.ethereum.eth.transactions.layered.TransactionsLayer.RemovalReason.INVALIDATED;
import static org.hyperledger.besu.ethereum.eth.transactions.layered.TransactionsLayer.RemovalReason.RECONCILED;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransaction;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransactionAddedListener;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransactionDroppedListener;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolConfiguration;
import org.hyperledger.besu.ethereum.mainnet.feemarket.FeeMarket;
import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;
import org.hyperledger.besu.evm.account.Account;
import org.hyperledger.besu.evm.account.AccountState;
import org.hyperledger.besu.plugin.data.TransactionSelectionResult;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalLong;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collector;
import java.util.stream.Collectors;

import kotlin.ranges.LongRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

public class LayeredPendingTransactions implements PendingTransactions {
<span class="fc" id="L61">  private static final Logger LOG = LoggerFactory.getLogger(LayeredPendingTransactions.class);</span>
<span class="fc" id="L62">  private static final Logger LOG_FOR_REPLAY = LoggerFactory.getLogger(&quot;LOG_FOR_REPLAY&quot;);</span>
<span class="fc" id="L63">  private static final Marker INVALID_TX_REMOVED = MarkerFactory.getMarker(&quot;INVALID_TX_REMOVED&quot;);</span>
  private final TransactionPoolConfiguration poolConfig;
  private final AbstractPrioritizedTransactions prioritizedTransactions;

  public LayeredPendingTransactions(
      final TransactionPoolConfiguration poolConfig,
<span class="fc" id="L69">      final AbstractPrioritizedTransactions prioritizedTransactions) {</span>
<span class="fc" id="L70">    this.poolConfig = poolConfig;</span>
<span class="fc" id="L71">    this.prioritizedTransactions = prioritizedTransactions;</span>
<span class="fc" id="L72">  }</span>

  @Override
  public synchronized void reset() {
<span class="fc" id="L76">    prioritizedTransactions.reset();</span>
<span class="fc" id="L77">  }</span>

  @Override
  public synchronized TransactionAddedResult addTransaction(
      final PendingTransaction pendingTransaction, final Optional&lt;Account&gt; maybeSenderAccount) {

<span class="fc" id="L83">    final long stateSenderNonce = maybeSenderAccount.map(AccountState::getNonce).orElse(0L);</span>

<span class="fc" id="L85">    logTransactionForReplayAdd(pendingTransaction, stateSenderNonce);</span>

<span class="fc bfc" id="L87" title="All 2 branches covered.">    if (hasAccountNonceDisparity(pendingTransaction, stateSenderNonce)) {</span>
<span class="fc" id="L88">      reconcileSender(pendingTransaction.getSender(), stateSenderNonce);</span>
    }

<span class="fc" id="L91">    final long nonceDistance = pendingTransaction.getNonce() - stateSenderNonce;</span>

<span class="fc" id="L93">    final TransactionAddedResult nonceChecksResult =</span>
<span class="fc" id="L94">        nonceChecks(pendingTransaction, stateSenderNonce, nonceDistance);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">    if (nonceChecksResult != null) {</span>
<span class="fc" id="L96">      return nonceChecksResult;</span>
    }

    try {
<span class="fc" id="L100">      return prioritizedTransactions.add(pendingTransaction, (int) nonceDistance);</span>
<span class="nc" id="L101">    } catch (final Throwable throwable) {</span>
<span class="nc" id="L102">      return reconcileAndRetryAdd(</span>
          pendingTransaction, stateSenderNonce, (int) nonceDistance, throwable);
    }
  }

  private TransactionAddedResult reconcileAndRetryAdd(
      final PendingTransaction pendingTransaction,
      final long stateSenderNonce,
      final int nonceDistance,
      final Throwable throwable) {
    // in case something unexpected happened, log this sender txs, force a reconcile and retry
    // another time
<span class="nc" id="L114">    LOG.atDebug()</span>
<span class="nc" id="L115">        .setMessage(</span>
            &quot;Unexpected error when adding transaction {}, current sender status {}, force a reconcile and retry&quot;)
<span class="nc" id="L117">        .setCause(throwable)</span>
<span class="nc" id="L118">        .addArgument(pendingTransaction::toTraceLog)</span>
<span class="nc" id="L119">        .addArgument(() -&gt; prioritizedTransactions.logSender(pendingTransaction.getSender()))</span>
<span class="nc" id="L120">        .log();</span>
<span class="nc" id="L121">    reconcileSender(pendingTransaction.getSender(), stateSenderNonce);</span>
    try {
<span class="nc" id="L123">      return prioritizedTransactions.add(pendingTransaction, nonceDistance);</span>
<span class="nc" id="L124">    } catch (final Throwable throwable2) {</span>
      // the error should have been solved by the reconcile, logging at higher level now
<span class="nc" id="L126">      LOG.atWarn()</span>
<span class="nc" id="L127">          .setCause(throwable2)</span>
<span class="nc" id="L128">          .setMessage(</span>
              &quot;Unexpected error when adding transaction {} after reconciliation, current sender status {}&quot;)
<span class="nc" id="L130">          .addArgument(pendingTransaction.toTraceLog())</span>
<span class="nc" id="L131">          .addArgument(prioritizedTransactions.logSender(pendingTransaction.getSender()))</span>
<span class="nc" id="L132">          .log();</span>
<span class="nc" id="L133">      return INTERNAL_ERROR;</span>
    }
  }

  /**
   * Detect a disparity between account nonce has seen by the world state and the txpool, that could
   * happen during the small amount of time during block import when the world state is updated
   * while the txpool still does not process the confirmed txs, or when there is a reorg and the
   * sender nonce goes back.
   *
   * @param pendingTransaction the incoming transaction to check
   * @param stateSenderNonce account nonce from the world state
   * @return false if the nonce for the sender has seen by the txpool matches the value of the
   *     account nonce in the world state, true if they differ
   */
  private boolean hasAccountNonceDisparity(
      final PendingTransaction pendingTransaction, final long stateSenderNonce) {
<span class="fc" id="L150">    final OptionalLong maybeTxPoolSenderNonce =</span>
<span class="fc" id="L151">        prioritizedTransactions.getCurrentNonceFor(pendingTransaction.getSender());</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (maybeTxPoolSenderNonce.isPresent()) {</span>
<span class="fc" id="L153">      final long txPoolSenderNonce = maybeTxPoolSenderNonce.getAsLong();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">      if (stateSenderNonce != txPoolSenderNonce) {</span>
<span class="fc" id="L155">        LOG.atDebug()</span>
<span class="fc" id="L156">            .setMessage(</span>
                &quot;Nonce disparity detected when adding pending transaction {}. &quot;
                    + &quot;Account nonce from world state is {} while current txpool nonce is {}&quot;)
<span class="fc" id="L159">            .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L160">            .addArgument(stateSenderNonce)</span>
<span class="fc" id="L161">            .addArgument(txPoolSenderNonce)</span>
<span class="fc" id="L162">            .log();</span>
<span class="fc" id="L163">        return true;</span>
      }
    }
<span class="fc" id="L166">    return false;</span>
  }

  /**
   * Rebuild the txpool for a sender according to the specified nonce. This is used in case the
   * account nonce has seen by the txpool is not the correct one (see {@link
   * LayeredPendingTransactions#hasAccountNonceDisparity(PendingTransaction, long)} for when this
   * could happen). It works by removing all the txs for the sender and re-adding them using the
   * passed nonce.
   *
   * @param sender the sender for which rebuild the txpool
   * @param stateSenderNonce the world state account nonce to use in the txpool for the sender
   */
  private void reconcileSender(final Address sender, final long stateSenderNonce) {
<span class="fc" id="L180">    final var existingSenderTxs = prioritizedTransactions.getAllFor(sender);</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">    if (existingSenderTxs.isEmpty()) {</span>
<span class="nc" id="L182">      LOG.debug(&quot;Sender {} has no transactions to reconcile&quot;, sender);</span>
<span class="nc" id="L183">      return;</span>
    }

<span class="fc" id="L186">    LOG.atDebug()</span>
<span class="fc" id="L187">        .setMessage(&quot;Sender {} with nonce {} has {} transaction(s) to reconcile {}&quot;)</span>
<span class="fc" id="L188">        .addArgument(sender)</span>
<span class="fc" id="L189">        .addArgument(stateSenderNonce)</span>
<span class="fc" id="L190">        .addArgument(existingSenderTxs::size)</span>
<span class="pc" id="L191">        .addArgument(() -&gt; prioritizedTransactions.logSender(sender))</span>
<span class="fc" id="L192">        .log();</span>

<span class="fc" id="L194">    final var reAddTxs = new ArrayDeque&lt;PendingTransaction&gt;(existingSenderTxs.size());</span>

    // it is more performant to invalidate backward
<span class="fc bfc" id="L197" title="All 2 branches covered.">    for (int i = existingSenderTxs.size() - 1; i &gt;= 0; --i) {</span>
<span class="fc" id="L198">      final var ptx = existingSenderTxs.get(i);</span>
<span class="fc" id="L199">      prioritizedTransactions.remove(ptx, RECONCILED);</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">      if (ptx.getNonce() &gt;= stateSenderNonce) {</span>
<span class="fc" id="L201">        reAddTxs.addFirst(ptx);</span>
      }
    }

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    if (!reAddTxs.isEmpty()) {</span>
      // re-add all the previous txs
<span class="fc" id="L207">      final long lowestNonce = reAddTxs.getFirst().getNonce();</span>
<span class="fc" id="L208">      final int newNonceDistance = (int) Math.max(0, lowestNonce - stateSenderNonce);</span>

<span class="fc" id="L210">      reAddTxs.forEach(ptx -&gt; prioritizedTransactions.add(ptx, newNonceDistance));</span>
    }

<span class="fc" id="L213">    LOG.atDebug()</span>
<span class="fc" id="L214">        .setMessage(&quot;Sender {} with nonce {} status after reconciliation {}&quot;)</span>
<span class="fc" id="L215">        .addArgument(sender)</span>
<span class="fc" id="L216">        .addArgument(stateSenderNonce)</span>
<span class="pc" id="L217">        .addArgument(() -&gt; prioritizedTransactions.logSender(sender))</span>
<span class="fc" id="L218">        .log();</span>
<span class="fc" id="L219">  }</span>

  private void logTransactionForReplayAdd(
      final PendingTransaction pendingTransaction, final long senderNonce) {
    // csv fields: sequence, addedAt, sender, sender_nonce, nonce, type, hash, rlp
<span class="fc" id="L224">    LOG_FOR_REPLAY</span>
<span class="fc" id="L225">        .atTrace()</span>
<span class="fc" id="L226">        .setMessage(&quot;T,{},{},{},{},{},{},{},{}&quot;)</span>
<span class="fc" id="L227">        .addArgument(pendingTransaction.getSequence())</span>
<span class="fc" id="L228">        .addArgument(pendingTransaction.getAddedAt())</span>
<span class="fc" id="L229">        .addArgument(pendingTransaction.getSender())</span>
<span class="fc" id="L230">        .addArgument(senderNonce)</span>
<span class="fc" id="L231">        .addArgument(pendingTransaction.getNonce())</span>
<span class="fc" id="L232">        .addArgument(pendingTransaction.getTransaction().getType())</span>
<span class="fc" id="L233">        .addArgument(pendingTransaction::getHash)</span>
<span class="fc" id="L234">        .addArgument(</span>
            () -&gt; {
<span class="nc" id="L236">              final BytesValueRLPOutput rlp = new BytesValueRLPOutput();</span>
<span class="nc" id="L237">              pendingTransaction.getTransaction().writeTo(rlp);</span>
<span class="nc" id="L238">              return rlp.encoded().toHexString();</span>
            })
<span class="fc" id="L240">        .log();</span>
<span class="fc" id="L241">  }</span>

  private void logDiscardedTransaction(
      final PendingTransaction pendingTransaction, final TransactionSelectionResult result) {
    // csv fields: sequence, addedAt, sender, nonce, type, hash, rlp
<span class="fc" id="L246">    LOG_FOR_REPLAY</span>
<span class="fc" id="L247">        .atTrace()</span>
<span class="fc" id="L248">        .setMessage(&quot;D,{},{},{},{},{},{},{}&quot;)</span>
<span class="fc" id="L249">        .addArgument(pendingTransaction.getSequence())</span>
<span class="fc" id="L250">        .addArgument(pendingTransaction.getAddedAt())</span>
<span class="fc" id="L251">        .addArgument(pendingTransaction.getSender())</span>
<span class="fc" id="L252">        .addArgument(pendingTransaction.getNonce())</span>
<span class="fc" id="L253">        .addArgument(pendingTransaction.getTransaction().getType())</span>
<span class="fc" id="L254">        .addArgument(pendingTransaction::getHash)</span>
<span class="fc" id="L255">        .addArgument(</span>
            () -&gt; {
<span class="nc" id="L257">              final BytesValueRLPOutput rlp = new BytesValueRLPOutput();</span>
<span class="nc" id="L258">              pendingTransaction.getTransaction().writeTo(rlp);</span>
<span class="nc" id="L259">              return rlp.encoded().toHexString();</span>
            })
<span class="fc" id="L261">        .log();</span>
<span class="fc" id="L262">    LOG.atInfo()</span>
<span class="fc" id="L263">        .addMarker(INVALID_TX_REMOVED)</span>
<span class="fc" id="L264">        .addKeyValue(&quot;txhash&quot;, pendingTransaction::getHash)</span>
<span class="fc" id="L265">        .addKeyValue(&quot;txlog&quot;, pendingTransaction::toTraceLog)</span>
<span class="fc" id="L266">        .addKeyValue(&quot;reason&quot;, result)</span>
<span class="fc" id="L267">        .addKeyValue(</span>
            &quot;txrlp&quot;,
            () -&gt; {
<span class="fc" id="L270">              final BytesValueRLPOutput rlp = new BytesValueRLPOutput();</span>
<span class="fc" id="L271">              pendingTransaction.getTransaction().writeTo(rlp);</span>
<span class="fc" id="L272">              return rlp.encoded().toHexString();</span>
            })
<span class="fc" id="L274">        .log();</span>
<span class="fc" id="L275">  }</span>

  private TransactionAddedResult nonceChecks(
      final PendingTransaction pendingTransaction,
      final long senderNonce,
      final long nonceDistance) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">    if (nonceDistance &lt; 0) {</span>
<span class="fc" id="L282">      LOG.atTrace()</span>
<span class="fc" id="L283">          .setMessage(&quot;Drop already confirmed transaction {}, since current sender nonce is {}&quot;)</span>
<span class="fc" id="L284">          .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L285">          .addArgument(senderNonce)</span>
<span class="fc" id="L286">          .log();</span>
<span class="fc" id="L287">      return ALREADY_KNOWN;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">    } else if (nonceDistance &gt;= poolConfig.getMaxFutureBySender()) {</span>
<span class="fc" id="L289">      LOG.atTrace()</span>
<span class="fc" id="L290">          .setMessage(</span>
              &quot;Drop too much in the future transaction {}, since current sender nonce is {}&quot;)
<span class="fc" id="L292">          .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L293">          .addArgument(senderNonce)</span>
<span class="fc" id="L294">          .log();</span>
<span class="fc" id="L295">      return NONCE_TOO_FAR_IN_FUTURE_FOR_SENDER;</span>
    }
<span class="fc" id="L297">    return null;</span>
  }

  @Override
<span class="nc" id="L301">  public void evictOldTransactions() {}</span>

  @Override
  public synchronized List&lt;Transaction&gt; getLocalTransactions() {
<span class="fc" id="L305">    return prioritizedTransactions.getAllLocal();</span>
  }

  @Override
  public synchronized List&lt;Transaction&gt; getPriorityTransactions() {
<span class="fc" id="L310">    return prioritizedTransactions.getAllPriority();</span>
  }

  @Override
  // There's a small edge case here we could encounter.
  // When we pass an upgrade block that has a new transaction type, we start allowing transactions
  // of that new type into our pool.
  // If we then reorg to a block lower than the upgrade block height _and_ we create a block, that
  // block could end up with transactions of the new type.
  // This seems like it would be very rare but worth it to document that we don't handle that case
  // right now.
  public synchronized void selectTransactions(
      final PendingTransactions.TransactionSelector selector) {
<span class="fc" id="L323">    final List&lt;PendingTransaction&gt; invalidTransactions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L324">    final Set&lt;Hash&gt; alreadyChecked = new HashSet&lt;&gt;();</span>
<span class="fc" id="L325">    final Set&lt;Address&gt; skipSenders = new HashSet&lt;&gt;();</span>
<span class="fc" id="L326">    final AtomicBoolean completed = new AtomicBoolean(false);</span>

<span class="fc" id="L328">    prioritizedTransactions.stream()</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        .takeWhile(unused -&gt; !completed.get())</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        .filter(highPrioPendingTx -&gt; !skipSenders.contains(highPrioPendingTx.getSender()))</span>
<span class="fc" id="L331">        .peek(this::logSenderTxs)</span>
<span class="fc" id="L332">        .forEach(</span>
            highPrioPendingTx -&gt;
<span class="fc" id="L334">                prioritizedTransactions.stream(highPrioPendingTx.getSender())</span>
<span class="fc" id="L335">                    .takeWhile(</span>
                        candidatePendingTx -&gt;
<span class="fc bfc" id="L337" title="All 2 branches covered.">                            !skipSenders.contains(candidatePendingTx.getSender())</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                                &amp;&amp; !completed.get())</span>
<span class="fc" id="L339">                    .filter(</span>
                        candidatePendingTx -&gt;
<span class="fc bfc" id="L341" title="All 2 branches covered.">                            !alreadyChecked.contains(candidatePendingTx.getHash())</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                                &amp;&amp; Long.compareUnsigned(</span>
<span class="fc" id="L343">                                        candidatePendingTx.getNonce(), highPrioPendingTx.getNonce())</span>
                                    &lt;= 0)
<span class="fc" id="L345">                    .forEach(</span>
                        candidatePendingTx -&gt; {
<span class="fc" id="L347">                          alreadyChecked.add(candidatePendingTx.getHash());</span>
<span class="fc" id="L348">                          final var res = selector.evaluateTransaction(candidatePendingTx);</span>

<span class="fc" id="L350">                          LOG.atTrace()</span>
<span class="fc" id="L351">                              .setMessage(&quot;Selection result {} for transaction {}&quot;)</span>
<span class="fc" id="L352">                              .addArgument(res)</span>
<span class="fc" id="L353">                              .addArgument(candidatePendingTx::toTraceLog)</span>
<span class="fc" id="L354">                              .log();</span>

<span class="fc bfc" id="L356" title="All 2 branches covered.">                          if (res.discard()) {</span>
<span class="fc" id="L357">                            invalidTransactions.add(candidatePendingTx);</span>
<span class="fc" id="L358">                            logDiscardedTransaction(candidatePendingTx, res);</span>
                          }

<span class="fc bfc" id="L361" title="All 2 branches covered.">                          if (res.stop()) {</span>
<span class="fc" id="L362">                            completed.set(true);</span>
                          }

<span class="fc bfc" id="L365" title="All 2 branches covered.">                          if (!res.selected()) {</span>
                            // avoid processing other txs from this sender if this one is skipped
                            // since the following will not be selected due to the nonce gap
<span class="fc" id="L368">                            skipSenders.add(candidatePendingTx.getSender());</span>
<span class="fc" id="L369">                            LOG.trace(&quot;Skipping tx from sender {}&quot;, candidatePendingTx.getSender());</span>
                          }
<span class="fc" id="L371">                        }));</span>

<span class="fc" id="L373">    invalidTransactions.forEach(</span>
<span class="fc" id="L374">        invalidTx -&gt; prioritizedTransactions.remove(invalidTx, INVALIDATED));</span>
<span class="fc" id="L375">  }</span>

  private void logSenderTxs(final PendingTransaction highPrioPendingTx) {
<span class="fc" id="L378">    LOG.atTrace()</span>
<span class="fc" id="L379">        .setMessage(&quot;highPrioPendingTx {}, senderTxs {}&quot;)</span>
<span class="fc" id="L380">        .addArgument(highPrioPendingTx::toTraceLog)</span>
<span class="fc" id="L381">        .addArgument(</span>
            () -&gt;
<span class="nc" id="L383">                prioritizedTransactions.stream(highPrioPendingTx.getSender())</span>
<span class="nc" id="L384">                    .map(PendingTransaction::toTraceLog)</span>
<span class="nc" id="L385">                    .collect(Collectors.joining(&quot;, &quot;)))</span>
<span class="fc" id="L386">        .log();</span>
<span class="fc" id="L387">  }</span>

  @Override
  public long maxSize() {
<span class="nc" id="L391">    return -1;</span>
  }

  @Override
  public synchronized int size() {
<span class="fc" id="L396">    return prioritizedTransactions.count();</span>
  }

  @Override
  public synchronized boolean containsTransaction(final Transaction transaction) {
<span class="fc" id="L401">    return prioritizedTransactions.contains(transaction);</span>
  }

  @Override
  public synchronized Optional&lt;Transaction&gt; getTransactionByHash(final Hash transactionHash) {
<span class="fc" id="L406">    return prioritizedTransactions.getByHash(transactionHash);</span>
  }

  @Override
  public synchronized List&lt;PendingTransaction&gt; getPendingTransactions() {
<span class="fc" id="L411">    return prioritizedTransactions.getAll();</span>
  }

  @Override
  public long subscribePendingTransactions(final PendingTransactionAddedListener listener) {
<span class="fc" id="L416">    return prioritizedTransactions.subscribeToAdded(listener);</span>
  }

  @Override
  public void unsubscribePendingTransactions(final long id) {
<span class="fc" id="L421">    prioritizedTransactions.unsubscribeFromAdded(id);</span>
<span class="fc" id="L422">  }</span>

  @Override
  public long subscribeDroppedTransactions(final PendingTransactionDroppedListener listener) {
<span class="fc" id="L426">    return prioritizedTransactions.subscribeToDropped(listener);</span>
  }

  @Override
  public void unsubscribeDroppedTransactions(final long id) {
<span class="fc" id="L431">    prioritizedTransactions.unsubscribeFromDropped(id);</span>
<span class="fc" id="L432">  }</span>

  @Override
  public OptionalLong getNextNonceForSender(final Address sender) {
<span class="fc" id="L436">    return prioritizedTransactions.getNextNonceFor(sender);</span>
  }

  @Override
  public synchronized void manageBlockAdded(
      final BlockHeader blockHeader,
      final List&lt;Transaction&gt; confirmedTransactions,
      final List&lt;Transaction&gt; reorgTransactions,
      final FeeMarket feeMarket) {
<span class="fc" id="L445">    LOG.atTrace()</span>
<span class="fc" id="L446">        .setMessage(&quot;Managing new added block {}&quot;)</span>
<span class="fc" id="L447">        .addArgument(blockHeader::toLogString)</span>
<span class="fc" id="L448">        .log();</span>

<span class="fc" id="L450">    final var maxConfirmedNonceBySender = maxNonceBySender(confirmedTransactions);</span>

<span class="fc" id="L452">    final var reorgNonceRangeBySender = nonceRangeBySender(reorgTransactions);</span>

    try {
<span class="fc" id="L455">      prioritizedTransactions.blockAdded(feeMarket, blockHeader, maxConfirmedNonceBySender);</span>
<span class="nc" id="L456">    } catch (final Throwable throwable) {</span>
<span class="nc" id="L457">      LOG.warn(</span>
          &quot;Unexpected error {} when managing added block {}, maxNonceBySender {}, reorgNonceRangeBySender {}&quot;,
          throwable,
<span class="nc" id="L460">          blockHeader.toLogString(),</span>
          maxConfirmedNonceBySender,
          reorgTransactions);
<span class="nc" id="L463">      LOG.warn(&quot;Stack trace&quot;, throwable);</span>
<span class="fc" id="L464">    }</span>

<span class="fc" id="L466">    logBlockHeaderForReplay(blockHeader, maxConfirmedNonceBySender, reorgNonceRangeBySender);</span>
<span class="fc" id="L467">  }</span>

  private void logBlockHeaderForReplay(
      final BlockHeader blockHeader,
      final Map&lt;Address, Long&gt; maxConfirmedNonceBySender,
      final Map&lt;Address, LongRange&gt; reorgNonceRangeBySender) {
    // block number, block hash, sender, max nonce ..., rlp
<span class="fc" id="L474">    LOG_FOR_REPLAY</span>
<span class="fc" id="L475">        .atTrace()</span>
<span class="fc" id="L476">        .setMessage(&quot;B,{},{},{},R,{},{}&quot;)</span>
<span class="fc" id="L477">        .addArgument(blockHeader.getNumber())</span>
<span class="fc" id="L478">        .addArgument(blockHeader.getBlockHash())</span>
<span class="fc" id="L479">        .addArgument(</span>
            () -&gt;
<span class="nc" id="L481">                maxConfirmedNonceBySender.entrySet().stream()</span>
<span class="nc" id="L482">                    .map(e -&gt; e.getKey().toHexString() + &quot;,&quot; + e.getValue())</span>
<span class="nc" id="L483">                    .collect(Collectors.joining(&quot;,&quot;)))</span>
<span class="fc" id="L484">        .addArgument(</span>
            () -&gt;
<span class="nc" id="L486">                reorgNonceRangeBySender.entrySet().stream()</span>
<span class="nc" id="L487">                    .map(</span>
                        e -&gt;
<span class="nc" id="L489">                            e.getKey().toHexString()</span>
                                + &quot;,&quot;
<span class="nc" id="L491">                                + e.getValue().getStart()</span>
                                + &quot;,&quot;
<span class="nc" id="L493">                                + e.getValue().getEndInclusive())</span>
<span class="nc" id="L494">                    .collect(Collectors.joining(&quot;,&quot;)))</span>
<span class="fc" id="L495">        .addArgument(</span>
            () -&gt; {
<span class="nc" id="L497">              final BytesValueRLPOutput rlp = new BytesValueRLPOutput();</span>
<span class="nc" id="L498">              blockHeader.writeTo(rlp);</span>
<span class="nc" id="L499">              return rlp.encoded().toHexString();</span>
            })
<span class="fc" id="L501">        .log();</span>
<span class="fc" id="L502">  }</span>

  private Map&lt;Address, Long&gt; maxNonceBySender(final List&lt;Transaction&gt; confirmedTransactions) {
<span class="fc" id="L505">    return confirmedTransactions.stream()</span>
<span class="fc" id="L506">        .collect(</span>
<span class="fc" id="L507">            groupingBy(</span>
<span class="fc" id="L508">                Transaction::getSender, mapping(Transaction::getNonce, reducing(0L, Math::max))));</span>
  }

  private Map&lt;Address, LongRange&gt; nonceRangeBySender(
      final List&lt;Transaction&gt; confirmedTransactions) {

<span class="fc" id="L514">    class MutableLongRange {</span>
<span class="fc" id="L515">      long start = Long.MAX_VALUE;</span>
<span class="fc" id="L516">      long end = 0;</span>

      void update(final long nonce) {
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        if (nonce &lt; start) {</span>
<span class="fc" id="L520">          start = nonce;</span>
        }
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (nonce &gt; end) {</span>
<span class="fc" id="L523">          end = nonce;</span>
        }
<span class="fc" id="L525">      }</span>

      MutableLongRange combine(final MutableLongRange other) {
<span class="nc" id="L528">        update(other.start);</span>
<span class="nc" id="L529">        update(other.end);</span>
<span class="nc" id="L530">        return this;</span>
      }

      LongRange toImmutable() {
<span class="fc" id="L534">        return new LongRange(start, end);</span>
      }
    }

<span class="fc" id="L538">    return confirmedTransactions.stream()</span>
<span class="fc" id="L539">        .collect(</span>
<span class="fc" id="L540">            groupingBy(</span>
                Transaction::getSender,
<span class="fc" id="L542">                mapping(</span>
                    Transaction::getNonce,
<span class="fc" id="L544">                    Collector.of(</span>
<span class="fc" id="L545">                        MutableLongRange::new,</span>
                        MutableLongRange::update,
                        MutableLongRange::combine,
                        MutableLongRange::toImmutable))));
  }

  @Override
  public synchronized String toTraceLog() {
<span class="nc" id="L553">    return &quot;&quot;;</span>
  }

  @Override
  public synchronized String logStats() {
<span class="fc" id="L558">    return prioritizedTransactions.logStats();</span>
  }

  @Override
  public Optional&lt;Transaction&gt; restoreBlob(final Transaction transaction) {
<span class="fc" id="L563">    return prioritizedTransactions.getBlobCache().restoreBlob(transaction);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>