<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SparseTransactions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.transactions.layered</a> &gt; <span class="el_source">SparseTransactions.java</span></div><h1>SparseTransactions.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.transactions.layered;

import static org.hyperledger.besu.ethereum.eth.transactions.layered.TransactionsLayer.RemovalReason.INVALIDATED;
import static org.hyperledger.besu.ethereum.eth.transactions.layered.TransactionsLayer.RemovalReason.PROMOTED;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.hyperledger.besu.ethereum.eth.transactions.BlobCache;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransaction;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolConfiguration;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolMetrics;
import org.hyperledger.besu.ethereum.mainnet.feemarket.FeeMarket;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.OptionalLong;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import com.google.common.collect.Iterables;

<span class="fc" id="L50">public class SparseTransactions extends AbstractTransactionsLayer {</span>
<span class="fc" id="L51">  private final NavigableSet&lt;PendingTransaction&gt; sparseEvictionOrder =</span>
      new TreeSet&lt;&gt;(
<span class="fc" id="L53">          Comparator.comparing(PendingTransaction::hasPriority)</span>
<span class="fc" id="L54">              .thenComparing(PendingTransaction::getSequence));</span>
<span class="fc" id="L55">  private final Map&lt;Address, Integer&gt; gapBySender = new HashMap&lt;&gt;();</span>
  private final List&lt;SendersByPriority&gt; orderByGap;

  public SparseTransactions(
      final TransactionPoolConfiguration poolConfig,
      final TransactionsLayer nextLayer,
      final TransactionPoolMetrics metrics,
      final BiFunction&lt;PendingTransaction, PendingTransaction, Boolean&gt;
          transactionReplacementTester,
      final BlobCache blobCache) {
<span class="fc" id="L65">    super(poolConfig, nextLayer, transactionReplacementTester, metrics, blobCache);</span>
<span class="fc" id="L66">    orderByGap = new ArrayList&lt;&gt;(poolConfig.getMaxFutureBySender());</span>
<span class="fc" id="L67">    IntStream.range(0, poolConfig.getMaxFutureBySender())</span>
<span class="fc" id="L68">        .forEach(i -&gt; orderByGap.add(new SendersByPriority()));</span>
<span class="fc" id="L69">  }</span>

  @Override
  public String name() {
<span class="fc" id="L73">    return &quot;sparse&quot;;</span>
  }

  @Override
  protected long cacheFreeSpace() {
<span class="fc" id="L78">    return poolConfig.getPendingTransactionsLayerMaxCapacityBytes() - getLayerSpaceUsed();</span>
  }

  @Override
  protected boolean gapsAllowed() {
<span class="fc" id="L83">    return true;</span>
  }

  @Override
  public void reset() {
<span class="fc" id="L88">    super.reset();</span>
<span class="fc" id="L89">    sparseEvictionOrder.clear();</span>
<span class="fc" id="L90">    gapBySender.clear();</span>
<span class="fc" id="L91">    orderByGap.forEach(SendersByPriority::clear);</span>
<span class="fc" id="L92">  }</span>

  @Override
  protected TransactionAddedResult canAdd(
      final PendingTransaction pendingTransaction, final int gap) {
<span class="fc" id="L97">    gapBySender.compute(</span>
<span class="fc" id="L98">        pendingTransaction.getSender(),</span>
        (sender, currGap) -&gt; {
<span class="fc bfc" id="L100" title="All 2 branches covered.">          if (currGap == null) {</span>
<span class="fc" id="L101">            orderByGap.get(gap).add(pendingTransaction);</span>
<span class="fc" id="L102">            return gap;</span>
          }
<span class="fc bfc" id="L104" title="All 2 branches covered.">          if (Long.compareUnsigned(</span>
<span class="fc" id="L105">                  pendingTransaction.getNonce(), txsBySender.get(sender).firstKey())</span>
              &lt; 0) {
<span class="fc" id="L107">            orderByGap.get(currGap).remove(sender);</span>
<span class="fc" id="L108">            orderByGap.get(gap).add(pendingTransaction);</span>
<span class="fc" id="L109">            return gap;</span>
          }
<span class="fc" id="L111">          return currGap;</span>
        });

<span class="fc" id="L114">    return TransactionAddedResult.ADDED;</span>
  }

  @Override
  protected void internalAdd(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs, final PendingTransaction addedTx) {
<span class="fc" id="L120">    sparseEvictionOrder.add(addedTx);</span>
<span class="fc" id="L121">  }</span>

  @Override
  protected int maxTransactionsNumber() {
<span class="fc" id="L125">    return Integer.MAX_VALUE;</span>
  }

  @Override
  protected void internalReplaced(final PendingTransaction replacedTx) {
<span class="nc" id="L130">    sparseEvictionOrder.remove(replacedTx);</span>
<span class="nc" id="L131">  }</span>

  @Override
<span class="fc" id="L134">  protected void internalBlockAdded(final BlockHeader blockHeader, final FeeMarket feeMarket) {}</span>

  /**
   * We only want to promote transactions that have gap == 0, so there will be no gap in the prev
   * layers. A promoted transaction is removed from this layer, and the gap data is updated for its
   * sender.
   *
   * @param promotionFilter the prev layer's promotion filter
   * @param freeSpace max amount of memory promoted txs can occupy
   * @param freeSlots max number of promoted txs
   * @return a list of transactions promoted to the prev layer
   */
  @Override
  public List&lt;PendingTransaction&gt; promote(
      final Predicate&lt;PendingTransaction&gt; promotionFilter,
      final long freeSpace,
      final int freeSlots) {
<span class="fc" id="L151">    long accumulatedSpace = 0;</span>
<span class="fc" id="L152">    final List&lt;PendingTransaction&gt; promotedTxs = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L154">    final var zeroGapSenders = orderByGap.get(0);</span>

    search:
<span class="fc bfc" id="L157" title="All 2 branches covered.">    for (final var sender : zeroGapSenders) {</span>
<span class="fc" id="L158">      final var senderSeqTxs = getSequentialSubset(txsBySender.get(sender));</span>

<span class="fc bfc" id="L160" title="All 2 branches covered.">      for (final var candidateTx : senderSeqTxs.values()) {</span>

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">        if (promotionFilter.test(candidateTx)) {</span>
<span class="fc" id="L163">          accumulatedSpace += candidateTx.memorySize();</span>
<span class="pc bpc" id="L164" title="1 of 4 branches missed.">          if (promotedTxs.size() &lt; freeSlots &amp;&amp; accumulatedSpace &lt;= freeSpace) {</span>
<span class="fc" id="L165">            promotedTxs.add(candidateTx);</span>
          } else {
            // no room for more txs the search is over exit the loops
            break search;
          }
        } else {
          // skip remaining txs for this sender
          break;
        }
<span class="fc" id="L174">      }</span>
<span class="fc" id="L175">    }</span>

    // remove promoted txs from this layer
<span class="fc" id="L178">    promotedTxs.forEach(</span>
        promotedTx -&gt; {
<span class="fc" id="L180">          final var sender = promotedTx.getSender();</span>
<span class="fc" id="L181">          final var senderTxs = txsBySender.get(sender);</span>
<span class="fc" id="L182">          senderTxs.remove(promotedTx.getNonce());</span>
<span class="fc" id="L183">          processRemove(senderTxs, promotedTx.getTransaction(), PROMOTED);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">          if (senderTxs.isEmpty()) {</span>
<span class="fc" id="L185">            txsBySender.remove(sender);</span>
<span class="fc" id="L186">            orderByGap.get(0).remove(sender);</span>
<span class="fc" id="L187">            gapBySender.remove(sender);</span>
          } else {
<span class="fc" id="L189">            final long firstNonce = senderTxs.firstKey();</span>
<span class="fc" id="L190">            final int newGap = (int) (firstNonce - (promotedTx.getNonce() + 1));</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (newGap != 0) {</span>
<span class="nc" id="L192">              updateGap(sender, 0, newGap);</span>
            }
          }
<span class="fc" id="L195">        });</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (!promotedTxs.isEmpty()) {</span>
      // since we removed some txs we can try to promote from next layer
<span class="fc" id="L199">      promoteTransactions();</span>
    }

<span class="fc" id="L202">    return promotedTxs;</span>
  }

  private NavigableMap&lt;Long, PendingTransaction&gt; getSequentialSubset(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs) {
<span class="fc" id="L207">    long lastSequentialNonce = senderTxs.firstKey();</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    for (final long nonce : senderTxs.tailMap(lastSequentialNonce, false).keySet()) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">      if (nonce == lastSequentialNonce + 1) {</span>
<span class="fc" id="L210">        ++lastSequentialNonce;</span>
      } else {
        break;
      }
<span class="fc" id="L214">    }</span>
<span class="fc" id="L215">    return senderTxs.headMap(lastSequentialNonce, true);</span>
  }

  @Override
  public void remove(final PendingTransaction invalidatedTx, final RemovalReason reason) {

<span class="fc" id="L221">    final var senderTxs = txsBySender.get(invalidatedTx.getSender());</span>
<span class="fc bfc" id="L222" title="All 4 branches covered.">    if (senderTxs != null &amp;&amp; senderTxs.containsKey(invalidatedTx.getNonce())) {</span>
      // gaps are allowed here then just remove
<span class="fc" id="L224">      senderTxs.remove(invalidatedTx.getNonce());</span>
<span class="fc" id="L225">      processRemove(senderTxs, invalidatedTx.getTransaction(), reason);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">      if (senderTxs.isEmpty()) {</span>
<span class="fc" id="L227">        txsBySender.remove(invalidatedTx.getSender());</span>
      }
    } else {
<span class="fc" id="L230">      nextLayer.remove(invalidatedTx, reason);</span>
    }
<span class="fc" id="L232">  }</span>

  @Override
  protected void internalConfirmed(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final Address sender,
      final long maxConfirmedNonce,
      final PendingTransaction highestNonceRemovedTx) {

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">    if (highestNonceRemovedTx != null) {</span>
<span class="nc" id="L242">      final int currGap = gapBySender.get(sender);</span>
<span class="nc" id="L243">      final int newGap = (int) (senderTxs.firstKey() - (highestNonceRemovedTx.getNonce() + 1));</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      if (currGap != newGap) {</span>
<span class="nc" id="L245">        updateGap(sender, currGap, newGap);</span>
      }
<span class="nc" id="L247">    } else {</span>
<span class="fc" id="L248">      final int currGap = gapBySender.get(sender);</span>
<span class="fc" id="L249">      final int newGap = (int) (senderTxs.firstKey() - (maxConfirmedNonce + 1));</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">      if (newGap &lt; currGap) {</span>
<span class="fc" id="L251">        updateGap(sender, currGap, newGap);</span>
      }
    }
<span class="fc" id="L254">  }</span>

  @Override
  protected void internalEvict(
      final NavigableMap&lt;Long, PendingTransaction&gt; lessReadySenderTxs,
      final PendingTransaction evictedTx) {
<span class="fc" id="L260">    sparseEvictionOrder.remove(evictedTx);</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">    if (lessReadySenderTxs.isEmpty()) {</span>
<span class="fc" id="L263">      deleteGap(evictedTx.getSender());</span>
    }
<span class="fc" id="L265">  }</span>

  @Override
  protected void internalRemove(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final PendingTransaction removedTx,
      final RemovalReason removalReason) {

<span class="fc" id="L273">    sparseEvictionOrder.remove(removedTx);</span>

<span class="fc" id="L275">    final Address sender = removedTx.getSender();</span>

<span class="pc bpc" id="L277" title="1 of 4 branches missed.">    if (senderTxs != null &amp;&amp; !senderTxs.isEmpty()) {</span>
<span class="fc" id="L278">      final int deltaGap = (int) (senderTxs.firstKey() - removedTx.getNonce());</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">      if (deltaGap &gt; 0) {</span>
<span class="fc" id="L280">        final int currGap = gapBySender.get(sender);</span>
        final int newGap;
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (removalReason.equals(INVALIDATED)) {</span>
<span class="fc" id="L283">          newGap = currGap + deltaGap;</span>
        } else {
<span class="fc" id="L285">          newGap = deltaGap - 1;</span>
        }
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (currGap != newGap) {</span>
<span class="fc" id="L288">          updateGap(sender, currGap, newGap);</span>
        }
      }

<span class="fc" id="L292">    } else {</span>
<span class="fc" id="L293">      deleteGap(sender);</span>
    }
<span class="fc" id="L295">  }</span>

  private void deleteGap(final Address sender) {
<span class="fc" id="L298">    orderByGap.get(gapBySender.remove(sender)).remove(sender);</span>
<span class="fc" id="L299">  }</span>

  @Override
  protected PendingTransaction getEvictable() {
<span class="fc" id="L303">    return sparseEvictionOrder.first();</span>
  }

  @Override
  protected boolean promotionFilter(final PendingTransaction pendingTransaction) {
<span class="nc" id="L308">    return false;</span>
  }

  @Override
  public Stream&lt;PendingTransaction&gt; stream() {
<span class="fc" id="L313">    return sparseEvictionOrder.descendingSet().stream();</span>
  }

  @Override
  public OptionalLong getNextNonceFor(final Address sender) {
<span class="fc" id="L318">    final Integer gap = gapBySender.get(sender);</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">    if (gap != null &amp;&amp; gap == 0) {</span>
<span class="fc" id="L320">      final var senderTxs = txsBySender.get(sender);</span>
<span class="fc" id="L321">      var currNonce = senderTxs.firstKey();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">      for (final var nextNonce : senderTxs.keySet()) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (nextNonce &gt; currNonce + 1) {</span>
<span class="fc" id="L324">          break;</span>
        }
<span class="fc" id="L326">        currNonce = nextNonce;</span>
<span class="fc" id="L327">      }</span>
<span class="fc" id="L328">      return OptionalLong.of(currNonce + 1);</span>
    }
<span class="fc" id="L330">    return OptionalLong.empty();</span>
  }

  @Override
  public OptionalLong getCurrentNonceFor(final Address sender) {
<span class="fc" id="L335">    final var senderTxs = txsBySender.get(sender);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">    if (senderTxs != null) {</span>
<span class="fc" id="L337">      final var gap = gapBySender.get(sender);</span>
<span class="fc" id="L338">      return OptionalLong.of(senderTxs.firstKey() - gap);</span>
    }
<span class="fc" id="L340">    return nextLayer.getCurrentNonceFor(sender);</span>
  }

  @Override
  protected void internalNotifyAdded(
      final NavigableMap&lt;Long, PendingTransaction&gt; senderTxs,
      final PendingTransaction pendingTransaction) {
<span class="fc" id="L347">    final Address sender = pendingTransaction.getSender();</span>
<span class="fc" id="L348">    final Integer currGap = gapBySender.get(sender);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">    if (currGap != null) {</span>
<span class="fc" id="L350">      final int newGap = (int) (senderTxs.firstKey() - (pendingTransaction.getNonce() + 1));</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">      if (newGap &lt; currGap) {</span>
<span class="fc" id="L352">        updateGap(sender, currGap, newGap);</span>
      }
    }
<span class="fc" id="L355">  }</span>

  @Override
  public String logSender(final Address sender) {
<span class="nc" id="L359">    final var senderTxs = txsBySender.get(sender);</span>
<span class="nc" id="L360">    return name()</span>
        + &quot;[&quot;
<span class="nc bnc" id="L362" title="All 2 branches missed.">        + (Objects.isNull(senderTxs)</span>
<span class="nc" id="L363">            ? &quot;Empty&quot;</span>
<span class="nc" id="L364">            : &quot;gap(&quot; + gapBySender.get(sender) + &quot;) &quot; + senderTxs.keySet())</span>
        + &quot;] &quot;
<span class="nc" id="L366">        + nextLayer.logSender(sender);</span>
  }

  @Override
  public String internalLogStats() {
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">    if (sparseEvictionOrder.isEmpty()) {</span>
<span class="fc" id="L372">      return &quot;Sparse: Empty&quot;;</span>
    }

<span class="nc" id="L375">    final Transaction newest = sparseEvictionOrder.last().getTransaction();</span>
<span class="nc" id="L376">    final Transaction oldest = sparseEvictionOrder.first().getTransaction();</span>

<span class="nc" id="L378">    return &quot;Sparse: &quot;</span>
        + &quot;count=&quot;
<span class="nc" id="L380">        + pendingTransactions.size()</span>
        + &quot;, space used: &quot;
        + spaceUsed
        + &quot;, unique senders: &quot;
<span class="nc" id="L384">        + txsBySender.size()</span>
        + &quot;, oldest [gap: &quot;
<span class="nc" id="L386">        + gapBySender.get(oldest.getSender())</span>
        + &quot;, max fee:&quot;
<span class="nc" id="L388">        + oldest.getMaxGasPrice().toHumanReadableString()</span>
        + &quot;, hash: &quot;
<span class="nc" id="L390">        + oldest.getHash()</span>
        + &quot;], newest [gap: &quot;
<span class="nc" id="L392">        + gapBySender.get(newest.getSender())</span>
        + &quot;, max fee: &quot;
<span class="nc" id="L394">        + newest.getMaxGasPrice().toHumanReadableString()</span>
        + &quot;, hash: &quot;
<span class="nc" id="L396">        + newest.getHash()</span>
        + &quot;]&quot;;
  }

  private void updateGap(final Address sender, final int currGap, final int newGap) {
<span class="fc" id="L401">    final boolean hasPriority = orderByGap.get(currGap).remove(sender);</span>
<span class="fc" id="L402">    orderByGap.get(newGap).add(sender, hasPriority);</span>
<span class="fc" id="L403">    gapBySender.put(sender, newGap);</span>
<span class="fc" id="L404">  }</span>

  @Override
  protected void internalConsistencyCheck(
      final Map&lt;Address, NavigableMap&lt;Long, PendingTransaction&gt;&gt; prevLayerTxsBySender) {
<span class="nc" id="L409">    txsBySender.values().stream()</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        .filter(senderTxs -&gt; senderTxs.size() &gt; 1)</span>
<span class="nc" id="L411">        .map(NavigableMap::entrySet)</span>
<span class="nc" id="L412">        .map(Set::iterator)</span>
<span class="nc" id="L413">        .forEach(</span>
            itNonce -&gt; {
<span class="nc" id="L415">              PendingTransaction firstTx = itNonce.next().getValue();</span>

<span class="nc" id="L417">              prevLayerTxsBySender.computeIfPresent(</span>
<span class="nc" id="L418">                  firstTx.getSender(),</span>
                  (sender, txsByNonce) -&gt; {
<span class="nc" id="L420">                    final long prevLayerMaxNonce = txsByNonce.lastKey();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                    assert prevLayerMaxNonce &lt; firstTx.getNonce()</span>
                        : &quot;first nonce is not greater than previous layer last nonce&quot;;

<span class="nc" id="L424">                    final int gap = (int) (firstTx.getNonce() - (prevLayerMaxNonce + 1));</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                    assert gapBySender.get(firstTx.getSender()).equals(gap) : &quot;gap mismatch&quot;;</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                    assert orderByGap.get(gap).contains(firstTx.getSender())</span>
                        : &quot;orderByGap sender not found&quot;;

<span class="nc" id="L429">                    return txsByNonce;</span>
                  });

<span class="nc" id="L432">              long prevNonce = firstTx.getNonce();</span>

<span class="nc bnc" id="L434" title="All 2 branches missed.">              while (itNonce.hasNext()) {</span>
<span class="nc" id="L435">                final long currNonce = itNonce.next().getKey();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                assert Long.compareUnsigned(prevNonce, currNonce) &lt; 0 : &quot;non incremental nonce&quot;;</span>
<span class="nc" id="L437">                prevNonce = currNonce;</span>
<span class="nc" id="L438">              }</span>
<span class="nc" id="L439">            });</span>
<span class="nc" id="L440">  }</span>

<span class="fc" id="L442">  private static class SendersByPriority implements Iterable&lt;Address&gt; {</span>
<span class="fc" id="L443">    final Set&lt;Address&gt; prioritySenders = new HashSet&lt;&gt;();</span>
<span class="fc" id="L444">    final Set&lt;Address&gt; standardSenders = new HashSet&lt;&gt;();</span>

    void clear() {
<span class="fc" id="L447">      prioritySenders.clear();</span>
<span class="fc" id="L448">      standardSenders.clear();</span>
<span class="fc" id="L449">    }</span>

    public void add(final Address sender, final boolean hasPriority) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">      if (hasPriority) {</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if (standardSenders.contains(sender)) {</span>
<span class="nc" id="L454">          throw new IllegalStateException(</span>
              &quot;Sender &quot; + sender + &quot; cannot simultaneously have and not have priority&quot;);
        }
<span class="fc" id="L457">        prioritySenders.add(sender);</span>
      } else {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (prioritySenders.contains(sender)) {</span>
<span class="nc" id="L460">          throw new IllegalStateException(</span>
              &quot;Sender &quot; + sender + &quot; cannot simultaneously have and not have priority&quot;);
        }
<span class="fc" id="L463">        standardSenders.add(sender);</span>
      }
<span class="fc" id="L465">    }</span>

    void add(final PendingTransaction pendingTransaction) {
<span class="fc" id="L468">      add(pendingTransaction.getSender(), pendingTransaction.hasPriority());</span>
<span class="fc" id="L469">    }</span>

    boolean remove(final Address sender) {
<span class="fc bfc" id="L472" title="All 2 branches covered.">      if (standardSenders.remove(sender)) {</span>
<span class="fc" id="L473">        return false;</span>
      }
<span class="fc" id="L475">      return prioritySenders.remove(sender);</span>
    }

    public boolean contains(final Address sender) {
<span class="nc bnc" id="L479" title="All 4 branches missed.">      return standardSenders.contains(sender) || prioritySenders.contains(sender);</span>
    }

    @Override
    public Iterator&lt;Address&gt; iterator() {
<span class="fc" id="L484">      return Iterables.concat(prioritySenders, standardSenders).iterator();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>