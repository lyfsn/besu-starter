<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenesisState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.chain</a> &gt; <span class="el_source">GenesisState.java</span></div><h1>GenesisState.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.chain;

import static java.util.Collections.emptyList;
import static org.hyperledger.besu.ethereum.trie.common.GenesisWorldStateProvider.createGenesisWorldState;

import org.hyperledger.besu.config.GenesisAllocation;
import org.hyperledger.besu.config.GenesisConfigFile;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.BlobGas;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockBody;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockHeaderBuilder;
import org.hyperledger.besu.ethereum.core.Deposit;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.core.MutableWorldState;
import org.hyperledger.besu.ethereum.core.ValidatorExit;
import org.hyperledger.besu.ethereum.core.Withdrawal;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.ScheduleBasedBlockHeaderFunctions;
import org.hyperledger.besu.ethereum.worldstate.DataStorageConfiguration;
import org.hyperledger.besu.evm.account.MutableAccount;
import org.hyperledger.besu.evm.log.LogsBloomFilter;
import org.hyperledger.besu.evm.worldstate.WorldUpdater;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalLong;
import java.util.function.Function;
import java.util.stream.Stream;

import com.google.common.base.MoreObjects;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.apache.tuweni.units.bigints.UInt256;

public final class GenesisState {

  private final Block block;
  private final List&lt;GenesisAccount&gt; genesisAccounts;

<span class="fc" id="L62">  private GenesisState(final Block block, final List&lt;GenesisAccount&gt; genesisAccounts) {</span>
<span class="fc" id="L63">    this.block = block;</span>
<span class="fc" id="L64">    this.genesisAccounts = genesisAccounts;</span>
<span class="fc" id="L65">  }</span>

  /**
   * Construct a {@link GenesisState} from a JSON string.
   *
   * @param json A JSON string describing the genesis block
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromJson(final String json, final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L75">    return fromConfig(GenesisConfigFile.fromConfig(json), protocolSchedule);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON string.
   *
   * @param dataStorageConfiguration A {@link DataStorageConfiguration} describing the storage
   *     configuration
   * @param json A JSON string describing the genesis block
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromJson(
      final DataStorageConfiguration dataStorageConfiguration,
      final String json,
      final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L91">    return fromConfig(</span>
<span class="fc" id="L92">        dataStorageConfiguration, GenesisConfigFile.fromConfig(json), protocolSchedule);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON object.
   *
   * @param config A {@link GenesisConfigFile} describing the genesis block.
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromConfig(
      final GenesisConfigFile config, final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L104">    return fromConfig(DataStorageConfiguration.DEFAULT_CONFIG, config, protocolSchedule);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON object.
   *
   * @param dataStorageConfiguration A {@link DataStorageConfiguration} describing the storage
   *     configuration
   * @param config A {@link GenesisConfigFile} describing the genesis block.
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromConfig(
      final DataStorageConfiguration dataStorageConfiguration,
      final GenesisConfigFile config,
      final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L120">    final List&lt;GenesisAccount&gt; genesisAccounts = parseAllocations(config).toList();</span>
<span class="fc" id="L121">    final Block block =</span>
        new Block(
<span class="fc" id="L123">            buildHeader(</span>
                config,
<span class="fc" id="L125">                calculateGenesisStateHash(dataStorageConfiguration, genesisAccounts),</span>
                protocolSchedule),
<span class="fc" id="L127">            buildBody(config));</span>
<span class="fc" id="L128">    return new GenesisState(block, genesisAccounts);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON object.
   *
   * @param genesisStateHash The hash of the genesis state.
   * @param config A {@link GenesisConfigFile} describing the genesis block.
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromConfig(
      final Hash genesisStateHash,
      final GenesisConfigFile config,
      final ProtocolSchedule protocolSchedule) {
<span class="nc" id="L143">    final List&lt;GenesisAccount&gt; genesisAccounts = parseAllocations(config).toList();</span>
<span class="nc" id="L144">    final Block block =</span>
<span class="nc" id="L145">        new Block(buildHeader(config, genesisStateHash, protocolSchedule), buildBody(config));</span>
<span class="nc" id="L146">    return new GenesisState(block, genesisAccounts);</span>
  }

  private static BlockBody buildBody(final GenesisConfigFile config) {
    final Optional&lt;List&lt;Withdrawal&gt;&gt; withdrawals =
<span class="fc bfc" id="L151" title="All 2 branches covered.">        isShanghaiAtGenesis(config) ? Optional.of(emptyList()) : Optional.empty();</span>
    final Optional&lt;List&lt;Deposit&gt;&gt; deposits =
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        isExperimentalEipsTimeAtGenesis(config) ? Optional.of(emptyList()) : Optional.empty();</span>
    final Optional&lt;List&lt;ValidatorExit&gt;&gt; exits =
<span class="fc bfc" id="L155" title="All 2 branches covered.">        isPragueAtGenesis(config) ? Optional.of(emptyList()) : Optional.empty();</span>

<span class="fc" id="L157">    return new BlockBody(emptyList(), emptyList(), withdrawals, deposits, exits);</span>
  }

  public Block getBlock() {
<span class="fc" id="L161">    return block;</span>
  }

  /**
   * Writes the genesis block's world state to the given {@link MutableWorldState}.
   *
   * @param target WorldView to write genesis state to
   */
  public void writeStateTo(final MutableWorldState target) {
<span class="fc" id="L170">    writeAccountsTo(target, genesisAccounts, block.getHeader());</span>
<span class="fc" id="L171">  }</span>

  private static void writeAccountsTo(
      final MutableWorldState target,
      final List&lt;GenesisAccount&gt; genesisAccounts,
      final BlockHeader rootHeader) {
<span class="fc" id="L177">    final WorldUpdater updater = target.updater();</span>
<span class="fc" id="L178">    genesisAccounts.forEach(</span>
        genesisAccount -&gt; {
<span class="fc" id="L180">          final MutableAccount account = updater.getOrCreate(genesisAccount.address);</span>
<span class="fc" id="L181">          account.setNonce(genesisAccount.nonce);</span>
<span class="fc" id="L182">          account.setBalance(genesisAccount.balance);</span>
<span class="fc" id="L183">          account.setCode(genesisAccount.code);</span>
<span class="fc" id="L184">          genesisAccount.storage.forEach(account::setStorageValue);</span>
<span class="fc" id="L185">        });</span>
<span class="fc" id="L186">    updater.commit();</span>
<span class="fc" id="L187">    target.persist(rootHeader);</span>
<span class="fc" id="L188">  }</span>

  private static Hash calculateGenesisStateHash(
      final DataStorageConfiguration dataStorageConfiguration,
      final List&lt;GenesisAccount&gt; genesisAccounts) {
<span class="fc" id="L193">    try (var worldState = createGenesisWorldState(dataStorageConfiguration)) {</span>
<span class="fc" id="L194">      writeAccountsTo(worldState, genesisAccounts, null);</span>
<span class="fc" id="L195">      return worldState.rootHash();</span>
<span class="nc" id="L196">    } catch (Exception e) {</span>
<span class="nc" id="L197">      throw new RuntimeException(e);</span>
    }
  }

  private static BlockHeader buildHeader(
      final GenesisConfigFile genesis,
      final Hash genesisRootHash,
      final ProtocolSchedule protocolSchedule) {

<span class="fc" id="L206">    return BlockHeaderBuilder.create()</span>
<span class="fc" id="L207">        .parentHash(parseParentHash(genesis))</span>
<span class="fc" id="L208">        .ommersHash(Hash.EMPTY_LIST_HASH)</span>
<span class="fc" id="L209">        .coinbase(parseCoinbase(genesis))</span>
<span class="fc" id="L210">        .stateRoot(genesisRootHash)</span>
<span class="fc" id="L211">        .transactionsRoot(Hash.EMPTY_TRIE_HASH)</span>
<span class="fc" id="L212">        .receiptsRoot(Hash.EMPTY_TRIE_HASH)</span>
<span class="fc" id="L213">        .logsBloom(LogsBloomFilter.empty())</span>
<span class="fc" id="L214">        .difficulty(parseDifficulty(genesis))</span>
<span class="fc" id="L215">        .number(BlockHeader.GENESIS_BLOCK_NUMBER)</span>
<span class="fc" id="L216">        .gasLimit(genesis.getGasLimit())</span>
<span class="fc" id="L217">        .gasUsed(0L)</span>
<span class="fc" id="L218">        .timestamp(genesis.getTimestamp())</span>
<span class="fc" id="L219">        .extraData(parseExtraData(genesis))</span>
<span class="fc" id="L220">        .mixHash(parseMixHash(genesis))</span>
<span class="fc" id="L221">        .nonce(parseNonce(genesis))</span>
<span class="fc" id="L222">        .blockHeaderFunctions(ScheduleBasedBlockHeaderFunctions.create(protocolSchedule))</span>
<span class="fc" id="L223">        .baseFee(genesis.getGenesisBaseFeePerGas().orElse(null))</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        .withdrawalsRoot(isShanghaiAtGenesis(genesis) ? Hash.EMPTY_TRIE_HASH : null)</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        .blobGasUsed(isCancunAtGenesis(genesis) ? parseBlobGasUsed(genesis) : null)</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        .excessBlobGas(isCancunAtGenesis(genesis) ? parseExcessBlobGas(genesis) : null)</span>
<span class="fc" id="L227">        .parentBeaconBlockRoot(</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            (isCancunAtGenesis(genesis) ? parseParentBeaconBlockRoot(genesis) : null))</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        .depositsRoot(isExperimentalEipsTimeAtGenesis(genesis) ? Hash.EMPTY_TRIE_HASH : null)</span>
<span class="fc" id="L230">        .buildBlockHeader();</span>
  }

  private static Address parseCoinbase(final GenesisConfigFile genesis) {
<span class="fc" id="L234">    return genesis</span>
<span class="fc" id="L235">        .getCoinbase()</span>
<span class="fc" id="L236">        .map(str -&gt; withNiceErrorMessage(&quot;coinbase&quot;, str, Address::fromHexString))</span>
<span class="fc" id="L237">        .orElseGet(() -&gt; Address.wrap(Bytes.wrap(new byte[Address.SIZE])));</span>
  }

  private static &lt;T&gt; T withNiceErrorMessage(
      final String name, final String value, final Function&lt;String, T&gt; parser) {
    try {
<span class="fc" id="L243">      return parser.apply(value);</span>
<span class="nc" id="L244">    } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L245">      throw createInvalidBlockConfigException(name, value, e);</span>
    }
  }

  private static IllegalArgumentException createInvalidBlockConfigException(
      final String name, final String value, final IllegalArgumentException e) {
<span class="nc" id="L251">    return new IllegalArgumentException(</span>
        &quot;Invalid &quot; + name + &quot; in genesis block configuration: &quot; + value, e);
  }

  private static Hash parseParentHash(final GenesisConfigFile genesis) {
<span class="fc" id="L256">    return withNiceErrorMessage(&quot;parentHash&quot;, genesis.getParentHash(), Hash::fromHexStringLenient);</span>
  }

  private static Bytes parseExtraData(final GenesisConfigFile genesis) {
<span class="fc" id="L260">    return withNiceErrorMessage(&quot;extraData&quot;, genesis.getExtraData(), Bytes::fromHexString);</span>
  }

  private static Difficulty parseDifficulty(final GenesisConfigFile genesis) {
<span class="fc" id="L264">    return withNiceErrorMessage(&quot;difficulty&quot;, genesis.getDifficulty(), Difficulty::fromHexString);</span>
  }

  private static Hash parseMixHash(final GenesisConfigFile genesis) {
<span class="fc" id="L268">    return withNiceErrorMessage(&quot;mixHash&quot;, genesis.getMixHash(), Hash::fromHexStringLenient);</span>
  }

  private static Stream&lt;GenesisAccount&gt; parseAllocations(final GenesisConfigFile genesis) {
<span class="fc" id="L272">    return genesis.streamAllocations().map(GenesisAccount::fromAllocation);</span>
  }

  private static long parseNonce(final GenesisConfigFile genesis) {
<span class="fc" id="L276">    return withNiceErrorMessage(&quot;nonce&quot;, genesis.getNonce(), GenesisState::parseUnsignedLong);</span>
  }

  private static long parseBlobGasUsed(final GenesisConfigFile genesis) {
<span class="fc" id="L280">    return withNiceErrorMessage(</span>
<span class="fc" id="L281">        &quot;blobGasUsed&quot;, genesis.getBlobGasUsed(), GenesisState::parseUnsignedLong);</span>
  }

  private static BlobGas parseExcessBlobGas(final GenesisConfigFile genesis) {
<span class="fc" id="L285">    long excessBlobGas =</span>
<span class="fc" id="L286">        withNiceErrorMessage(</span>
<span class="fc" id="L287">            &quot;excessBlobGas&quot;, genesis.getExcessBlobGas(), GenesisState::parseUnsignedLong);</span>
<span class="fc" id="L288">    return BlobGas.of(excessBlobGas);</span>
  }

  private static Bytes32 parseParentBeaconBlockRoot(final GenesisConfigFile genesis) {
<span class="fc" id="L292">    return withNiceErrorMessage(</span>
<span class="fc" id="L293">        &quot;parentBeaconBlockRoot&quot;, genesis.getParentBeaconBlockRoot(), Bytes32::fromHexString);</span>
  }

  private static long parseUnsignedLong(final String value) {
<span class="fc" id="L297">    String v = value.toLowerCase(Locale.US);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">    if (v.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L299">      v = v.substring(2);</span>
    }
<span class="fc" id="L301">    return Long.parseUnsignedLong(v, 16);</span>
  }

  private static boolean isShanghaiAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L305">    final OptionalLong shanghaiTimestamp = genesis.getConfigOptions().getShanghaiTime();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">    if (shanghaiTimestamp.isPresent()) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">      return genesis.getTimestamp() &gt;= shanghaiTimestamp.getAsLong();</span>
    }
<span class="fc" id="L309">    return isCancunAtGenesis(genesis);</span>
  }

  private static boolean isCancunAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L313">    final OptionalLong cancunTimestamp = genesis.getConfigOptions().getCancunTime();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">    if (cancunTimestamp.isPresent()) {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">      return genesis.getTimestamp() &gt;= cancunTimestamp.getAsLong();</span>
    }
<span class="fc" id="L317">    return isPragueAtGenesis(genesis);</span>
  }

  private static boolean isPragueAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L321">    final OptionalLong pragueTimestamp = genesis.getConfigOptions().getPragueTime();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">    if (pragueTimestamp.isPresent()) {</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">      return genesis.getTimestamp() &gt;= pragueTimestamp.getAsLong();</span>
    }
<span class="fc" id="L325">    return isFutureEipsTimeAtGenesis(genesis);</span>
  }

  private static boolean isFutureEipsTimeAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L329">    final OptionalLong futureEipsTime = genesis.getConfigOptions().getFutureEipsTime();</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">    if (futureEipsTime.isPresent()) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">      return genesis.getTimestamp() &gt;= futureEipsTime.getAsLong();</span>
    }
<span class="fc" id="L333">    return isExperimentalEipsTimeAtGenesis(genesis);</span>
  }

  private static boolean isExperimentalEipsTimeAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L337">    final OptionalLong experimentalEipsTime = genesis.getConfigOptions().getExperimentalEipsTime();</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (experimentalEipsTime.isPresent()) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">      return genesis.getTimestamp() &gt;= experimentalEipsTime.getAsLong();</span>
    }
<span class="fc" id="L341">    return false;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L346">    return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L347">        .add(&quot;block&quot;, block)</span>
<span class="nc" id="L348">        .add(&quot;genesisAccounts&quot;, genesisAccounts)</span>
<span class="nc" id="L349">        .toString();</span>
  }

  private static final class GenesisAccount {

    final long nonce;
    final Address address;
    final Wei balance;
    final Map&lt;UInt256, UInt256&gt; storage;
    final Bytes code;

    static GenesisAccount fromAllocation(final GenesisAllocation allocation) {
<span class="fc" id="L361">      return new GenesisAccount(</span>
<span class="fc" id="L362">          allocation.getNonce(),</span>
<span class="fc" id="L363">          allocation.getAddress(),</span>
<span class="fc" id="L364">          allocation.getBalance(),</span>
<span class="fc" id="L365">          allocation.getStorage(),</span>
<span class="fc" id="L366">          allocation.getCode());</span>
    }

    private GenesisAccount(
        final String hexNonce,
        final String hexAddress,
        final String balance,
        final Map&lt;String, String&gt; storage,
<span class="fc" id="L374">        final String hexCode) {</span>
<span class="fc" id="L375">      this.nonce = withNiceErrorMessage(&quot;nonce&quot;, hexNonce, GenesisState::parseUnsignedLong);</span>
<span class="fc" id="L376">      this.address = withNiceErrorMessage(&quot;address&quot;, hexAddress, Address::fromHexString);</span>
<span class="fc" id="L377">      this.balance = withNiceErrorMessage(&quot;balance&quot;, balance, this::parseBalance);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">      this.code = hexCode != null ? Bytes.fromHexString(hexCode) : null;</span>
<span class="fc" id="L379">      this.storage = parseStorage(storage);</span>
<span class="fc" id="L380">    }</span>

    private Wei parseBalance(final String balance) {
      final BigInteger val;
<span class="fc bfc" id="L384" title="All 2 branches covered.">      if (balance.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L385">        val = new BigInteger(1, Bytes.fromHexStringLenient(balance).toArrayUnsafe());</span>
      } else {
<span class="fc" id="L387">        val = new BigInteger(balance);</span>
      }

<span class="fc" id="L390">      return Wei.of(val);</span>
    }

    private Map&lt;UInt256, UInt256&gt; parseStorage(final Map&lt;String, String&gt; storage) {
<span class="fc" id="L394">      final Map&lt;UInt256, UInt256&gt; parsedStorage = new HashMap&lt;&gt;();</span>
<span class="fc" id="L395">      storage.forEach(</span>
          (key1, value1) -&gt; {
<span class="fc" id="L397">            final UInt256 key = withNiceErrorMessage(&quot;storage key&quot;, key1, UInt256::fromHexString);</span>
<span class="fc" id="L398">            final UInt256 value =</span>
<span class="fc" id="L399">                withNiceErrorMessage(&quot;storage value&quot;, value1, UInt256::fromHexString);</span>
<span class="fc" id="L400">            parsedStorage.put(key, value);</span>
<span class="fc" id="L401">          });</span>

<span class="fc" id="L403">      return parsedStorage;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L408">      return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L409">          .add(&quot;address&quot;, address)</span>
<span class="nc" id="L410">          .add(&quot;nonce&quot;, nonce)</span>
<span class="nc" id="L411">          .add(&quot;balance&quot;, balance)</span>
<span class="nc" id="L412">          .add(&quot;storage&quot;, storage)</span>
<span class="nc" id="L413">          .add(&quot;code&quot;, code)</span>
<span class="nc" id="L414">          .toString();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>