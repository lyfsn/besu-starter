<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RocksDBColumnarKeyValueStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.plugin.services.storage.rocksdb.segmented</a> &gt; <span class="el_source">RocksDBColumnarKeyValueStorage.java</span></div><h1>RocksDBColumnarKeyValueStorage.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors..
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.plugin.services.storage.rocksdb.segmented;

import static java.util.stream.Collectors.toUnmodifiableSet;

import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.exception.StorageException;
import org.hyperledger.besu.plugin.services.metrics.OperationTimer;
import org.hyperledger.besu.plugin.services.storage.SegmentIdentifier;
import org.hyperledger.besu.plugin.services.storage.SegmentedKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.RocksDBMetrics;
import org.hyperledger.besu.plugin.services.storage.rocksdb.RocksDBMetricsFactory;
import org.hyperledger.besu.plugin.services.storage.rocksdb.RocksDbIterator;
import org.hyperledger.besu.plugin.services.storage.rocksdb.RocksDbSegmentIdentifier;
import org.hyperledger.besu.plugin.services.storage.rocksdb.RocksDbUtil;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBConfiguration;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.base.Splitter;
import com.google.common.collect.Streams;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.tuweni.bytes.Bytes;
import org.rocksdb.AbstractRocksIterator;
import org.rocksdb.BlockBasedTableConfig;
import org.rocksdb.BloomFilter;
import org.rocksdb.ColumnFamilyDescriptor;
import org.rocksdb.ColumnFamilyHandle;
import org.rocksdb.ColumnFamilyOptions;
import org.rocksdb.CompressionType;
import org.rocksdb.DBOptions;
import org.rocksdb.Env;
import org.rocksdb.LRUCache;
import org.rocksdb.Options;
import org.rocksdb.ReadOptions;
import org.rocksdb.RocksDB;
import org.rocksdb.RocksDBException;
import org.rocksdb.RocksIterator;
import org.rocksdb.Statistics;
import org.rocksdb.Status;
import org.rocksdb.TransactionDBOptions;
import org.rocksdb.WriteOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The RocksDb columnar key value storage. */
public abstract class RocksDBColumnarKeyValueStorage implements SegmentedKeyValueStorage {

<span class="fc" id="L72">  private static final Logger LOG = LoggerFactory.getLogger(RocksDBColumnarKeyValueStorage.class);</span>
  private static final int ROCKSDB_FORMAT_VERSION = 5;
  private static final long ROCKSDB_BLOCK_SIZE = 32768;

  /** RocksDb blockcache size when using the high spec option */
  protected static final long ROCKSDB_BLOCKCACHE_SIZE_HIGH_SPEC = 1_073_741_824L;

  /** RocksDb memtable size when using the high spec option */
  protected static final long ROCKSDB_MEMTABLE_SIZE_HIGH_SPEC = 536_870_912L;

  /** Max total size of all WAL file, after which a flush is triggered */
  protected static final long WAL_MAX_TOTAL_SIZE = 1_073_741_824L;

  /** Expected size of a single WAL file, to determine how many WAL files to keep around */
  protected static final long EXPECTED_WAL_FILE_SIZE = 67_108_864L;

  /** RocksDb number of log files to keep on disk */
  private static final long NUMBER_OF_LOG_FILES_TO_KEEP = 7;

  /** RocksDb Time to roll a log file (1 day = 3600 * 24 seconds) */
  private static final long TIME_TO_ROLL_LOG_FILE = 86_400L;

  static {
<span class="fc" id="L95">    RocksDbUtil.loadNativeLibrary();</span>
<span class="fc" id="L96">  }</span>

  /** atomic boolean to track if the storage is closed */
<span class="fc" id="L99">  protected final AtomicBoolean closed = new AtomicBoolean(false);</span>

<span class="fc" id="L101">  private final WriteOptions tryDeleteOptions =</span>
<span class="fc" id="L102">      new WriteOptions().setNoSlowdown(true).setIgnoreMissingColumnFamilies(true);</span>
<span class="fc" id="L103">  private final ReadOptions readOptions = new ReadOptions().setVerifyChecksums(false);</span>
  private final MetricsSystem metricsSystem;
  private final RocksDBMetricsFactory rocksDBMetricsFactory;
  private final RocksDBConfiguration configuration;

  /** RocksDB DB options */
  protected DBOptions options;

  /** RocksDb transactionDB options */
  protected TransactionDBOptions txOptions;

  /** RocksDb statistics */
<span class="fc" id="L115">  protected final Statistics stats = new Statistics();</span>

  /** RocksDB metrics */
  protected RocksDBMetrics metrics;

  /** Map of the columns handles by name */
  protected Map&lt;SegmentIdentifier, RocksDbSegmentIdentifier&gt; columnHandlesBySegmentIdentifier;

  /** Column descriptors */
  protected List&lt;ColumnFamilyDescriptor&gt; columnDescriptors;

  /** Column handles */
  protected List&lt;ColumnFamilyHandle&gt; columnHandles;

  /** Trimmed segments */
  protected List&lt;SegmentIdentifier&gt; trimmedSegments;

  /**
   * Instantiates a new Rocks db columnar key value storage.
   *
   * @param configuration the configuration
   * @param defaultSegments the segments
   * @param ignorableSegments the ignorable segments
   * @param metricsSystem the metrics system
   * @param rocksDBMetricsFactory the rocks db metrics factory
   * @throws StorageException the storage exception
   */
  public RocksDBColumnarKeyValueStorage(
      final RocksDBConfiguration configuration,
      final List&lt;SegmentIdentifier&gt; defaultSegments,
      final List&lt;SegmentIdentifier&gt; ignorableSegments,
      final MetricsSystem metricsSystem,
      final RocksDBMetricsFactory rocksDBMetricsFactory)
<span class="fc" id="L148">      throws StorageException {</span>

<span class="fc" id="L150">    this.configuration = configuration;</span>
<span class="fc" id="L151">    this.metricsSystem = metricsSystem;</span>
<span class="fc" id="L152">    this.rocksDBMetricsFactory = rocksDBMetricsFactory;</span>

    try {
<span class="fc" id="L155">      trimmedSegments = new ArrayList&lt;&gt;(defaultSegments);</span>
<span class="fc" id="L156">      final List&lt;byte[]&gt; existingColumnFamilies =</span>
<span class="fc" id="L157">          RocksDB.listColumnFamilies(new Options(), configuration.getDatabaseDir().toString());</span>
      // Only ignore if not existed currently
<span class="fc" id="L159">      ignorableSegments.stream()</span>
<span class="fc" id="L160">          .filter(</span>
              ignorableSegment -&gt;
<span class="fc" id="L162">                  existingColumnFamilies.stream()</span>
<span class="fc" id="L163">                      .noneMatch(existed -&gt; Arrays.equals(existed, ignorableSegment.getId())))</span>
<span class="fc" id="L164">          .forEach(trimmedSegments::remove);</span>
<span class="fc" id="L165">      columnDescriptors =</span>
<span class="fc" id="L166">          trimmedSegments.stream()</span>
<span class="fc" id="L167">              .map(segment -&gt; createColumnDescriptor(segment, configuration))</span>
<span class="fc" id="L168">              .collect(Collectors.toList());</span>

<span class="fc" id="L170">      setGlobalOptions(configuration, stats);</span>

<span class="fc" id="L172">      txOptions = new TransactionDBOptions();</span>
<span class="fc" id="L173">      columnHandles = new ArrayList&lt;&gt;(columnDescriptors.size());</span>
<span class="nc" id="L174">    } catch (RocksDBException e) {</span>
<span class="nc" id="L175">      throw parseRocksDBException(e, defaultSegments, ignorableSegments);</span>
<span class="fc" id="L176">    }</span>
<span class="fc" id="L177">  }</span>

  /**
   * Create a Column Family Descriptor for a given segment It defines basically the different
   * options to apply to the corresponding Column Family
   *
   * @param segment the segment identifier
   * @param configuration RocksDB configuration
   * @return a column family descriptor
   */
  private ColumnFamilyDescriptor createColumnDescriptor(
      final SegmentIdentifier segment, final RocksDBConfiguration configuration) {

<span class="fc" id="L190">    BlockBasedTableConfig basedTableConfig = createBlockBasedTableConfig(segment, configuration);</span>

<span class="fc" id="L192">    final var options =</span>
        new ColumnFamilyOptions()
<span class="fc" id="L194">            .setTtl(0)</span>
<span class="fc" id="L195">            .setCompressionType(CompressionType.LZ4_COMPRESSION)</span>
<span class="fc" id="L196">            .setTableFormatConfig(basedTableConfig);</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (segment.containsStaticData()) {</span>
<span class="fc" id="L199">      options</span>
<span class="fc" id="L200">          .setEnableBlobFiles(true)</span>
<span class="fc" id="L201">          .setEnableBlobGarbageCollection(segment.isStaticDataGarbageCollectionEnabled())</span>
<span class="fc" id="L202">          .setMinBlobSize(100)</span>
<span class="fc" id="L203">          .setBlobCompressionType(CompressionType.LZ4_COMPRESSION);</span>
    }

<span class="fc" id="L206">    return new ColumnFamilyDescriptor(segment.getId(), options);</span>
  }

  /***
   * Create a Block Base Table configuration for each segment, depending on the configuration in place
   * and the segment itself
   *
   * @param segment The segment related to the column family
   * @param config RocksDB configuration
   * @return Block Base Table configuration
   */
  private BlockBasedTableConfig createBlockBasedTableConfig(
      final SegmentIdentifier segment, final RocksDBConfiguration config) {
<span class="fc" id="L219">    final LRUCache cache =</span>
        new LRUCache(
<span class="pc bpc" id="L221" title="3 of 4 branches missed.">            config.isHighSpec() &amp;&amp; segment.isEligibleToHighSpecFlag()</span>
<span class="nc" id="L222">                ? ROCKSDB_BLOCKCACHE_SIZE_HIGH_SPEC</span>
<span class="fc" id="L223">                : config.getCacheCapacity());</span>
<span class="fc" id="L224">    return new BlockBasedTableConfig()</span>
<span class="fc" id="L225">        .setFormatVersion(ROCKSDB_FORMAT_VERSION)</span>
<span class="fc" id="L226">        .setBlockCache(cache)</span>
<span class="fc" id="L227">        .setFilterPolicy(new BloomFilter(10, false))</span>
<span class="fc" id="L228">        .setPartitionFilters(true)</span>
<span class="fc" id="L229">        .setCacheIndexAndFilterBlocks(false)</span>
<span class="fc" id="L230">        .setBlockSize(ROCKSDB_BLOCK_SIZE);</span>
  }

  /***
   * Set Global options (DBOptions)
   *
   * @param configuration RocksDB configuration
   * @param stats The statistics object
   */
  private void setGlobalOptions(final RocksDBConfiguration configuration, final Statistics stats) {
<span class="fc" id="L240">    options = new DBOptions();</span>
<span class="fc" id="L241">    options</span>
<span class="fc" id="L242">        .setCreateIfMissing(true)</span>
<span class="fc" id="L243">        .setMaxOpenFiles(configuration.getMaxOpenFiles())</span>
<span class="fc" id="L244">        .setStatistics(stats)</span>
<span class="fc" id="L245">        .setCreateMissingColumnFamilies(true)</span>
<span class="fc" id="L246">        .setLogFileTimeToRoll(TIME_TO_ROLL_LOG_FILE)</span>
<span class="fc" id="L247">        .setKeepLogFileNum(NUMBER_OF_LOG_FILES_TO_KEEP)</span>
<span class="fc" id="L248">        .setEnv(Env.getDefault().setBackgroundThreads(configuration.getBackgroundThreadCount()))</span>
<span class="fc" id="L249">        .setMaxTotalWalSize(WAL_MAX_TOTAL_SIZE)</span>
<span class="fc" id="L250">        .setRecycleLogFileNum(WAL_MAX_TOTAL_SIZE / EXPECTED_WAL_FILE_SIZE);</span>
<span class="fc" id="L251">  }</span>

  /**
   * Parse RocksDBException and wrap in StorageException
   *
   * @param ex RocksDBException
   * @param defaultSegments segments requested to open
   * @param ignorableSegments segments which are ignorable if not present
   * @return StorageException wrapping the RocksDB Exception
   */
  protected static StorageException parseRocksDBException(
      final RocksDBException ex,
      final List&lt;SegmentIdentifier&gt; defaultSegments,
      final List&lt;SegmentIdentifier&gt; ignorableSegments) {
<span class="fc" id="L265">    String message = ex.getMessage();</span>
<span class="fc" id="L266">    List&lt;SegmentIdentifier&gt; knownSegments =</span>
<span class="fc" id="L267">        Streams.concat(defaultSegments.stream(), ignorableSegments.stream()).distinct().toList();</span>

    // parse out unprintable segment names for a more useful exception:
<span class="fc" id="L270">    String columnExceptionMessagePrefix = &quot;Column families not opened: &quot;;</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    if (message.contains(columnExceptionMessagePrefix)) {</span>
<span class="fc" id="L272">      String substring = message.substring(message.indexOf(&quot;: &quot;) + 2);</span>

<span class="fc" id="L274">      List&lt;String&gt; unHandledSegments = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L275">      Splitter.on(&quot;, &quot;)</span>
<span class="fc" id="L276">          .splitToStream(substring)</span>
<span class="fc" id="L277">          .forEach(</span>
              part -&gt; {
<span class="fc" id="L279">                byte[] bytes = part.getBytes(StandardCharsets.UTF_8);</span>
<span class="fc" id="L280">                unHandledSegments.add(</span>
<span class="fc" id="L281">                    knownSegments.stream()</span>
<span class="fc" id="L282">                        .filter(seg -&gt; Arrays.equals(seg.getId(), bytes))</span>
<span class="fc" id="L283">                        .findFirst()</span>
<span class="pc" id="L284">                        .map(seg -&gt; new SegmentRecord(seg.getName(), seg.getId()))</span>
<span class="fc" id="L285">                        .orElse(new SegmentRecord(part, bytes))</span>
<span class="fc" id="L286">                        .forDisplay());</span>
<span class="fc" id="L287">              });</span>

<span class="fc" id="L289">      return new StorageException(</span>
          &quot;RocksDBException: Unhandled column families: [&quot;
<span class="fc" id="L291">              + unHandledSegments.stream().collect(Collectors.joining(&quot;, &quot;))</span>
              + &quot;]&quot;);
    } else {
<span class="nc" id="L294">      return new StorageException(ex);</span>
    }
  }

  void initMetrics() {
<span class="fc" id="L299">    metrics = rocksDBMetricsFactory.create(metricsSystem, configuration, getDB(), stats);</span>
<span class="fc" id="L300">  }</span>

  void initColumnHandles() throws RocksDBException {
    // will not include the DEFAULT columnHandle, we do not use it:
<span class="fc" id="L304">    columnHandlesBySegmentIdentifier =</span>
<span class="fc" id="L305">        trimmedSegments.stream()</span>
<span class="fc" id="L306">            .collect(</span>
<span class="fc" id="L307">                Collectors.toMap(</span>
<span class="fc" id="L308">                    segmentId -&gt; segmentId,</span>
                    segment -&gt; {
<span class="fc" id="L310">                      var columnHandle =</span>
<span class="fc" id="L311">                          columnHandles.stream()</span>
<span class="fc" id="L312">                              .filter(</span>
                                  ch -&gt; {
                                    try {
<span class="fc" id="L315">                                      return Arrays.equals(ch.getName(), segment.getId());</span>
<span class="nc" id="L316">                                    } catch (RocksDBException e) {</span>
<span class="nc" id="L317">                                      throw new RuntimeException(e);</span>
                                    }
                                  })
<span class="fc" id="L320">                              .findFirst()</span>
<span class="fc" id="L321">                              .orElseThrow(</span>
                                  () -&gt;
<span class="nc" id="L323">                                      new RuntimeException(</span>
                                          &quot;Column handle not found for segment &quot;
<span class="nc" id="L325">                                              + segment.getName()));</span>
<span class="fc" id="L326">                      return new RocksDbSegmentIdentifier(getDB(), columnHandle);</span>
                    }));
<span class="fc" id="L328">  }</span>

  /**
   * Safe method to map segment identifier to column handle.
   *
   * @param segment segment identifier
   * @return column handle
   */
  protected ColumnFamilyHandle safeColumnHandle(final SegmentIdentifier segment) {
<span class="fc" id="L337">    RocksDbSegmentIdentifier safeRef = columnHandlesBySegmentIdentifier.get(segment);</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (safeRef == null) {</span>
<span class="nc" id="L339">      throw new RuntimeException(&quot;Column handle not found for segment &quot; + segment.getName());</span>
    }
<span class="fc" id="L341">    return safeRef.get();</span>
  }

  @Override
  public Optional&lt;byte[]&gt; get(final SegmentIdentifier segment, final byte[] key)
      throws StorageException {
<span class="fc" id="L347">    throwIfClosed();</span>

<span class="fc" id="L349">    try (final OperationTimer.TimingContext ignored = metrics.getReadLatency().startTimer()) {</span>
<span class="fc" id="L350">      return Optional.ofNullable(getDB().get(safeColumnHandle(segment), readOptions, key));</span>
<span class="nc" id="L351">    } catch (final RocksDBException e) {</span>
<span class="nc" id="L352">      throw new StorageException(e);</span>
    }
  }

  @Override
  public Optional&lt;NearestKeyValue&gt; getNearestTo(
      final SegmentIdentifier segmentIdentifier, final Bytes key) throws StorageException {

<span class="nc" id="L360">    try (final RocksIterator rocksIterator =</span>
<span class="nc" id="L361">        getDB().newIterator(safeColumnHandle(segmentIdentifier))) {</span>
<span class="nc" id="L362">      rocksIterator.seekForPrev(key.toArrayUnsafe());</span>
<span class="nc" id="L363">      return Optional.of(rocksIterator)</span>
<span class="nc" id="L364">          .filter(AbstractRocksIterator::isValid)</span>
<span class="nc" id="L365">          .map(it -&gt; new NearestKeyValue(Bytes.of(it.key()), Optional.of(it.value())));</span>
    }
  }

  @Override
  public Stream&lt;Pair&lt;byte[], byte[]&gt;&gt; stream(final SegmentIdentifier segmentIdentifier) {
<span class="fc" id="L371">    final RocksIterator rocksIterator = getDB().newIterator(safeColumnHandle(segmentIdentifier));</span>
<span class="fc" id="L372">    rocksIterator.seekToFirst();</span>
<span class="fc" id="L373">    return RocksDbIterator.create(rocksIterator).toStream();</span>
  }

  @Override
  public Stream&lt;Pair&lt;byte[], byte[]&gt;&gt; streamFromKey(
      final SegmentIdentifier segmentIdentifier, final byte[] startKey) {
<span class="nc" id="L379">    final RocksIterator rocksIterator = getDB().newIterator(safeColumnHandle(segmentIdentifier));</span>
<span class="nc" id="L380">    rocksIterator.seek(startKey);</span>
<span class="nc" id="L381">    return RocksDbIterator.create(rocksIterator).toStream();</span>
  }

  @Override
  public Stream&lt;Pair&lt;byte[], byte[]&gt;&gt; streamFromKey(
      final SegmentIdentifier segmentIdentifier, final byte[] startKey, final byte[] endKey) {
<span class="nc" id="L387">    final Bytes endKeyBytes = Bytes.wrap(endKey);</span>
<span class="nc" id="L388">    final RocksIterator rocksIterator = getDB().newIterator(safeColumnHandle(segmentIdentifier));</span>
<span class="nc" id="L389">    rocksIterator.seek(startKey);</span>
<span class="nc" id="L390">    return RocksDbIterator.create(rocksIterator)</span>
<span class="nc" id="L391">        .toStream()</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        .takeWhile(e -&gt; endKeyBytes.compareTo(Bytes.wrap(e.getKey())) &gt;= 0);</span>
  }

  @Override
  public Stream&lt;byte[]&gt; streamKeys(final SegmentIdentifier segmentIdentifier) {
<span class="nc" id="L397">    final RocksIterator rocksIterator = getDB().newIterator(safeColumnHandle(segmentIdentifier));</span>
<span class="nc" id="L398">    rocksIterator.seekToFirst();</span>
<span class="nc" id="L399">    return RocksDbIterator.create(rocksIterator).toStreamKeys();</span>
  }

  @Override
  public boolean tryDelete(final SegmentIdentifier segmentIdentifier, final byte[] key) {
    try {
<span class="fc" id="L405">      getDB().delete(safeColumnHandle(segmentIdentifier), tryDeleteOptions, key);</span>
<span class="fc" id="L406">      return true;</span>
<span class="nc" id="L407">    } catch (RocksDBException e) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">      if (e.getStatus().getCode() == Status.Code.Incomplete) {</span>
<span class="nc" id="L409">        return false;</span>
      } else {
<span class="nc" id="L411">        throw new StorageException(e);</span>
      }
    }
  }

  @Override
  public Set&lt;byte[]&gt; getAllKeysThat(
      final SegmentIdentifier segmentIdentifier, final Predicate&lt;byte[]&gt; returnCondition) {
<span class="fc" id="L419">    return stream(segmentIdentifier)</span>
<span class="fc" id="L420">        .filter(pair -&gt; returnCondition.test(pair.getKey()))</span>
<span class="fc" id="L421">        .map(Pair::getKey)</span>
<span class="fc" id="L422">        .collect(toUnmodifiableSet());</span>
  }

  @Override
  public Set&lt;byte[]&gt; getAllValuesFromKeysThat(
      final SegmentIdentifier segmentIdentifier, final Predicate&lt;byte[]&gt; returnCondition) {
<span class="nc" id="L428">    return stream(segmentIdentifier)</span>
<span class="nc" id="L429">        .filter(pair -&gt; returnCondition.test(pair.getKey()))</span>
<span class="nc" id="L430">        .map(Pair::getValue)</span>
<span class="nc" id="L431">        .collect(toUnmodifiableSet());</span>
  }

  @Override
  public void clear(final SegmentIdentifier segmentIdentifier) {
<span class="fc" id="L436">    Optional.ofNullable(columnHandlesBySegmentIdentifier.get(segmentIdentifier))</span>
<span class="fc" id="L437">        .ifPresent(RocksDbSegmentIdentifier::reset);</span>
<span class="fc" id="L438">  }</span>

  @Override
  public void close() {
<span class="fc bfc" id="L442" title="All 2 branches covered.">    if (closed.compareAndSet(false, true)) {</span>
<span class="fc" id="L443">      txOptions.close();</span>
<span class="fc" id="L444">      options.close();</span>
<span class="fc" id="L445">      tryDeleteOptions.close();</span>
<span class="fc" id="L446">      columnHandlesBySegmentIdentifier.values().stream()</span>
<span class="fc" id="L447">          .map(RocksDbSegmentIdentifier::get)</span>
<span class="fc" id="L448">          .forEach(ColumnFamilyHandle::close);</span>
<span class="fc" id="L449">      getDB().close();</span>
    }
<span class="fc" id="L451">  }</span>

  @Override
  public boolean isClosed() {
<span class="fc" id="L455">    return closed.get();</span>
  }

  void throwIfClosed() {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">    if (closed.get()) {</span>
<span class="nc" id="L460">      LOG.error(&quot;Attempting to use a closed RocksDbKeyValueStorage&quot;);</span>
<span class="nc" id="L461">      throw new IllegalStateException(&quot;Storage has been closed&quot;);</span>
    }
<span class="fc" id="L463">  }</span>

  abstract RocksDB getDB();

<span class="pc" id="L467">  record SegmentRecord(String name, byte[] id) {</span>
    public String forDisplay() {
<span class="fc" id="L469">      return String.format(&quot;'%s'(%s)&quot;, name, Bytes.of(id).toHexString());</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>