<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PostMergeContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.merge</a> &gt; <span class="el_source">PostMergeContext.java</span></div><h1>PostMergeContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.merge;

import org.hyperledger.besu.consensus.merge.blockcreation.PayloadIdentifier;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.ethereum.ConsensusContext;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockValueCalculator;
import org.hyperledger.besu.ethereum.core.BlockWithReceipts;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.eth.sync.state.SyncState;
import org.hyperledger.besu.util.Subscribers;

import java.util.Comparator;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.EvictingQueue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Post merge context. */
public class PostMergeContext implements MergeContext {
<span class="fc" id="L42">  private static final Logger LOG = LoggerFactory.getLogger(PostMergeContext.class);</span>

  /** The Max blocks in progress. */
  static final int MAX_BLOCKS_IN_PROGRESS = 12;

<span class="fc" id="L47">  private static final AtomicReference&lt;PostMergeContext&gt; singleton = new AtomicReference&lt;&gt;();</span>

<span class="fc" id="L49">  private static final Comparator&lt;BlockWithReceipts&gt; compareByGasUsedDesc =</span>
<span class="fc" id="L50">      Comparator.comparingLong(</span>
              (BlockWithReceipts blockWithReceipts) -&gt;
<span class="fc" id="L52">                  blockWithReceipts.getBlock().getHeader().getGasUsed())</span>
<span class="fc" id="L53">          .reversed();</span>

  private final AtomicReference&lt;SyncState&gt; syncState;
  private final AtomicReference&lt;Difficulty&gt; terminalTotalDifficulty;
  // initial postMerge state is indeterminate until it is set:
<span class="fc" id="L58">  private final AtomicReference&lt;Optional&lt;Boolean&gt;&gt; isPostMerge =</span>
<span class="fc" id="L59">      new AtomicReference&lt;&gt;(Optional.empty());</span>
<span class="fc" id="L60">  private final Subscribers&lt;MergeStateHandler&gt; newMergeStateCallbackSubscribers =</span>
<span class="fc" id="L61">      Subscribers.create();</span>
<span class="fc" id="L62">  private final Subscribers&lt;UnverifiedForkchoiceListener&gt;</span>
<span class="fc" id="L63">      newUnverifiedForkchoiceCallbackSubscribers = Subscribers.create();</span>

<span class="fc" id="L65">  private final EvictingQueue&lt;PayloadWrapper&gt; blocksInProgress =</span>
<span class="fc" id="L66">      EvictingQueue.create(MAX_BLOCKS_IN_PROGRESS);</span>

  // latest finalized block
<span class="fc" id="L69">  private final AtomicReference&lt;BlockHeader&gt; lastFinalized = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L70">  private final AtomicReference&lt;BlockHeader&gt; lastSafeBlock = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L71">  private final AtomicReference&lt;Optional&lt;BlockHeader&gt;&gt; terminalPoWBlock =</span>
<span class="fc" id="L72">      new AtomicReference&lt;&gt;(Optional.empty());</span>
<span class="fc" id="L73">  private final BlockValueCalculator blockValueCalculator = new BlockValueCalculator();</span>
  private boolean isPostMergeAtGenesis;

  /** Instantiates a new Post merge context. */
  @VisibleForTesting
  PostMergeContext() {
<span class="fc" id="L79">    this(Difficulty.ZERO);</span>
<span class="fc" id="L80">  }</span>

  /**
   * Instantiates a new Post merge context.
   *
   * @param difficulty the difficulty
   */
  @VisibleForTesting
<span class="fc" id="L88">  PostMergeContext(final Difficulty difficulty) {</span>
<span class="fc" id="L89">    this.terminalTotalDifficulty = new AtomicReference&lt;&gt;(difficulty);</span>
<span class="fc" id="L90">    this.syncState = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L91">  }</span>

  /**
   * Get post merge context.
   *
   * @return the post merge context
   */
  public static PostMergeContext get() {
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (singleton.get() == null) {</span>
<span class="fc" id="L100">      singleton.compareAndSet(null, new PostMergeContext());</span>
    }
<span class="fc" id="L102">    return singleton.get();</span>
  }

  @Override
  public &lt;C extends ConsensusContext&gt; C as(final Class&lt;C&gt; klass) {
<span class="fc" id="L107">    return klass.cast(this);</span>
  }

  @Override
  public PostMergeContext setTerminalTotalDifficulty(final Difficulty newTerminalTotalDifficulty) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">    if (newTerminalTotalDifficulty == null) {</span>
<span class="nc" id="L113">      throw new IllegalStateException(&quot;cannot set null terminal total difficulty&quot;);</span>
    }
<span class="fc" id="L115">    terminalTotalDifficulty.set(newTerminalTotalDifficulty);</span>
<span class="fc" id="L116">    return this;</span>
  }

  @Override
  public void setIsPostMerge(final Difficulty totalDifficulty) {
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (isPostMerge.get().orElse(Boolean.FALSE)) {</span>
      // if we have finalized, we never switch back to a pre-merge once we have transitioned
      // post-TTD.
<span class="fc" id="L124">      return;</span>
    }
<span class="fc" id="L126">    final boolean newState = terminalTotalDifficulty.get().lessOrEqualThan(totalDifficulty);</span>
<span class="fc" id="L127">    final Optional&lt;Boolean&gt; oldState = isPostMerge.getAndSet(Optional.of(newState));</span>

    // if we are past TTD, set it:
<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (newState)</span>
<span class="fc" id="L131">      Optional.ofNullable(syncState.get())</span>
<span class="fc" id="L132">          .ifPresent(ss -&gt; ss.setReachedTerminalDifficulty(newState));</span>

<span class="fc bfc" id="L134" title="All 4 branches covered.">    if (oldState.isEmpty() || oldState.get() != newState) {</span>
<span class="fc" id="L135">      newMergeStateCallbackSubscribers.forEach(</span>
          newMergeStateCallback -&gt;
<span class="fc" id="L137">              newMergeStateCallback.mergeStateChanged(</span>
<span class="fc" id="L138">                  newState, oldState, Optional.of(totalDifficulty)));</span>
    }
<span class="fc" id="L140">  }</span>

  @Override
  public boolean isPostMerge() {
<span class="fc" id="L144">    return isPostMerge.get().orElse(Boolean.FALSE);</span>
  }

  @Override
  public PostMergeContext setSyncState(final SyncState syncState) {
<span class="fc" id="L149">    this.syncState.set(syncState);</span>
<span class="fc" id="L150">    return this;</span>
  }

  @Override
  public boolean isSyncing() {
<span class="fc bfc" id="L155" title="All 4 branches covered.">    return Optional.ofNullable(syncState.get()).map(s -&gt; !s.isInSync()).orElse(Boolean.TRUE)</span>
        // this is necessary for when we do not have a sync target yet, like at startup.
        // not being stopped at ttd implies we are syncing.
<span class="fc" id="L158">        &amp;&amp; Optional.ofNullable(syncState.get())</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            .map(s -&gt; !(s.hasReachedTerminalDifficulty().orElse(Boolean.FALSE)))</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            .orElse(Boolean.TRUE);</span>
  }

  @Override
  public void observeNewIsPostMergeState(final MergeStateHandler mergeStateHandler) {
<span class="fc" id="L165">    newMergeStateCallbackSubscribers.subscribe(mergeStateHandler);</span>
<span class="fc" id="L166">  }</span>

  @Override
  public long addNewUnverifiedForkchoiceListener(
      final UnverifiedForkchoiceListener unverifiedForkchoiceListener) {
<span class="fc" id="L171">    return newUnverifiedForkchoiceCallbackSubscribers.subscribe(unverifiedForkchoiceListener);</span>
  }

  @Override
  public void removeNewUnverifiedForkchoiceListener(final long subscriberId) {
<span class="nc" id="L176">    newUnverifiedForkchoiceCallbackSubscribers.unsubscribe(subscriberId);</span>
<span class="nc" id="L177">  }</span>

  @Override
  public void fireNewUnverifiedForkchoiceEvent(
      final Hash headBlockHash, final Hash safeBlockHash, final Hash finalizedBlockHash) {
<span class="nc" id="L182">    final ForkchoiceEvent event =</span>
        new ForkchoiceEvent(headBlockHash, safeBlockHash, finalizedBlockHash);
<span class="nc" id="L184">    newUnverifiedForkchoiceCallbackSubscribers.forEach(cb -&gt; cb.onNewUnverifiedForkchoice(event));</span>
<span class="nc" id="L185">  }</span>

  @Override
  public Difficulty getTerminalTotalDifficulty() {
<span class="fc" id="L189">    return terminalTotalDifficulty.get();</span>
  }

  @Override
  public void setFinalized(final BlockHeader blockHeader) {
<span class="fc" id="L194">    lastFinalized.set(blockHeader);</span>
<span class="fc" id="L195">  }</span>

  @Override
  public Optional&lt;BlockHeader&gt; getFinalized() {
<span class="fc" id="L199">    return Optional.ofNullable(lastFinalized.get());</span>
  }

  @Override
  public void setSafeBlock(final BlockHeader blockHeader) {
<span class="nc" id="L204">    lastSafeBlock.set(blockHeader);</span>
<span class="nc" id="L205">  }</span>

  @Override
  public Optional&lt;BlockHeader&gt; getSafeBlock() {
<span class="nc" id="L209">    return Optional.ofNullable(lastSafeBlock.get());</span>
  }

  @Override
  public Optional&lt;BlockHeader&gt; getTerminalPoWBlock() {
<span class="fc" id="L214">    return terminalPoWBlock.get();</span>
  }

  @Override
  public void setTerminalPoWBlock(final Optional&lt;BlockHeader&gt; hashAndNumber) {
<span class="fc" id="L219">    terminalPoWBlock.set(hashAndNumber);</span>
<span class="fc" id="L220">  }</span>

  @Override
  public boolean validateCandidateHead(final BlockHeader candidateHeader) {
<span class="fc" id="L224">    return Optional.ofNullable(lastFinalized.get())</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">        .map(finalized -&gt; candidateHeader.getNumber() &gt;= finalized.getNumber())</span>
<span class="fc" id="L226">        .orElse(Boolean.TRUE);</span>
  }

  @Override
  public void putPayloadById(final PayloadWrapper payloadWrapper) {
<span class="fc" id="L231">    synchronized (blocksInProgress) {</span>
<span class="fc" id="L232">      final Optional&lt;BlockWithReceipts&gt; maybeCurrBestBlock =</span>
<span class="fc" id="L233">          retrieveBlockById(payloadWrapper.payloadIdentifier());</span>

<span class="fc" id="L235">      maybeCurrBestBlock.ifPresentOrElse(</span>
          currBestBlock -&gt; {
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (compareByGasUsedDesc.compare(payloadWrapper.blockWithReceipts(), currBestBlock)</span>
                &lt; 0) {
<span class="fc" id="L239">              LOG.atDebug()</span>
<span class="fc" id="L240">                  .setMessage(&quot;New proposal for payloadId {} {} is better than the previous one {}&quot;)</span>
<span class="fc" id="L241">                  .addArgument(payloadWrapper.payloadIdentifier())</span>
<span class="fc" id="L242">                  .addArgument(</span>
<span class="nc" id="L243">                      () -&gt; logBlockProposal(payloadWrapper.blockWithReceipts().getBlock()))</span>
<span class="pc" id="L244">                  .addArgument(() -&gt; logBlockProposal(currBestBlock.getBlock()))</span>
<span class="fc" id="L245">                  .log();</span>
<span class="fc" id="L246">              blocksInProgress.removeAll(</span>
<span class="fc" id="L247">                  retrievePayloadsById(payloadWrapper.payloadIdentifier())</span>
<span class="fc" id="L248">                      .collect(Collectors.toUnmodifiableList()));</span>
<span class="fc" id="L249">              blocksInProgress.add(</span>
                  new PayloadWrapper(
<span class="fc" id="L251">                      payloadWrapper.payloadIdentifier(), payloadWrapper.blockWithReceipts()));</span>
<span class="fc" id="L252">              logCurrentBestBlock(payloadWrapper.blockWithReceipts());</span>
            }
<span class="fc" id="L254">          },</span>
          () -&gt;
<span class="fc" id="L256">              blocksInProgress.add(</span>
                  new PayloadWrapper(
<span class="fc" id="L258">                      payloadWrapper.payloadIdentifier(), payloadWrapper.blockWithReceipts())));</span>
<span class="fc" id="L259">    }</span>
<span class="fc" id="L260">  }</span>

  private void logCurrentBestBlock(final BlockWithReceipts blockWithReceipts) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L264">      final Block block = blockWithReceipts.getBlock();</span>
<span class="nc" id="L265">      final float gasUsedPerc =</span>
<span class="nc" id="L266">          100.0f * block.getHeader().getGasUsed() / block.getHeader().getGasLimit();</span>
<span class="nc" id="L267">      final int txsNum = block.getBody().getTransactions().size();</span>
<span class="nc" id="L268">      final Wei reward = blockValueCalculator.calculateBlockValue(blockWithReceipts);</span>

<span class="nc" id="L270">      LOG.debug(</span>
          &quot;Current best proposal for block {}: txs {}, gas used {}%, reward {}&quot;,
<span class="nc" id="L272">          blockWithReceipts.getNumber(),</span>
<span class="nc" id="L273">          txsNum,</span>
<span class="nc" id="L274">          String.format(&quot;%1.2f&quot;, gasUsedPerc),</span>
<span class="nc" id="L275">          reward.toHumanReadableString());</span>
    }
<span class="fc" id="L277">  }</span>

  @Override
  public Optional&lt;BlockWithReceipts&gt; retrieveBlockById(final PayloadIdentifier payloadId) {
<span class="fc" id="L281">    synchronized (blocksInProgress) {</span>
<span class="fc" id="L282">      return retrievePayloadsById(payloadId)</span>
<span class="fc" id="L283">          .map(payloadWrapper -&gt; payloadWrapper.blockWithReceipts())</span>
<span class="fc" id="L284">          .sorted(compareByGasUsedDesc)</span>
<span class="fc" id="L285">          .findFirst();</span>
    }
  }

  private Stream&lt;PayloadWrapper&gt; retrievePayloadsById(final PayloadIdentifier payloadId) {
<span class="fc" id="L290">    return blocksInProgress.stream().filter(z -&gt; z.payloadIdentifier().equals(payloadId));</span>
  }

  private String logBlockProposal(final Block block) {
<span class="nc" id="L294">    return &quot;block &quot;</span>
<span class="nc" id="L295">        + block.toLogString()</span>
        + &quot; gas used &quot;
<span class="nc" id="L297">        + block.getHeader().getGasUsed()</span>
        + &quot; transactions &quot;
<span class="nc" id="L299">        + block.getBody().getTransactions().size();</span>
  }

  @Override
  public boolean isPostMergeAtGenesis() {
<span class="fc" id="L304">    return this.isPostMergeAtGenesis;</span>
  }

  /**
   * Sets whether it is post merge at genesis
   *
   * @param isPostMergeAtGenesis the is post merge at genesis state
   * @return the post merge context
   */
  public PostMergeContext setPostMergeAtGenesis(final boolean isPostMergeAtGenesis) {
<span class="fc" id="L314">    this.isPostMergeAtGenesis = isPostMergeAtGenesis;</span>
<span class="fc" id="L315">    return this;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>