<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EthHash.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.mainnet</a> &gt; <span class="el_source">EthHash.java</span></div><h1>EthHash.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.mainnet;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.core.SealableBlockHeader;
import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;

import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.DigestException;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.function.BiConsumer;

import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.bouncycastle.jcajce.provider.digest.Keccak;

/** Implementation of EthHash. */
<span class="nc" id="L36">public final class EthHash {</span>

  public static final int HASH_BYTES = 64;

<span class="fc" id="L40">  public static final BigInteger TARGET_UPPER_BOUND = BigInteger.valueOf(2).pow(256);</span>

  public static final int EPOCH_LENGTH = 30000;

  private static final int DATASET_INIT_BYTES = 1 &lt;&lt; 30;

  private static final int DATASET_GROWTH_BYTES = 1 &lt;&lt; 23;

  private static final int CACHE_INIT_BYTES = 1 &lt;&lt; 24;

  private static final int CACHE_GROWTH_BYTES = 1 &lt;&lt; 17;

  private static final int MIX_BYTES = 128;

  private static final int HASH_WORDS = 16;

  private static final int CACHE_ROUNDS = 3;

  private static final int WORD_BYTES = 4;

  private static final int DATASET_PARENTS = 256;

  private static final int ACCESSES = 64;

<span class="fc" id="L64">  private static final ThreadLocal&lt;MessageDigest&gt; KECCAK_512 =</span>
<span class="fc" id="L65">      ThreadLocal.withInitial(Keccak.Digest512::new);</span>

  /**
   * Hashimoto Light Implementation.
   *
   * @param size Dataset size for the given header hash
   * @param cache EthHash Cache
   * @param header Truncated BlockHeader hash
   * @param nonce Nonce to use for hashing
   * @return A byte array holding MixHash in its first 32 bytes and the EthHash result in the in
   *     bytes 32 to 63
   */
  public static PoWSolution hashimotoLight(
      final long size, final int[] cache, final Bytes header, final long nonce) {
<span class="fc" id="L79">    return hashimoto(header, size, nonce, (target, ind) -&gt; calcDatasetItem(target, cache, ind));</span>
  }

  public static PoWSolution hashimoto(
      final Bytes header,
      final long size,
      final long nonce,
      final BiConsumer&lt;byte[], Integer&gt; datasetLookup) {
<span class="fc" id="L87">    final int n = (int) Long.divideUnsigned(size, MIX_BYTES);</span>
<span class="fc" id="L88">    final MessageDigest keccak512 = KECCAK_512.get();</span>
<span class="fc" id="L89">    keccak512.update(header.toArrayUnsafe());</span>
<span class="fc" id="L90">    keccak512.update(Longs.toByteArray(Long.reverseBytes(nonce)));</span>
<span class="fc" id="L91">    final byte[] seed = keccak512.digest();</span>
<span class="fc" id="L92">    final ByteBuffer mixBuffer = ByteBuffer.allocate(MIX_BYTES).order(ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">    for (int i = 0; i &lt; MIX_BYTES / HASH_BYTES; ++i) {</span>
<span class="fc" id="L94">      mixBuffer.put(seed);</span>
    }
<span class="fc" id="L96">    mixBuffer.position(0);</span>
<span class="fc" id="L97">    final int[] mix = new int[MIX_BYTES / 4];</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">    for (int i = 0; i &lt; MIX_BYTES / 4; ++i) {</span>
<span class="fc" id="L99">      mix[i] = mixBuffer.getInt();</span>
    }
<span class="fc" id="L101">    final byte[] lookupResult = new byte[HASH_BYTES];</span>
<span class="fc" id="L102">    final byte[] temp = new byte[MIX_BYTES];</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">    for (int i = 0; i &lt; ACCESSES; ++i) {</span>
<span class="fc" id="L104">      final int p =</span>
<span class="fc" id="L105">          Integer.remainderUnsigned(</span>
<span class="fc" id="L106">              fnv(i ^ readLittleEndianInt(seed, 0), mix[i % (MIX_BYTES / WORD_BYTES)]), n);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">      for (int j = 0; j &lt; MIX_BYTES / HASH_BYTES; ++j) {</span>
<span class="fc" id="L108">        datasetLookup.accept(lookupResult, 2 * p + j);</span>
<span class="fc" id="L109">        System.arraycopy(lookupResult, 0, temp, j * HASH_BYTES, HASH_BYTES);</span>
      }
<span class="fc" id="L111">      fnvHash(mix, temp);</span>
    }
<span class="fc" id="L113">    final int[] cmix = new int[mix.length / 4];</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">    for (int i = 0; i &lt; mix.length; i += 4) {</span>
<span class="fc" id="L115">      cmix[i / 4] = fnv(fnv(fnv(mix[i], mix[i + 1]), mix[i + 2]), mix[i + 3]);</span>
    }
<span class="fc" id="L117">    final byte[] result = new byte[32 + 32];</span>
<span class="fc" id="L118">    intToByte(result, cmix);</span>
<span class="fc" id="L119">    final MessageDigest keccak256 = DirectAcyclicGraphSeed.KECCAK_256.get();</span>
<span class="fc" id="L120">    keccak256.update(seed);</span>
<span class="fc" id="L121">    keccak256.update(result, 0, 32);</span>
    try {
<span class="fc" id="L123">      keccak256.digest(result, 32, 32);</span>
<span class="nc" id="L124">    } catch (final DigestException ex) {</span>
<span class="nc" id="L125">      throw new IllegalStateException(ex);</span>
<span class="fc" id="L126">    }</span>

<span class="fc" id="L128">    return new PoWSolution(</span>
        nonce,
<span class="fc" id="L130">        Hash.wrap(Bytes32.wrap(Arrays.copyOf(result, 32))),</span>
<span class="fc" id="L131">        Bytes32.wrap(result, 32),</span>
        header);
  }

  /**
   * Calculates a dataset item and writes it to a given buffer.
   *
   * @param buffer Buffer to store dataset item in
   * @param cache EthHash Cache
   * @param index Index of the dataset item to calculate
   */
  public static void calcDatasetItem(final byte[] buffer, final int[] cache, final int index) {
<span class="fc" id="L143">    final int rows = cache.length / HASH_WORDS;</span>
<span class="fc" id="L144">    final int[] mixInts = new int[HASH_BYTES / 4];</span>
<span class="fc" id="L145">    final int offset = index % rows * HASH_WORDS;</span>
<span class="fc" id="L146">    mixInts[0] = cache[offset] ^ index;</span>
<span class="fc" id="L147">    System.arraycopy(cache, offset + 1, mixInts, 1, HASH_WORDS - 1);</span>
<span class="fc" id="L148">    intToByte(buffer, mixInts);</span>
<span class="fc" id="L149">    final MessageDigest keccak512 = KECCAK_512.get();</span>
<span class="fc" id="L150">    keccak512.update(buffer);</span>
    try {
<span class="fc" id="L152">      keccak512.digest(buffer, 0, HASH_BYTES);</span>
<span class="fc" id="L153">      ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN).asIntBuffer().get(mixInts);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">      for (int i = 0; i &lt; DATASET_PARENTS; ++i) {</span>
<span class="fc" id="L155">        fnvHash(</span>
            mixInts,
            cache,
<span class="fc" id="L158">            Integer.remainderUnsigned(fnv(index ^ i, mixInts[i % 16]), rows) * HASH_WORDS);</span>
      }
<span class="fc" id="L160">      intToByte(buffer, mixInts);</span>
<span class="fc" id="L161">      keccak512.update(buffer);</span>
<span class="fc" id="L162">      keccak512.digest(buffer, 0, HASH_BYTES);</span>
<span class="nc" id="L163">    } catch (final DigestException ex) {</span>
<span class="nc" id="L164">      throw new IllegalStateException(ex);</span>
<span class="fc" id="L165">    }</span>
<span class="fc" id="L166">  }</span>

  /**
   * Hashes a BlockHeader without its nonce and MixHash.
   *
   * @param header Block Header
   * @return Truncated BlockHeader hash
   */
  public static Bytes32 hashHeader(final SealableBlockHeader header) {
<span class="fc" id="L175">    final BytesValueRLPOutput out = new BytesValueRLPOutput();</span>
<span class="fc" id="L176">    out.startList();</span>
<span class="fc" id="L177">    out.writeBytes(header.getParentHash());</span>
<span class="fc" id="L178">    out.writeBytes(header.getOmmersHash());</span>
<span class="fc" id="L179">    out.writeBytes(header.getCoinbase());</span>
<span class="fc" id="L180">    out.writeBytes(header.getStateRoot());</span>
<span class="fc" id="L181">    out.writeBytes(header.getTransactionsRoot());</span>
<span class="fc" id="L182">    out.writeBytes(header.getReceiptsRoot());</span>
<span class="fc" id="L183">    out.writeBytes(header.getLogsBloom());</span>
<span class="fc" id="L184">    out.writeUInt256Scalar(header.getDifficulty());</span>
<span class="fc" id="L185">    out.writeLongScalar(header.getNumber());</span>
<span class="fc" id="L186">    out.writeLongScalar(header.getGasLimit());</span>
<span class="fc" id="L187">    out.writeLongScalar(header.getGasUsed());</span>
<span class="fc" id="L188">    out.writeLongScalar(header.getTimestamp());</span>
<span class="fc" id="L189">    out.writeBytes(header.getExtraData());</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">    if (header.getBaseFee().isPresent()) {</span>
<span class="nc" id="L191">      out.writeUInt256Scalar(header.getBaseFee().get());</span>
    }
<span class="fc" id="L193">    out.endList();</span>
<span class="fc" id="L194">    return Bytes32.wrap(</span>
<span class="fc" id="L195">        DirectAcyclicGraphSeed.KECCAK_256.get().digest(out.encoded().toArrayUnsafe()));</span>
  }

  /**
   * Generates the EthHash cache for given parameters.
   *
   * @param cacheSize Size of the cache to generate
   * @param block Block Number to generate cache for
   * @param epochCalculator EpochCalculator used to determine current epoch length
   * @return EthHash Cache
   */
  public static int[] mkCache(
      final int cacheSize, final long block, final EpochCalculator epochCalculator) {
<span class="fc" id="L208">    final MessageDigest keccak512 = KECCAK_512.get();</span>
<span class="fc" id="L209">    keccak512.update(DirectAcyclicGraphSeed.dagSeed(block, epochCalculator));</span>
<span class="fc" id="L210">    final int rows = cacheSize / HASH_BYTES;</span>
<span class="fc" id="L211">    final byte[] cache = new byte[rows * HASH_BYTES];</span>
    try {
<span class="fc" id="L213">      keccak512.digest(cache, 0, HASH_BYTES);</span>
<span class="nc" id="L214">    } catch (final DigestException ex) {</span>
<span class="nc" id="L215">      throw new IllegalStateException(ex);</span>
<span class="fc" id="L216">    }</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">    for (int i = 1; i &lt; rows; ++i) {</span>
<span class="fc" id="L218">      keccak512.update(cache, (i - 1) * HASH_BYTES, HASH_BYTES);</span>
      try {
<span class="fc" id="L220">        keccak512.digest(cache, i * HASH_BYTES, HASH_BYTES);</span>
<span class="nc" id="L221">      } catch (final DigestException ex) {</span>
<span class="nc" id="L222">        throw new IllegalStateException(ex);</span>
<span class="fc" id="L223">      }</span>
    }
<span class="fc" id="L225">    final byte[] temp = new byte[HASH_BYTES];</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">    for (int i = 0; i &lt; CACHE_ROUNDS; ++i) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">      for (int j = 0; j &lt; rows; ++j) {</span>
<span class="fc" id="L228">        final int offset = j * HASH_BYTES;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (int k = 0; k &lt; HASH_BYTES; ++k) {</span>
<span class="fc" id="L230">          temp[k] =</span>
              (byte)
                  (cache[(j - 1 + rows) % rows * HASH_BYTES + k]
                      ^ cache[
<span class="fc" id="L234">                          Integer.remainderUnsigned(readLittleEndianInt(cache, offset), rows)</span>
                                  * HASH_BYTES
                              + k]);
        }
<span class="fc" id="L238">        keccak512.update(temp);</span>
        try {
<span class="fc" id="L240">          keccak512.digest(temp, 0, HASH_BYTES);</span>
<span class="nc" id="L241">        } catch (final DigestException ex) {</span>
<span class="nc" id="L242">          throw new IllegalStateException(ex);</span>
<span class="fc" id="L243">        }</span>
<span class="fc" id="L244">        System.arraycopy(temp, 0, cache, offset, HASH_BYTES);</span>
      }
    }
<span class="fc" id="L247">    final int[] result = new int[cache.length / 4];</span>
<span class="fc" id="L248">    ByteBuffer.wrap(cache).order(ByteOrder.LITTLE_ENDIAN).asIntBuffer().get(result);</span>
<span class="fc" id="L249">    return result;</span>
  }

  /**
   * Calculates EthHash Cache size at a given epoch.
   *
   * @param epoch EthHash Epoch
   * @return Cache size
   */
  public static long cacheSize(final long epoch) {
<span class="fc" id="L259">    long size = epoch * CACHE_GROWTH_BYTES + CACHE_INIT_BYTES - HASH_BYTES;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">    while (!isPrime(Long.divideUnsigned(size, HASH_BYTES))) {</span>
<span class="fc" id="L261">      size -= 2 * HASH_BYTES;</span>
    }
<span class="fc" id="L263">    return size;</span>
  }

  /**
   * Calculates EthHash DataSet size at a given epoch.
   *
   * @param epoch EthHash Epoch
   * @return DataSet size
   */
  public static long datasetSize(final long epoch) {
<span class="fc" id="L273">    long size = epoch * DATASET_GROWTH_BYTES + DATASET_INIT_BYTES - MIX_BYTES;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">    while (!isPrime(Long.divideUnsigned(size, MIX_BYTES))) {</span>
<span class="fc" id="L275">      size -= 2 * MIX_BYTES;</span>
    }
<span class="fc" id="L277">    return size;</span>
  }

  private static boolean isPrime(final long num) {
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">    if (num &gt; 2 &amp;&amp; (num &amp; 1) == 0) {</span>
<span class="nc" id="L282">      return false;</span>
    }
<span class="fc bfc" id="L284" title="All 2 branches covered.">    for (long i = 3; i * i &lt;= num; i += 2) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">      if (num % i == 0) {</span>
<span class="fc" id="L286">        return false;</span>
      }
    }
<span class="fc" id="L289">    return true;</span>
  }

  private static int readLittleEndianInt(final byte[] buffer, final int offset) {
<span class="fc" id="L293">    return Ints.fromBytes(</span>
        buffer[offset + 3], buffer[offset + 2], buffer[offset + 1], buffer[offset]);
  }

  private static void intToByte(final byte[] target, final int[] ints) {
<span class="fc" id="L298">    final ByteBuffer buffer = ByteBuffer.wrap(target).order(ByteOrder.LITTLE_ENDIAN);</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">    for (final int i : ints) {</span>
<span class="fc" id="L300">      buffer.putInt(i);</span>
    }
<span class="fc" id="L302">  }</span>

  private static void fnvHash(final int[] mix, final byte[] cache) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">    for (int i = 0; i &lt; mix.length; i++) {</span>
<span class="fc" id="L306">      mix[i] = fnv(mix[i], readLittleEndianInt(cache, i * Integer.BYTES));</span>
    }
<span class="fc" id="L308">  }</span>

  private static void fnvHash(final int[] mix, final int[] cache, final int offset) {
<span class="fc bfc" id="L311" title="All 2 branches covered.">    for (int i = 0; i &lt; mix.length; i++) {</span>
<span class="fc" id="L312">      mix[i] = fnv(mix[i], cache[offset + i]);</span>
    }
<span class="fc" id="L314">  }</span>

  private static int fnv(final int a, final int b) {
<span class="fc" id="L317">    return a * 0x01000193 ^ b;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>