<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VoteTally.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.common.validator.blockbased</a> &gt; <span class="el_source">VoteTally.java</span></div><h1>VoteTally.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.common.validator.blockbased;

import org.hyperledger.besu.consensus.common.validator.ValidatorVote;
import org.hyperledger.besu.datatypes.Address;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;

import com.google.common.collect.Maps;

/** Tracks the current list of validators and votes to add or drop validators. */
class VoteTally {

  private final NavigableSet&lt;Address&gt; currentValidators;

  private final Map&lt;Address, Set&lt;Address&gt;&gt; addVotesBySubject;
  private final Map&lt;Address, Set&lt;Address&gt;&gt; removeVotesBySubject;

  VoteTally(final Collection&lt;Address&gt; initialValidators) {
<span class="fc" id="L41">    this(new TreeSet&lt;&gt;(initialValidators), new HashMap&lt;&gt;(), new HashMap&lt;&gt;());</span>
<span class="fc" id="L42">  }</span>

  private VoteTally(
      final Collection&lt;Address&gt; initialValidators,
      final Map&lt;Address, Set&lt;Address&gt;&gt; addVotesBySubject,
<span class="fc" id="L47">      final Map&lt;Address, Set&lt;Address&gt;&gt; removeVotesBySubject) {</span>
<span class="fc" id="L48">    this.currentValidators = new TreeSet&lt;&gt;(initialValidators);</span>
<span class="fc" id="L49">    this.addVotesBySubject = addVotesBySubject;</span>
<span class="fc" id="L50">    this.removeVotesBySubject = removeVotesBySubject;</span>
<span class="fc" id="L51">  }</span>

  /**
   * Add a vote to the current tally. The current validator list will be updated if this vote takes
   * the tally past the required votes to approve the change.
   *
   * @param validatorVote The vote which was cast in a block header.
   */
  void addVote(final ValidatorVote validatorVote) {
<span class="fc" id="L60">    final Set&lt;Address&gt; addVotesForSubject =</span>
<span class="fc" id="L61">        addVotesBySubject.computeIfAbsent(validatorVote.getRecipient(), target -&gt; new HashSet&lt;&gt;());</span>
<span class="fc" id="L62">    final Set&lt;Address&gt; removeVotesForSubject =</span>
<span class="fc" id="L63">        removeVotesBySubject.computeIfAbsent(</span>
<span class="fc" id="L64">            validatorVote.getRecipient(), target -&gt; new HashSet&lt;&gt;());</span>

<span class="fc bfc" id="L66" title="All 2 branches covered.">    if (validatorVote.isAuthVote()) {</span>
<span class="fc" id="L67">      addVotesForSubject.add(validatorVote.getProposer());</span>
<span class="fc" id="L68">      removeVotesForSubject.remove(validatorVote.getProposer());</span>
    } else {
<span class="fc" id="L70">      removeVotesForSubject.add(validatorVote.getProposer());</span>
<span class="fc" id="L71">      addVotesForSubject.remove(validatorVote.getProposer());</span>
    }

<span class="fc" id="L74">    final int validatorLimit = validatorLimit();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (addVotesForSubject.size() &gt;= validatorLimit) {</span>
<span class="fc" id="L76">      currentValidators.add(validatorVote.getRecipient());</span>
<span class="fc" id="L77">      discardOutstandingVotesFor(validatorVote.getRecipient());</span>
    }
<span class="fc bfc" id="L79" title="All 2 branches covered.">    if (removeVotesForSubject.size() &gt;= validatorLimit) {</span>
<span class="fc" id="L80">      currentValidators.remove(validatorVote.getRecipient());</span>
<span class="fc" id="L81">      discardOutstandingVotesFor(validatorVote.getRecipient());</span>
<span class="fc" id="L82">      addVotesBySubject.values().forEach(votes -&gt; votes.remove(validatorVote.getRecipient()));</span>
<span class="fc" id="L83">      removeVotesBySubject.values().forEach(votes -&gt; votes.remove(validatorVote.getRecipient()));</span>
    }
<span class="fc" id="L85">  }</span>

  private void discardOutstandingVotesFor(final Address subject) {
<span class="fc" id="L88">    addVotesBySubject.remove(subject);</span>
<span class="fc" id="L89">    removeVotesBySubject.remove(subject);</span>
<span class="fc" id="L90">  }</span>

  Set&lt;Address&gt; getOutstandingAddVotesFor(final Address subject) {
<span class="fc" id="L93">    return Optional.ofNullable(addVotesBySubject.get(subject)).orElse(Collections.emptySet());</span>
  }

  Set&lt;Address&gt; getOutstandingRemoveVotesFor(final Address subject) {
<span class="fc" id="L97">    return Optional.ofNullable(removeVotesBySubject.get(subject)).orElse(Collections.emptySet());</span>
  }

  private int validatorLimit() {
<span class="fc" id="L101">    return (currentValidators.size() / 2) + 1;</span>
  }

  /**
   * Reset the outstanding vote tallies as required at each epoch. The current validator list is
   * unaffected.
   */
  void discardOutstandingVotes() {
<span class="fc" id="L109">    addVotesBySubject.clear();</span>
<span class="fc" id="L110">  }</span>

  /**
   * The validator addresses
   *
   * @return The collection of validators after the voting at the most recent block has been
   *     finalised.
   */
  Collection&lt;Address&gt; getValidators() {
<span class="fc" id="L119">    return currentValidators;</span>
  }

  VoteTally copy() {
<span class="fc" id="L123">    final Map&lt;Address, Set&lt;Address&gt;&gt; addVotesBySubject = Maps.newHashMap();</span>
<span class="fc" id="L124">    final Map&lt;Address, Set&lt;Address&gt;&gt; removeVotesBySubject = Maps.newHashMap();</span>

<span class="fc" id="L126">    this.addVotesBySubject.forEach(</span>
<span class="fc" id="L127">        (key, value) -&gt; addVotesBySubject.put(key, new TreeSet&lt;&gt;(value)));</span>
<span class="fc" id="L128">    this.removeVotesBySubject.forEach(</span>
<span class="fc" id="L129">        (key, value) -&gt; removeVotesBySubject.put(key, new TreeSet&lt;&gt;(value)));</span>

<span class="fc" id="L131">    return new VoteTally(</span>
        new TreeSet&lt;&gt;(this.currentValidators), addVotesBySubject, removeVotesBySubject);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>