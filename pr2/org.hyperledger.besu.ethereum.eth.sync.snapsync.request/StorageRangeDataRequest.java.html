<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StorageRangeDataRequest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.sync.snapsync.request</a> &gt; <span class="el_source">StorageRangeDataRequest.java</span></div><h1>StorageRangeDataRequest.java</h1><pre class="source lang-java linenums">/*
 * Copyright contributors to Hyperledger Besu
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.sync.snapsync.request;

import static org.hyperledger.besu.ethereum.eth.sync.snapsync.RequestType.STORAGE_RANGE;
import static org.hyperledger.besu.ethereum.eth.sync.snapsync.StackTrie.FlatDatabaseUpdater.noop;
import static org.hyperledger.besu.ethereum.trie.RangeManager.MAX_RANGE;
import static org.hyperledger.besu.ethereum.trie.RangeManager.MIN_RANGE;
import static org.hyperledger.besu.ethereum.trie.RangeManager.findNewBeginElementInRange;
import static org.hyperledger.besu.ethereum.trie.RangeManager.getRangeCount;
import static org.hyperledger.besu.ethereum.worldstate.WorldStateStorageCoordinator.applyForStrategy;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapSyncConfiguration;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapSyncProcessState;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.SnapWorldDownloadState;
import org.hyperledger.besu.ethereum.eth.sync.snapsync.StackTrie;
import org.hyperledger.besu.ethereum.proof.WorldStateProofProvider;
import org.hyperledger.besu.ethereum.trie.CompactEncoding;
import org.hyperledger.besu.ethereum.trie.NodeUpdater;
import org.hyperledger.besu.ethereum.trie.RangeManager;
import org.hyperledger.besu.ethereum.trie.diffbased.bonsai.storage.BonsaiWorldStateKeyValueStorage;
import org.hyperledger.besu.ethereum.worldstate.FlatDbMode;
import org.hyperledger.besu.ethereum.worldstate.WorldStateKeyValueStorage;
import org.hyperledger.besu.ethereum.worldstate.WorldStateStorageCoordinator;

import java.util.ArrayList;
import java.util.List;
import java.util.NavigableMap;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import kotlin.collections.ArrayDeque;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.apache.tuweni.rlp.RLP;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** Returns a list of storages and the merkle proofs of an entire range */
public class StorageRangeDataRequest extends SnapDataRequest {

<span class="fc" id="L58">  private static final Logger LOG = LoggerFactory.getLogger(StorageRangeDataRequest.class);</span>

  private final Hash accountHash;
  private final Bytes32 storageRoot;
  private final Bytes32 startKeyHash;
  private final Bytes32 endKeyHash;

  private final StackTrie stackTrie;
  private Optional&lt;Boolean&gt; isProofValid;

  protected StorageRangeDataRequest(
      final Hash rootHash,
      final Bytes32 accountHash,
      final Bytes32 storageRoot,
      final Bytes32 startKeyHash,
      final Bytes32 endKeyHash) {
<span class="fc" id="L74">    super(STORAGE_RANGE, rootHash);</span>
<span class="fc" id="L75">    this.accountHash = Hash.wrap(accountHash);</span>
<span class="fc" id="L76">    this.storageRoot = storageRoot;</span>
<span class="fc" id="L77">    this.startKeyHash = startKeyHash;</span>
<span class="fc" id="L78">    this.endKeyHash = endKeyHash;</span>
<span class="fc" id="L79">    this.isProofValid = Optional.empty();</span>
<span class="fc" id="L80">    this.stackTrie = new StackTrie(Hash.wrap(getStorageRoot()), startKeyHash);</span>
<span class="fc" id="L81">    LOG.trace(</span>
        &quot;create get storage range data request for account {} with root hash={} from {} to {}&quot;,
        accountHash,
        rootHash,
        startKeyHash,
        endKeyHash);
<span class="fc" id="L87">  }</span>

  @Override
  protected int doPersist(
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final WorldStateKeyValueStorage.Updater updater,
      final SnapWorldDownloadState downloadState,
      final SnapSyncProcessState snapSyncState,
      final SnapSyncConfiguration snapSyncConfiguration) {

    // search incomplete nodes in the range
<span class="fc" id="L98">    final AtomicInteger nbNodesSaved = new AtomicInteger();</span>
<span class="fc" id="L99">    final NodeUpdater nodeUpdater =</span>
        (location, hash, value) -&gt; {
<span class="fc" id="L101">          applyForStrategy(</span>
              updater,
<span class="fc" id="L103">              onBonsai -&gt; onBonsai.putAccountStorageTrieNode(accountHash, location, hash, value),</span>
<span class="nc" id="L104">              onForest -&gt; onForest.putAccountStorageTrieNode(hash, value));</span>
<span class="fc" id="L105">          nbNodesSaved.incrementAndGet();</span>
<span class="fc" id="L106">        };</span>

<span class="fc" id="L108">    final AtomicReference&lt;StackTrie.FlatDatabaseUpdater&gt; flatDatabaseUpdater =</span>
<span class="fc" id="L109">        new AtomicReference&lt;&gt;(noop());</span>

    // we have a flat DB only with Bonsai
<span class="fc" id="L112">    worldStateStorageCoordinator.applyOnMatchingFlatMode(</span>
        FlatDbMode.FULL,
        bonsaiWorldStateStorageStrategy -&gt; {
<span class="nc" id="L115">          flatDatabaseUpdater.set(</span>
              (key, value) -&gt;
<span class="nc" id="L117">                  ((BonsaiWorldStateKeyValueStorage.Updater) updater)</span>
<span class="nc" id="L118">                      .putStorageValueBySlotHash(</span>
<span class="nc" id="L119">                          accountHash, Hash.wrap(key), Bytes32.leftPad(RLP.decodeValue(value))));</span>
<span class="nc" id="L120">        });</span>

<span class="fc" id="L122">    stackTrie.commit(flatDatabaseUpdater.get(), nodeUpdater);</span>

<span class="fc" id="L124">    downloadState.getMetricsManager().notifySlotsDownloaded(stackTrie.getElementsCount().get());</span>

<span class="fc" id="L126">    return nbNodesSaved.get();</span>
  }

  public void addResponse(
      final SnapWorldDownloadState downloadState,
      final WorldStateProofProvider worldStateProofProvider,
      final NavigableMap&lt;Bytes32, Bytes&gt; slots,
      final ArrayDeque&lt;Bytes&gt; proofs) {
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">    if (!slots.isEmpty() || !proofs.isEmpty()) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">      if (!worldStateProofProvider.isValidRangeProof(</span>
          startKeyHash, endKeyHash, storageRoot, proofs, slots)) {
        // If the proof is invalid, it means that the storage will be a mix of several blocks.
        // Therefore, it will be necessary to heal the account's storage subsequently
<span class="fc" id="L139">        LOG.atDebug()</span>
<span class="fc" id="L140">            .setMessage(&quot;invalid storage range proof received for account hash {} range {} {}&quot;)</span>
<span class="pc" id="L141">            .addArgument(() -&gt; accountHash)</span>
<span class="pc bnc" id="L142" title="All 2 branches missed.">            .addArgument(() -&gt; slots.isEmpty() ? &quot;none&quot; : slots.firstKey())</span>
<span class="pc bnc" id="L143" title="All 2 branches missed.">            .addArgument(() -&gt; slots.isEmpty() ? &quot;none&quot; : slots.lastKey())</span>
<span class="fc" id="L144">            .log();</span>

<span class="fc" id="L146">        downloadState.addAccountToHealingList(CompactEncoding.bytesToPath(accountHash));</span>
        // We will request the new storage root of the account because it is apparently no longer
        // valid with the new pivot block.
<span class="fc" id="L149">        downloadState.enqueueRequest(</span>
<span class="fc" id="L150">            createAccountDataRequest(</span>
<span class="fc" id="L151">                getRootHash(), Hash.wrap(accountHash), startKeyHash, endKeyHash));</span>
<span class="fc" id="L152">        isProofValid = Optional.of(false);</span>
      } else {
<span class="fc" id="L154">        stackTrie.addElement(startKeyHash, proofs, slots);</span>
<span class="fc" id="L155">        isProofValid = Optional.of(true);</span>
      }
    }
<span class="fc" id="L158">  }</span>

  @Override
  public boolean isResponseReceived() {
<span class="fc" id="L162">    return isProofValid.isPresent();</span>
  }

  @Override
  public boolean isExpired(final SnapSyncProcessState snapSyncState) {
<span class="nc" id="L167">    return snapSyncState.isExpired(this);</span>
  }

  @Override
  public Stream&lt;SnapDataRequest&gt; getChildRequests(
      final SnapWorldDownloadState downloadState,
      final WorldStateStorageCoordinator worldStateStorageCoordinator,
      final SnapSyncProcessState snapSyncState) {
<span class="fc" id="L175">    final List&lt;SnapDataRequest&gt; childRequests = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    if (!isProofValid.orElse(false)) {</span>
<span class="nc" id="L178">      return Stream.empty();</span>
    }

<span class="fc" id="L181">    final StackTrie.TaskElement taskElement = stackTrie.getElement(startKeyHash);</span>

<span class="fc" id="L183">    findNewBeginElementInRange(storageRoot, taskElement.proofs(), taskElement.keys(), endKeyHash)</span>
<span class="fc" id="L184">        .ifPresent(</span>
            missingRightElement -&gt; {
<span class="fc" id="L186">              final int nbRanges = getRangeCount(startKeyHash, endKeyHash, taskElement.keys());</span>
<span class="fc" id="L187">              RangeManager.generateRanges(missingRightElement, endKeyHash, nbRanges)</span>
<span class="fc" id="L188">                  .forEach(</span>
                      (key, value) -&gt; {
<span class="fc" id="L190">                        final StorageRangeDataRequest storageRangeDataRequest =</span>
<span class="fc" id="L191">                            createStorageRangeDataRequest(</span>
<span class="fc" id="L192">                                getRootHash(), accountHash, storageRoot, key, value);</span>
<span class="fc" id="L193">                        childRequests.add(storageRangeDataRequest);</span>
<span class="fc" id="L194">                      });</span>
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">              if (startKeyHash.equals(MIN_RANGE) &amp;&amp; endKeyHash.equals(MAX_RANGE)) {</span>
                // need to heal this account storage
<span class="fc" id="L197">                downloadState.addAccountToHealingList(CompactEncoding.bytesToPath(accountHash));</span>
              }
<span class="fc" id="L199">            });</span>

<span class="fc" id="L201">    return childRequests.stream();</span>
  }

  public Bytes32 getAccountHash() {
<span class="fc" id="L205">    return accountHash;</span>
  }

  public Bytes32 getStorageRoot() {
<span class="fc" id="L209">    return storageRoot;</span>
  }

  public NavigableMap&lt;Bytes32, Bytes&gt; getSlots() {
<span class="fc" id="L213">    return stackTrie.getElement(startKeyHash).keys();</span>
  }

  public Bytes32 getStartKeyHash() {
<span class="nc" id="L217">    return startKeyHash;</span>
  }

  public Bytes32 getEndKeyHash() {
<span class="nc" id="L221">    return endKeyHash;</span>
  }

  @Override
  public void clear() {
<span class="nc" id="L226">    this.isProofValid = Optional.of(false);</span>
<span class="nc" id="L227">    this.stackTrie.removeElement(startKeyHash);</span>
<span class="nc" id="L228">  }</span>

  @VisibleForTesting
  public void setProofValid(final boolean isProofValid) {
<span class="fc" id="L232">    this.isProofValid = Optional.of(isProofValid);</span>
<span class="fc" id="L233">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>