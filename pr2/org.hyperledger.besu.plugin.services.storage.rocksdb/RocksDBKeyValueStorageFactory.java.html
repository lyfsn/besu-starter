<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RocksDBKeyValueStorageFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.plugin.services.storage.rocksdb</a> &gt; <span class="el_source">RocksDBKeyValueStorageFactory.java</span></div><h1>RocksDBKeyValueStorageFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.plugin.services.storage.rocksdb;

import static org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat.BONSAI_WITH_RECEIPT_COMPACTION;
import static org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat.BONSAI_WITH_VARIABLES;
import static org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat.FOREST_WITH_RECEIPT_COMPACTION;
import static org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat.FOREST_WITH_VARIABLES;

import org.hyperledger.besu.plugin.services.BesuConfiguration;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.exception.StorageException;
import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.KeyValueStorageFactory;
import org.hyperledger.besu.plugin.services.storage.SegmentIdentifier;
import org.hyperledger.besu.plugin.services.storage.SegmentedKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.DatabaseMetadata;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBConfiguration;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBConfigurationBuilder;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBFactoryConfiguration;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.VersionedStorageFormat;
import org.hyperledger.besu.plugin.services.storage.rocksdb.segmented.OptimisticRocksDBColumnarKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.segmented.RocksDBColumnarKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.segmented.TransactionDBRocksDBColumnarKeyValueStorage;
import org.hyperledger.besu.services.kvstore.SegmentedKeyValueStorageAdapter;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.EnumSet;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Rocks db key value storage factory creates segmented storage and uses a adapter to support
 * unsegmented keyvalue storage.
 */
public class RocksDBKeyValueStorageFactory implements KeyValueStorageFactory {

<span class="fc" id="L58">  private static final Logger LOG = LoggerFactory.getLogger(RocksDBKeyValueStorageFactory.class);</span>
<span class="fc" id="L59">  private static final EnumSet&lt;BaseVersionedStorageFormat&gt; SUPPORTED_VERSIONED_FORMATS =</span>
<span class="fc" id="L60">      EnumSet.of(</span>
          FOREST_WITH_VARIABLES,
          FOREST_WITH_RECEIPT_COMPACTION,
          BONSAI_WITH_VARIABLES,
          BONSAI_WITH_RECEIPT_COMPACTION);
  private static final String NAME = &quot;rocksdb&quot;;
  private final RocksDBMetricsFactory rocksDBMetricsFactory;
  private DatabaseMetadata databaseMetadata;
  private RocksDBColumnarKeyValueStorage segmentedStorage;
  private RocksDBConfiguration rocksDBConfiguration;

  private final Supplier&lt;RocksDBFactoryConfiguration&gt; configuration;
  private final List&lt;SegmentIdentifier&gt; configuredSegments;
  private final List&lt;SegmentIdentifier&gt; ignorableSegments;

  /**
   * Instantiates a new RocksDb key value storage factory.
   *
   * @param configuration the configuration
   * @param configuredSegments the segments
   * @param ignorableSegments the ignorable segments
   * @param rocksDBMetricsFactory the rocks db metrics factory
   */
  public RocksDBKeyValueStorageFactory(
      final Supplier&lt;RocksDBFactoryConfiguration&gt; configuration,
      final List&lt;SegmentIdentifier&gt; configuredSegments,
      final List&lt;SegmentIdentifier&gt; ignorableSegments,
<span class="fc" id="L87">      final RocksDBMetricsFactory rocksDBMetricsFactory) {</span>
<span class="fc" id="L88">    this.configuration = configuration;</span>
<span class="fc" id="L89">    this.configuredSegments = configuredSegments;</span>
<span class="fc" id="L90">    this.ignorableSegments = ignorableSegments;</span>
<span class="fc" id="L91">    this.rocksDBMetricsFactory = rocksDBMetricsFactory;</span>
<span class="fc" id="L92">  }</span>

  /**
   * Instantiates a new RocksDb key value storage factory.
   *
   * @param configuration the configuration
   * @param configuredSegments the segments
   * @param rocksDBMetricsFactory the rocks db metrics factory
   */
  public RocksDBKeyValueStorageFactory(
      final Supplier&lt;RocksDBFactoryConfiguration&gt; configuration,
      final List&lt;SegmentIdentifier&gt; configuredSegments,
      final RocksDBMetricsFactory rocksDBMetricsFactory) {
<span class="fc" id="L105">    this(configuration, configuredSegments, List.of(), rocksDBMetricsFactory);</span>
<span class="fc" id="L106">  }</span>

  @Override
  public String getName() {
<span class="nc" id="L110">    return NAME;</span>
  }

  @Override
  public KeyValueStorage create(
      final SegmentIdentifier segment,
      final BesuConfiguration commonConfiguration,
      final MetricsSystem metricsSystem)
      throws StorageException {
<span class="fc" id="L119">    return new SegmentedKeyValueStorageAdapter(</span>
<span class="fc" id="L120">        segment, create(List.of(segment), commonConfiguration, metricsSystem));</span>
  }

  @Override
  public SegmentedKeyValueStorage create(
      final List&lt;SegmentIdentifier&gt; segments,
      final BesuConfiguration commonConfiguration,
      final MetricsSystem metricsSystem)
      throws StorageException {
<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (requiresInit()) {</span>
<span class="fc" id="L130">      init(commonConfiguration);</span>
    }

    // safety check to see that segments all exist within configured segments
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    if (!configuredSegments.containsAll(segments)) {</span>
<span class="nc" id="L135">      throw new StorageException(</span>
          &quot;Attempted to create storage for segments that are not configured: &quot;
<span class="nc" id="L137">              + segments.stream()</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                  .filter(segment -&gt; !configuredSegments.contains(segment))</span>
<span class="nc" id="L139">                  .map(SegmentIdentifier::toString)</span>
<span class="nc" id="L140">                  .collect(Collectors.joining(&quot;, &quot;)));</span>
    }

<span class="fc bfc" id="L143" title="All 2 branches covered.">    if (segmentedStorage == null) {</span>
<span class="fc" id="L144">      final List&lt;SegmentIdentifier&gt; segmentsForFormat =</span>
<span class="fc" id="L145">          configuredSegments.stream()</span>
<span class="fc" id="L146">              .filter(</span>
                  segmentId -&gt;
<span class="fc" id="L148">                      segmentId.includeInDatabaseFormat(</span>
<span class="fc" id="L149">                          databaseMetadata.getVersionedStorageFormat().getFormat()))</span>
<span class="fc" id="L150">              .toList();</span>

      // It's probably a good idea for the creation logic to be entirely dependent on the database
      // version. Introducing intermediate booleans that represent database properties and
      // dispatching
      // creation logic based on them is error-prone.
<span class="pc bpc" id="L156" title="1 of 3 branches missed.">      switch (databaseMetadata.getVersionedStorageFormat().getFormat()) {</span>
        case FOREST -&gt; {
<span class="fc" id="L158">          LOG.debug(&quot;FOREST mode detected, using TransactionDB.&quot;);</span>
<span class="fc" id="L159">          segmentedStorage =</span>
              new TransactionDBRocksDBColumnarKeyValueStorage(
                  rocksDBConfiguration,
                  segmentsForFormat,
                  ignorableSegments,
                  metricsSystem,
                  rocksDBMetricsFactory);
<span class="fc" id="L166">        }</span>
        case BONSAI -&gt; {
<span class="fc" id="L168">          LOG.debug(&quot;BONSAI mode detected, Using OptimisticTransactionDB.&quot;);</span>
<span class="fc" id="L169">          segmentedStorage =</span>
              new OptimisticRocksDBColumnarKeyValueStorage(
                  rocksDBConfiguration,
                  segmentsForFormat,
                  ignorableSegments,
                  metricsSystem,
                  rocksDBMetricsFactory);
        }
      }
    }
<span class="fc" id="L179">    return segmentedStorage;</span>
  }

  /**
   * Storage path.
   *
   * @param commonConfiguration the common configuration
   * @return the path
   */
  protected Path storagePath(final BesuConfiguration commonConfiguration) {
<span class="fc" id="L189">    return commonConfiguration.getStoragePath();</span>
  }

  private void init(final BesuConfiguration commonConfiguration) {
    try {
<span class="fc" id="L194">      databaseMetadata = readDatabaseMetadata(commonConfiguration);</span>
<span class="nc" id="L195">    } catch (final IOException e) {</span>
<span class="nc" id="L196">      final String message =</span>
          &quot;Failed to retrieve the RocksDB database meta version: &quot;
<span class="nc" id="L198">              + e.getMessage()</span>
              + &quot; could not be found. You may not have the appropriate permission to access the item.&quot;;
<span class="nc" id="L200">      throw new StorageException(message, e);</span>
<span class="fc" id="L201">    }</span>
<span class="fc" id="L202">    rocksDBConfiguration =</span>
<span class="fc" id="L203">        RocksDBConfigurationBuilder.from(configuration.get())</span>
<span class="fc" id="L204">            .databaseDir(storagePath(commonConfiguration))</span>
<span class="fc" id="L205">            .build();</span>
<span class="fc" id="L206">  }</span>

  private boolean requiresInit() {
<span class="fc bfc" id="L209" title="All 2 branches covered.">    return segmentedStorage == null;</span>
  }

  private DatabaseMetadata readDatabaseMetadata(final BesuConfiguration commonConfiguration)
      throws IOException {
<span class="fc" id="L214">    final Path dataDir = commonConfiguration.getDataPath();</span>
<span class="fc" id="L215">    final boolean dataDirExists = dataDir.toFile().exists();</span>
<span class="fc" id="L216">    final boolean databaseExists = commonConfiguration.getStoragePath().toFile().exists();</span>
<span class="fc" id="L217">    final boolean metadataExists = DatabaseMetadata.isPresent(dataDir);</span>
    DatabaseMetadata metadata;
<span class="fc bfc" id="L219" title="All 4 branches covered.">    if (databaseExists &amp;&amp; !metadataExists) {</span>
<span class="fc" id="L220">      throw new StorageException(</span>
          &quot;Database exists but metadata file not found, without it there is no safe way to open the database&quot;);
    }
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (metadataExists) {</span>
<span class="fc" id="L224">      metadata = DatabaseMetadata.lookUpFrom(dataDir);</span>

<span class="fc" id="L226">      if (!metadata</span>
<span class="fc" id="L227">          .getVersionedStorageFormat()</span>
<span class="fc" id="L228">          .getFormat()</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">          .equals(commonConfiguration.getDataStorageConfiguration().getDatabaseFormat())) {</span>
<span class="nc" id="L230">        handleFormatMismatch(commonConfiguration, dataDir, metadata);</span>
      }

<span class="fc" id="L233">      final var runtimeVersion =</span>
<span class="fc" id="L234">          BaseVersionedStorageFormat.defaultForNewDB(</span>
<span class="fc" id="L235">              commonConfiguration.getDataStorageConfiguration());</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">      if (metadata.getVersionedStorageFormat().getVersion() &gt; runtimeVersion.getVersion()) {</span>
<span class="nc" id="L238">        final var maybeDowngradedMetadata =</span>
<span class="nc" id="L239">            handleVersionDowngrade(dataDir, metadata, runtimeVersion);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (maybeDowngradedMetadata.isPresent()) {</span>
<span class="nc" id="L241">          metadata = maybeDowngradedMetadata.get();</span>
<span class="nc" id="L242">          metadata.writeToDirectory(dataDir);</span>
        }
      }

<span class="fc bfc" id="L246" title="All 2 branches covered.">      if (metadata.getVersionedStorageFormat().getVersion() &lt; runtimeVersion.getVersion()) {</span>
<span class="nc" id="L247">        final var maybeUpgradedMetadata = handleVersionUpgrade(dataDir, metadata, runtimeVersion);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (maybeUpgradedMetadata.isPresent()) {</span>
<span class="nc" id="L249">          metadata = maybeUpgradedMetadata.get();</span>
<span class="nc" id="L250">          metadata.writeToDirectory(dataDir);</span>
        }
      }

<span class="fc" id="L254">      LOG.info(&quot;Existing database at {}. Metadata {}. Processing WAL...&quot;, dataDir, metadata);</span>
<span class="fc" id="L255">    } else {</span>

<span class="fc" id="L257">      metadata = DatabaseMetadata.defaultForNewDb(commonConfiguration);</span>
<span class="fc" id="L258">      LOG.info(</span>
          &quot;No existing database at {}. Using default metadata for new db {}&quot;, dataDir, metadata);
<span class="fc bfc" id="L260" title="All 2 branches covered.">      if (!dataDirExists) {</span>
<span class="fc" id="L261">        Files.createDirectories(dataDir);</span>
      }
<span class="fc" id="L263">      metadata.writeToDirectory(dataDir);</span>
    }

<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (!isSupportedVersionedFormat(metadata.getVersionedStorageFormat())) {</span>
<span class="nc" id="L267">      final String message = &quot;Unsupported RocksDB metadata: &quot; + metadata;</span>
<span class="nc" id="L268">      LOG.error(message);</span>
<span class="nc" id="L269">      throw new StorageException(message);</span>
    }

<span class="fc" id="L272">    return metadata;</span>
  }

  private static void handleFormatMismatch(
      final BesuConfiguration commonConfiguration,
      final Path dataDir,
      final DatabaseMetadata existingMetadata) {
<span class="fc" id="L279">    String error =</span>
<span class="fc" id="L280">        String.format(</span>
            &quot;Database format mismatch: DB at %s is %s but config expects %s. &quot;
                + &quot;Please check your config.&quot;,
            dataDir,
<span class="fc" id="L284">            existingMetadata.getVersionedStorageFormat().getFormat().name(),</span>
<span class="fc" id="L285">            commonConfiguration.getDataStorageConfiguration().getDatabaseFormat());</span>

<span class="fc" id="L287">    throw new StorageException(error);</span>
  }

  private Optional&lt;DatabaseMetadata&gt; handleVersionDowngrade(
      final Path dataDir,
      final DatabaseMetadata existingMetadata,
      final BaseVersionedStorageFormat runtimeVersion) {
    // here we put the code, or the messages, to perform an automated, or manual, downgrade of the
    // database, if supported, otherwise we just prevent Besu from starting since it will not
    // recognize the newer version.
    // In case we do an automated downgrade, then we also need to update the metadata on disk to
    // reflect the change to the runtime version, and return it.

    // Besu supports both formats of receipts so no downgrade is needed
<span class="nc bnc" id="L301" title="All 4 branches missed.">    if (runtimeVersion == BONSAI_WITH_VARIABLES || runtimeVersion == FOREST_WITH_VARIABLES) {</span>
<span class="nc" id="L302">      LOG.warn(</span>
          &quot;Database contains compacted receipts but receipt compaction is not enabled, new receipts  will &quot;
              + &quot;be not stored in the compacted format. If you want to remove compacted receipts from the &quot;
              + &quot;database it is necessary to resync Besu. Besu can support both compacted and non-compacted receipts.&quot;);
<span class="nc" id="L306">      return Optional.empty();</span>
    }

    // for the moment there are supported automated downgrades, so we just fail.
<span class="nc" id="L310">    String error =</span>
<span class="nc" id="L311">        String.format(</span>
            &quot;Database unsafe downgrade detect: DB at %s is %s with version %s but version %s is expected. &quot;
                + &quot;Please check your config and review release notes for supported downgrade procedures.&quot;,
            dataDir,
<span class="nc" id="L315">            existingMetadata.getVersionedStorageFormat().getFormat().name(),</span>
<span class="nc" id="L316">            existingMetadata.getVersionedStorageFormat().getVersion(),</span>
<span class="nc" id="L317">            runtimeVersion.getVersion());</span>

<span class="nc" id="L319">    throw new StorageException(error);</span>
  }

  private Optional&lt;DatabaseMetadata&gt; handleVersionUpgrade(
      final Path dataDir,
      final DatabaseMetadata existingMetadata,
      final BaseVersionedStorageFormat runtimeVersion) {
    // here we put the code, or the messages, to perform an automated, or manual, upgrade of the
    // database.
    // In case we do an automated upgrade, then we also need to update the metadata on disk to
    // reflect the change to the runtime version, and return it.

    // Besu supports both formats of receipts so no upgrade is needed other than updating metadata
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">    if (runtimeVersion == BONSAI_WITH_RECEIPT_COMPACTION</span>
        || runtimeVersion == FOREST_WITH_RECEIPT_COMPACTION) {
<span class="nc" id="L334">      final DatabaseMetadata metadata = new DatabaseMetadata(runtimeVersion);</span>
      try {
<span class="nc" id="L336">        metadata.writeToDirectory(dataDir);</span>
<span class="nc" id="L337">        return Optional.of(metadata);</span>
<span class="nc" id="L338">      } catch (IOException e) {</span>
<span class="nc" id="L339">        throw new StorageException(&quot;Database upgrade to use receipt compaction failed&quot;, e);</span>
      }
    }

    // for the moment there are no planned automated upgrades, so we just fail.
<span class="fc" id="L344">    String error =</span>
<span class="fc" id="L345">        String.format(</span>
            &quot;Database unsafe downgrade detect: DB at %s is %s with version %s but version %s is expected. &quot;
                + &quot;Please check your config and review release notes for supported downgrade procedures.&quot;,
            dataDir,
<span class="fc" id="L349">            existingMetadata.getVersionedStorageFormat().getFormat().name(),</span>
<span class="fc" id="L350">            existingMetadata.getVersionedStorageFormat().getVersion(),</span>
<span class="fc" id="L351">            runtimeVersion.getVersion());</span>

<span class="fc" id="L353">    throw new StorageException(error);</span>
  }

  private boolean isSupportedVersionedFormat(final VersionedStorageFormat versionedStorageFormat) {
<span class="fc" id="L357">    return SUPPORTED_VERSIONED_FORMATS.stream()</span>
<span class="fc" id="L358">        .anyMatch(</span>
            vsf -&gt;
<span class="fc bfc" id="L360" title="All 2 branches covered.">                vsf.getFormat().equals(versionedStorageFormat.getFormat())</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                    &amp;&amp; vsf.getVersion() == versionedStorageFormat.getVersion());</span>
  }

  @Override
  public void close() throws IOException {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">    if (segmentedStorage != null) {</span>
<span class="fc" id="L367">      segmentedStorage.close();</span>
    }
<span class="fc" id="L369">  }</span>

  @Override
  public boolean isSegmentIsolationSupported() {
<span class="fc" id="L373">    return true;</span>
  }

  @Override
  public boolean isSnapshotIsolationSupported() {
<span class="nc" id="L378">    return true;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>