<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RocksDBKeyValueStorageFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.plugin.services.storage.rocksdb</a> &gt; <span class="el_source">RocksDBKeyValueStorageFactory.java</span></div><h1>RocksDBKeyValueStorageFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.plugin.services.storage.rocksdb;

import static org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat.BONSAI_WITH_VARIABLES;
import static org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat.FOREST_WITH_VARIABLES;

import org.hyperledger.besu.plugin.services.BesuConfiguration;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.exception.StorageException;
import org.hyperledger.besu.plugin.services.storage.KeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.KeyValueStorageFactory;
import org.hyperledger.besu.plugin.services.storage.SegmentIdentifier;
import org.hyperledger.besu.plugin.services.storage.SegmentedKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.BaseVersionedStorageFormat;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.DatabaseMetadata;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBConfiguration;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBConfigurationBuilder;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.RocksDBFactoryConfiguration;
import org.hyperledger.besu.plugin.services.storage.rocksdb.configuration.VersionedStorageFormat;
import org.hyperledger.besu.plugin.services.storage.rocksdb.segmented.OptimisticRocksDBColumnarKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.segmented.RocksDBColumnarKeyValueStorage;
import org.hyperledger.besu.plugin.services.storage.rocksdb.segmented.TransactionDBRocksDBColumnarKeyValueStorage;
import org.hyperledger.besu.services.kvstore.SegmentedKeyValueStorageAdapter;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.EnumSet;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Rocks db key value storage factory creates segmented storage and uses a adapter to support
 * unsegmented keyvalue storage.
 */
public class RocksDBKeyValueStorageFactory implements KeyValueStorageFactory {

<span class="fc" id="L56">  private static final Logger LOG = LoggerFactory.getLogger(RocksDBKeyValueStorageFactory.class);</span>
<span class="fc" id="L57">  private static final EnumSet&lt;BaseVersionedStorageFormat&gt; SUPPORTED_VERSIONED_FORMATS =</span>
<span class="fc" id="L58">      EnumSet.of(FOREST_WITH_VARIABLES, BONSAI_WITH_VARIABLES);</span>
  private static final String NAME = &quot;rocksdb&quot;;
  private final RocksDBMetricsFactory rocksDBMetricsFactory;
  private DatabaseMetadata databaseMetadata;
  private RocksDBColumnarKeyValueStorage segmentedStorage;
  private RocksDBConfiguration rocksDBConfiguration;

  private final Supplier&lt;RocksDBFactoryConfiguration&gt; configuration;
  private final List&lt;SegmentIdentifier&gt; configuredSegments;
  private final List&lt;SegmentIdentifier&gt; ignorableSegments;

  /**
   * Instantiates a new RocksDb key value storage factory.
   *
   * @param configuration the configuration
   * @param configuredSegments the segments
   * @param ignorableSegments the ignorable segments
   * @param rocksDBMetricsFactory the rocks db metrics factory
   */
  public RocksDBKeyValueStorageFactory(
      final Supplier&lt;RocksDBFactoryConfiguration&gt; configuration,
      final List&lt;SegmentIdentifier&gt; configuredSegments,
      final List&lt;SegmentIdentifier&gt; ignorableSegments,
<span class="fc" id="L81">      final RocksDBMetricsFactory rocksDBMetricsFactory) {</span>
<span class="fc" id="L82">    this.configuration = configuration;</span>
<span class="fc" id="L83">    this.configuredSegments = configuredSegments;</span>
<span class="fc" id="L84">    this.ignorableSegments = ignorableSegments;</span>
<span class="fc" id="L85">    this.rocksDBMetricsFactory = rocksDBMetricsFactory;</span>
<span class="fc" id="L86">  }</span>

  /**
   * Instantiates a new RocksDb key value storage factory.
   *
   * @param configuration the configuration
   * @param configuredSegments the segments
   * @param rocksDBMetricsFactory the rocks db metrics factory
   */
  public RocksDBKeyValueStorageFactory(
      final Supplier&lt;RocksDBFactoryConfiguration&gt; configuration,
      final List&lt;SegmentIdentifier&gt; configuredSegments,
      final RocksDBMetricsFactory rocksDBMetricsFactory) {
<span class="fc" id="L99">    this(configuration, configuredSegments, List.of(), rocksDBMetricsFactory);</span>
<span class="fc" id="L100">  }</span>

  @Override
  public String getName() {
<span class="fc" id="L104">    return NAME;</span>
  }

  @Override
  public KeyValueStorage create(
      final SegmentIdentifier segment,
      final BesuConfiguration commonConfiguration,
      final MetricsSystem metricsSystem)
      throws StorageException {
<span class="fc" id="L113">    return new SegmentedKeyValueStorageAdapter(</span>
<span class="fc" id="L114">        segment, create(List.of(segment), commonConfiguration, metricsSystem));</span>
  }

  @Override
  public SegmentedKeyValueStorage create(
      final List&lt;SegmentIdentifier&gt; segments,
      final BesuConfiguration commonConfiguration,
      final MetricsSystem metricsSystem)
      throws StorageException {
<span class="fc bfc" id="L123" title="All 2 branches covered.">    if (requiresInit()) {</span>
<span class="fc" id="L124">      init(commonConfiguration);</span>
    }

    // safety check to see that segments all exist within configured segments
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">    if (!configuredSegments.containsAll(segments)) {</span>
<span class="nc" id="L129">      throw new StorageException(</span>
          &quot;Attempted to create storage for segments that are not configured: &quot;
<span class="nc" id="L131">              + segments.stream()</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                  .filter(segment -&gt; !configuredSegments.contains(segment))</span>
<span class="nc" id="L133">                  .map(SegmentIdentifier::toString)</span>
<span class="nc" id="L134">                  .collect(Collectors.joining(&quot;, &quot;)));</span>
    }

<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (segmentedStorage == null) {</span>
<span class="fc" id="L138">      final List&lt;SegmentIdentifier&gt; segmentsForFormat =</span>
<span class="fc" id="L139">          configuredSegments.stream()</span>
<span class="fc" id="L140">              .filter(</span>
                  segmentId -&gt;
<span class="fc" id="L142">                      segmentId.includeInDatabaseFormat(</span>
<span class="fc" id="L143">                          databaseMetadata.getVersionedStorageFormat().getFormat()))</span>
<span class="fc" id="L144">              .toList();</span>

      // It's probably a good idea for the creation logic to be entirely dependent on the database
      // version. Introducing intermediate booleans that represent database properties and
      // dispatching
      // creation logic based on them is error-prone.
<span class="pc bpc" id="L150" title="1 of 3 branches missed.">      switch (databaseMetadata.getVersionedStorageFormat().getFormat()) {</span>
        case FOREST -&gt; {
<span class="fc" id="L152">          LOG.debug(&quot;FOREST mode detected, using TransactionDB.&quot;);</span>
<span class="fc" id="L153">          segmentedStorage =</span>
              new TransactionDBRocksDBColumnarKeyValueStorage(
                  rocksDBConfiguration,
                  segmentsForFormat,
                  ignorableSegments,
                  metricsSystem,
                  rocksDBMetricsFactory);
<span class="fc" id="L160">        }</span>
        case BONSAI -&gt; {
<span class="fc" id="L162">          LOG.debug(&quot;BONSAI mode detected, Using OptimisticTransactionDB.&quot;);</span>
<span class="fc" id="L163">          segmentedStorage =</span>
              new OptimisticRocksDBColumnarKeyValueStorage(
                  rocksDBConfiguration,
                  segmentsForFormat,
                  ignorableSegments,
                  metricsSystem,
                  rocksDBMetricsFactory);
        }
      }
    }
<span class="fc" id="L173">    return segmentedStorage;</span>
  }

  /**
   * Storage path.
   *
   * @param commonConfiguration the common configuration
   * @return the path
   */
  protected Path storagePath(final BesuConfiguration commonConfiguration) {
<span class="fc" id="L183">    return commonConfiguration.getStoragePath();</span>
  }

  private void init(final BesuConfiguration commonConfiguration) {
    try {
<span class="fc" id="L188">      databaseMetadata = readDatabaseMetadata(commonConfiguration);</span>
<span class="nc" id="L189">    } catch (final IOException e) {</span>
<span class="nc" id="L190">      final String message =</span>
          &quot;Failed to retrieve the RocksDB database meta version: &quot;
<span class="nc" id="L192">              + e.getMessage()</span>
              + &quot; could not be found. You may not have the appropriate permission to access the item.&quot;;
<span class="nc" id="L194">      throw new StorageException(message, e);</span>
<span class="fc" id="L195">    }</span>
<span class="fc" id="L196">    rocksDBConfiguration =</span>
<span class="fc" id="L197">        RocksDBConfigurationBuilder.from(configuration.get())</span>
<span class="fc" id="L198">            .databaseDir(storagePath(commonConfiguration))</span>
<span class="fc" id="L199">            .build();</span>
<span class="fc" id="L200">  }</span>

  private boolean requiresInit() {
<span class="fc bfc" id="L203" title="All 2 branches covered.">    return segmentedStorage == null;</span>
  }

  private DatabaseMetadata readDatabaseMetadata(final BesuConfiguration commonConfiguration)
      throws IOException {
<span class="fc" id="L208">    final Path dataDir = commonConfiguration.getDataPath();</span>
<span class="fc" id="L209">    final boolean dataDirExists = dataDir.toFile().exists();</span>
<span class="fc" id="L210">    final boolean databaseExists = commonConfiguration.getStoragePath().toFile().exists();</span>
<span class="fc" id="L211">    final boolean metadataExists = DatabaseMetadata.isPresent(dataDir);</span>
    DatabaseMetadata metadata;
<span class="fc bfc" id="L213" title="All 4 branches covered.">    if (databaseExists &amp;&amp; !metadataExists) {</span>
<span class="fc" id="L214">      throw new StorageException(</span>
          &quot;Database exists but metadata file not found, without it there is no safe way to open the database&quot;);
    }
<span class="fc bfc" id="L217" title="All 2 branches covered.">    if (metadataExists) {</span>
<span class="fc" id="L218">      metadata = DatabaseMetadata.lookUpFrom(dataDir);</span>

<span class="fc" id="L220">      if (!metadata</span>
<span class="fc" id="L221">          .getVersionedStorageFormat()</span>
<span class="fc" id="L222">          .getFormat()</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">          .equals(commonConfiguration.getDatabaseFormat())) {</span>
<span class="nc" id="L224">        handleFormatMismatch(commonConfiguration, dataDir, metadata);</span>
      }

<span class="fc" id="L227">      final var runtimeVersion =</span>
<span class="fc" id="L228">          BaseVersionedStorageFormat.defaultForNewDB(commonConfiguration.getDatabaseFormat());</span>

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">      if (metadata.getVersionedStorageFormat().getVersion() &gt; runtimeVersion.getVersion()) {</span>
<span class="nc" id="L231">        final var maybeDowngradedMetadata =</span>
<span class="nc" id="L232">            handleVersionDowngrade(dataDir, metadata, runtimeVersion);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (maybeDowngradedMetadata.isPresent()) {</span>
<span class="nc" id="L234">          metadata = maybeDowngradedMetadata.get();</span>
<span class="nc" id="L235">          metadata.writeToDirectory(dataDir);</span>
        }
      }

<span class="fc bfc" id="L239" title="All 2 branches covered.">      if (metadata.getVersionedStorageFormat().getVersion() &lt; runtimeVersion.getVersion()) {</span>
<span class="nc" id="L240">        final var maybeUpgradedMetadata = handleVersionUpgrade(dataDir, metadata, runtimeVersion);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (maybeUpgradedMetadata.isPresent()) {</span>
<span class="nc" id="L242">          metadata = maybeUpgradedMetadata.get();</span>
<span class="nc" id="L243">          metadata.writeToDirectory(dataDir);</span>
        }
      }

<span class="fc" id="L247">      LOG.info(&quot;Existing database at {}. Metadata {}. Processing WAL...&quot;, dataDir, metadata);</span>
<span class="fc" id="L248">    } else {</span>

<span class="fc" id="L250">      metadata = DatabaseMetadata.defaultForNewDb(commonConfiguration.getDatabaseFormat());</span>
<span class="fc" id="L251">      LOG.info(</span>
          &quot;No existing database at {}. Using default metadata for new db {}&quot;, dataDir, metadata);
<span class="fc bfc" id="L253" title="All 2 branches covered.">      if (!dataDirExists) {</span>
<span class="fc" id="L254">        Files.createDirectories(dataDir);</span>
      }
<span class="fc" id="L256">      metadata.writeToDirectory(dataDir);</span>
    }

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">    if (!isSupportedVersionedFormat(metadata.getVersionedStorageFormat())) {</span>
<span class="nc" id="L260">      final String message = &quot;Unsupported RocksDB metadata: &quot; + metadata;</span>
<span class="nc" id="L261">      LOG.error(message);</span>
<span class="nc" id="L262">      throw new StorageException(message);</span>
    }

<span class="fc" id="L265">    return metadata;</span>
  }

  private static void handleFormatMismatch(
      final BesuConfiguration commonConfiguration,
      final Path dataDir,
      final DatabaseMetadata existingMetadata) {
<span class="fc" id="L272">    String error =</span>
<span class="fc" id="L273">        String.format(</span>
            &quot;Database format mismatch: DB at %s is %s but config expects %s. &quot;
                + &quot;Please check your config.&quot;,
            dataDir,
<span class="fc" id="L277">            existingMetadata.getVersionedStorageFormat().getFormat().name(),</span>
<span class="fc" id="L278">            commonConfiguration.getDatabaseFormat());</span>

<span class="fc" id="L280">    throw new StorageException(error);</span>
  }

  private Optional&lt;DatabaseMetadata&gt; handleVersionDowngrade(
      final Path dataDir,
      final DatabaseMetadata existingMetadata,
      final BaseVersionedStorageFormat runtimeVersion) {
    // here we put the code, or the messages, to perform an automated, or manual, downgrade of the
    // database, if supported, otherwise we just prevent Besu from starting since it will not
    // recognize the newer version.
    // In case we do an automated downgrade, then we also need to update the metadata on disk to
    // reflect the change to the runtime version, and return it.

    // for the moment there are supported automated downgrades, so we just fail.
<span class="nc" id="L294">    String error =</span>
<span class="nc" id="L295">        String.format(</span>
            &quot;Database unsafe downgrade detect: DB at %s is %s with version %s but version %s is expected. &quot;
                + &quot;Please check your config and review release notes for supported downgrade procedures.&quot;,
            dataDir,
<span class="nc" id="L299">            existingMetadata.getVersionedStorageFormat().getFormat().name(),</span>
<span class="nc" id="L300">            existingMetadata.getVersionedStorageFormat().getVersion(),</span>
<span class="nc" id="L301">            runtimeVersion.getVersion());</span>

<span class="nc" id="L303">    throw new StorageException(error);</span>
  }

  private Optional&lt;DatabaseMetadata&gt; handleVersionUpgrade(
      final Path dataDir,
      final DatabaseMetadata existingMetadata,
      final BaseVersionedStorageFormat runtimeVersion) {
    // here we put the code, or the messages, to perform an automated, or manual, upgrade of the
    // database.
    // In case we do an automated upgrade, then we also need to update the metadata on disk to
    // reflect the change to the runtime version, and return it.

    // for the moment there are no planned automated upgrades, so we just fail.
<span class="fc" id="L316">    String error =</span>
<span class="fc" id="L317">        String.format(</span>
            &quot;Database unsafe downgrade detect: DB at %s is %s with version %s but version %s is expected. &quot;
                + &quot;Please check your config and review release notes for supported downgrade procedures.&quot;,
            dataDir,
<span class="fc" id="L321">            existingMetadata.getVersionedStorageFormat().getFormat().name(),</span>
<span class="fc" id="L322">            existingMetadata.getVersionedStorageFormat().getVersion(),</span>
<span class="fc" id="L323">            runtimeVersion.getVersion());</span>

<span class="fc" id="L325">    throw new StorageException(error);</span>
  }

  private boolean isSupportedVersionedFormat(final VersionedStorageFormat versionedStorageFormat) {
<span class="fc" id="L329">    return SUPPORTED_VERSIONED_FORMATS.stream()</span>
<span class="fc" id="L330">        .anyMatch(</span>
            vsf -&gt;
<span class="fc bfc" id="L332" title="All 2 branches covered.">                vsf.getFormat().equals(versionedStorageFormat.getFormat())</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                    &amp;&amp; vsf.getVersion() == versionedStorageFormat.getVersion());</span>
  }

  @Override
  public void close() throws IOException {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (segmentedStorage != null) {</span>
<span class="fc" id="L339">      segmentedStorage.close();</span>
    }
<span class="fc" id="L341">  }</span>

  @Override
  public boolean isSegmentIsolationSupported() {
<span class="fc" id="L345">    return true;</span>
  }

  @Override
  public boolean isSnapshotIsolationSupported() {
<span class="nc" id="L350">    return true;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>