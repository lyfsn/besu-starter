<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionPoolFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.transactions</a> &gt; <span class="el_source">TransactionPoolFactory.java</span></div><h1>TransactionPoolFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.transactions;

import static org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolConfiguration.Implementation.LAYERED;

import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.core.MiningParameters;
import org.hyperledger.besu.ethereum.eth.manager.EthContext;
import org.hyperledger.besu.ethereum.eth.messages.EthPV62;
import org.hyperledger.besu.ethereum.eth.messages.EthPV65;
import org.hyperledger.besu.ethereum.eth.sync.state.SyncState;
import org.hyperledger.besu.ethereum.eth.transactions.layered.AbstractPrioritizedTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.layered.BaseFeePrioritizedTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.layered.EndLayer;
import org.hyperledger.besu.ethereum.eth.transactions.layered.GasPricePrioritizedTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.layered.LayeredPendingTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.layered.ReadyTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.layered.SparseTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.sorter.AbstractPendingTransactionsSorter;
import org.hyperledger.besu.ethereum.eth.transactions.sorter.BaseFeePendingTransactionsSorter;
import org.hyperledger.besu.ethereum.eth.transactions.sorter.GasPricePendingTransactionsSorter;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.feemarket.FeeMarket;
import org.hyperledger.besu.plugin.services.BesuEvents;
import org.hyperledger.besu.plugin.services.MetricsSystem;

import java.time.Clock;
import java.util.function.BiFunction;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

<span class="nc" id="L46">public class TransactionPoolFactory {</span>
<span class="fc" id="L47">  private static final Logger LOG = LoggerFactory.getLogger(TransactionPoolFactory.class);</span>

  public static TransactionPool createTransactionPool(
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final EthContext ethContext,
      final Clock clock,
      final MetricsSystem metricsSystem,
      final SyncState syncState,
      final TransactionPoolConfiguration transactionPoolConfiguration,
      final BlobCache blobCache,
      final MiningParameters miningParameters) {

<span class="fc" id="L60">    final TransactionPoolMetrics metrics = new TransactionPoolMetrics(metricsSystem);</span>

<span class="fc" id="L62">    final PeerTransactionTracker transactionTracker = new PeerTransactionTracker();</span>
<span class="fc" id="L63">    final TransactionsMessageSender transactionsMessageSender =</span>
        new TransactionsMessageSender(transactionTracker);

<span class="fc" id="L66">    final NewPooledTransactionHashesMessageSender newPooledTransactionHashesMessageSender =</span>
        new NewPooledTransactionHashesMessageSender(transactionTracker);

<span class="fc" id="L69">    return createTransactionPool(</span>
        protocolSchedule,
        protocolContext,
        ethContext,
        clock,
        metrics,
        syncState,
        transactionPoolConfiguration,
        transactionTracker,
        transactionsMessageSender,
        newPooledTransactionHashesMessageSender,
        blobCache,
        miningParameters);
  }

  static TransactionPool createTransactionPool(
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final EthContext ethContext,
      final Clock clock,
      final TransactionPoolMetrics metrics,
      final SyncState syncState,
      final TransactionPoolConfiguration transactionPoolConfiguration,
      final PeerTransactionTracker transactionTracker,
      final TransactionsMessageSender transactionsMessageSender,
      final NewPooledTransactionHashesMessageSender newPooledTransactionHashesMessageSender,
      final BlobCache blobCache,
      final MiningParameters miningParameters) {

<span class="fc" id="L98">    final TransactionPool transactionPool =</span>
        new TransactionPool(
            () -&gt;
<span class="fc" id="L101">                createPendingTransactions(</span>
                    protocolSchedule,
                    protocolContext,
                    clock,
                    metrics,
                    transactionPoolConfiguration,
                    blobCache,
                    miningParameters),
            protocolSchedule,
            protocolContext,
            new TransactionBroadcaster(
                ethContext,
                transactionTracker,
                transactionsMessageSender,
                newPooledTransactionHashesMessageSender),
            ethContext,
            metrics,
            transactionPoolConfiguration);

<span class="fc" id="L120">    final TransactionsMessageHandler transactionsMessageHandler =</span>
        new TransactionsMessageHandler(
<span class="fc" id="L122">            ethContext.getScheduler(),</span>
            new TransactionsMessageProcessor(transactionTracker, transactionPool, metrics),
<span class="fc" id="L124">            transactionPoolConfiguration.getUnstable().getTxMessageKeepAliveSeconds());</span>

<span class="fc" id="L126">    final NewPooledTransactionHashesMessageHandler pooledTransactionsMessageHandler =</span>
        new NewPooledTransactionHashesMessageHandler(
<span class="fc" id="L128">            ethContext.getScheduler(),</span>
            new NewPooledTransactionHashesMessageProcessor(
                transactionTracker,
                transactionPool,
                transactionPoolConfiguration,
                ethContext,
                metrics),
<span class="fc" id="L135">            transactionPoolConfiguration.getUnstable().getTxMessageKeepAliveSeconds());</span>

<span class="fc" id="L137">    subscribeTransactionHandlers(</span>
        protocolContext,
        ethContext,
        transactionTracker,
        transactionPool,
        transactionsMessageHandler,
        pooledTransactionsMessageHandler);

<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (syncState.isInitialSyncPhaseDone()) {</span>
<span class="fc" id="L146">      LOG.info(&quot;Enabling transaction pool&quot;);</span>
<span class="fc" id="L147">      pooledTransactionsMessageHandler.setEnabled();</span>
<span class="fc" id="L148">      transactionsMessageHandler.setEnabled();</span>
<span class="fc" id="L149">      transactionPool.setEnabled();</span>
    } else {
<span class="fc" id="L151">      LOG.info(&quot;Transaction pool disabled while initial sync in progress&quot;);</span>
    }

<span class="fc" id="L154">    syncState.subscribeCompletionReached(</span>
<span class="fc" id="L155">        new BesuEvents.InitialSyncCompletionListener() {</span>
          @Override
          public void onInitialSyncCompleted() {
<span class="fc" id="L158">            LOG.info(&quot;Enabling transaction handling following initial sync&quot;);</span>
<span class="fc" id="L159">            enableTransactionHandling(</span>
                transactionTracker,
                transactionPool,
                transactionsMessageHandler,
                pooledTransactionsMessageHandler);
<span class="fc" id="L164">          }</span>

          @Override
          public void onInitialSyncRestart() {
<span class="nc" id="L168">            LOG.info(&quot;Disabling transaction handling during re-sync&quot;);</span>
<span class="nc" id="L169">            disableTransactionHandling(</span>
                transactionPool, transactionsMessageHandler, pooledTransactionsMessageHandler);
<span class="nc" id="L171">          }</span>
        });

<span class="fc" id="L174">    syncState.subscribeInSync(</span>
        isInSync -&gt; {
<span class="fc bfc" id="L176" title="All 2 branches covered.">          if (isInSync != transactionPool.isEnabled()) {</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">            if (isInSync &amp;&amp; syncState.isInitialSyncPhaseDone()) {</span>
<span class="fc" id="L178">              LOG.info(&quot;Node is in sync, enabling transaction handling&quot;);</span>
<span class="fc" id="L179">              enableTransactionHandling(</span>
                  transactionTracker,
                  transactionPool,
                  transactionsMessageHandler,
                  pooledTransactionsMessageHandler);
            } else {
<span class="fc bfc" id="L185" title="All 2 branches covered.">              if (transactionPool.isEnabled()) {</span>
<span class="fc" id="L186">                LOG.info(&quot;Node out of sync, disabling transaction handling&quot;);</span>
<span class="fc" id="L187">                disableTransactionHandling(</span>
                    transactionPool, transactionsMessageHandler, pooledTransactionsMessageHandler);
              }
            }
          }
<span class="fc" id="L192">        });</span>

<span class="fc" id="L194">    return transactionPool;</span>
  }

  private static void enableTransactionHandling(
      final PeerTransactionTracker transactionTracker,
      final TransactionPool transactionPool,
      final TransactionsMessageHandler transactionsMessageHandler,
      final NewPooledTransactionHashesMessageHandler pooledTransactionsMessageHandler) {
<span class="fc" id="L202">    transactionTracker.reset();</span>
<span class="fc" id="L203">    transactionPool.setEnabled();</span>
<span class="fc" id="L204">    transactionsMessageHandler.setEnabled();</span>
<span class="fc" id="L205">    pooledTransactionsMessageHandler.setEnabled();</span>
<span class="fc" id="L206">  }</span>

  private static void disableTransactionHandling(
      final TransactionPool transactionPool,
      final TransactionsMessageHandler transactionsMessageHandler,
      final NewPooledTransactionHashesMessageHandler pooledTransactionsMessageHandler) {
<span class="fc" id="L212">    transactionPool.setDisabled();</span>
<span class="fc" id="L213">    transactionsMessageHandler.setDisabled();</span>
<span class="fc" id="L214">    pooledTransactionsMessageHandler.setDisabled();</span>
<span class="fc" id="L215">  }</span>

  private static void subscribeTransactionHandlers(
      final ProtocolContext protocolContext,
      final EthContext ethContext,
      final PeerTransactionTracker transactionTracker,
      final TransactionPool transactionPool,
      final TransactionsMessageHandler transactionsMessageHandler,
      final NewPooledTransactionHashesMessageHandler pooledTransactionsMessageHandler) {
<span class="fc" id="L224">    ethContext.getEthPeers().subscribeDisconnect(transactionTracker);</span>
<span class="fc" id="L225">    protocolContext.getBlockchain().observeBlockAdded(transactionPool);</span>
<span class="fc" id="L226">    ethContext.getEthMessages().subscribe(EthPV62.TRANSACTIONS, transactionsMessageHandler);</span>
<span class="fc" id="L227">    ethContext</span>
<span class="fc" id="L228">        .getEthMessages()</span>
<span class="fc" id="L229">        .subscribe(EthPV65.NEW_POOLED_TRANSACTION_HASHES, pooledTransactionsMessageHandler);</span>
<span class="fc" id="L230">  }</span>

  private static PendingTransactions createPendingTransactions(
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final Clock clock,
      final TransactionPoolMetrics metrics,
      final TransactionPoolConfiguration transactionPoolConfiguration,
      final BlobCache blobCache,
      final MiningParameters miningParameters) {

<span class="fc" id="L241">    boolean isFeeMarketImplementBaseFee =</span>
<span class="fc" id="L242">        protocolSchedule.anyMatch(</span>
<span class="fc" id="L243">            scheduledSpec -&gt; scheduledSpec.spec().getFeeMarket().implementsBaseFee());</span>

<span class="fc bfc" id="L245" title="All 2 branches covered.">    if (transactionPoolConfiguration.getTxPoolImplementation().equals(LAYERED)) {</span>
<span class="fc" id="L246">      return createLayeredPendingTransactions(</span>
          protocolSchedule,
          protocolContext,
          metrics,
          transactionPoolConfiguration,
          isFeeMarketImplementBaseFee,
          blobCache,
          miningParameters);
    } else {
<span class="fc" id="L255">      return createPendingTransactionSorter(</span>
          protocolContext,
          clock,
<span class="fc" id="L258">          metrics.getMetricsSystem(),</span>
          transactionPoolConfiguration,
          isFeeMarketImplementBaseFee);
    }
  }

  private static AbstractPendingTransactionsSorter createPendingTransactionSorter(
      final ProtocolContext protocolContext,
      final Clock clock,
      final MetricsSystem metricsSystem,
      final TransactionPoolConfiguration transactionPoolConfiguration,
      final boolean isFeeMarketImplementBaseFee) {
<span class="fc bfc" id="L270" title="All 2 branches covered.">    if (isFeeMarketImplementBaseFee) {</span>
<span class="fc" id="L271">      return new BaseFeePendingTransactionsSorter(</span>
          transactionPoolConfiguration,
          clock,
          metricsSystem,
<span class="fc" id="L275">          protocolContext.getBlockchain()::getChainHeadHeader);</span>
    } else {
<span class="fc" id="L277">      return new GasPricePendingTransactionsSorter(</span>
          transactionPoolConfiguration,
          clock,
          metricsSystem,
<span class="fc" id="L281">          protocolContext.getBlockchain()::getChainHeadHeader);</span>
    }
  }

  private static PendingTransactions createLayeredPendingTransactions(
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final TransactionPoolMetrics metrics,
      final TransactionPoolConfiguration transactionPoolConfiguration,
      final boolean isFeeMarketImplementBaseFee,
      final BlobCache blobCache,
      final MiningParameters miningParameters) {

<span class="fc" id="L294">    final TransactionPoolReplacementHandler transactionReplacementHandler =</span>
        new TransactionPoolReplacementHandler(
<span class="fc" id="L296">            transactionPoolConfiguration.getPriceBump(),</span>
<span class="fc" id="L297">            transactionPoolConfiguration.getBlobPriceBump());</span>

<span class="fc" id="L299">    final BiFunction&lt;PendingTransaction, PendingTransaction, Boolean&gt; transactionReplacementTester =</span>
        (t1, t2) -&gt;
<span class="fc" id="L301">            transactionReplacementHandler.shouldReplace(</span>
<span class="fc" id="L302">                t1, t2, protocolContext.getBlockchain().getChainHeadHeader());</span>

<span class="fc" id="L304">    final EndLayer endLayer = new EndLayer(metrics);</span>

<span class="fc" id="L306">    final SparseTransactions sparseTransactions =</span>
        new SparseTransactions(
            transactionPoolConfiguration,
            endLayer,
            metrics,
            transactionReplacementTester,
            blobCache);

<span class="fc" id="L314">    final ReadyTransactions readyTransactions =</span>
        new ReadyTransactions(
            transactionPoolConfiguration,
            sparseTransactions,
            metrics,
            transactionReplacementTester,
            blobCache);

    final AbstractPrioritizedTransactions pendingTransactionsSorter;
<span class="fc bfc" id="L323" title="All 2 branches covered.">    if (isFeeMarketImplementBaseFee) {</span>
<span class="fc" id="L324">      final FeeMarket feeMarket =</span>
          protocolSchedule
<span class="fc" id="L326">              .getByBlockHeader(protocolContext.getBlockchain().getChainHeadHeader())</span>
<span class="fc" id="L327">              .getFeeMarket();</span>

<span class="fc" id="L329">      pendingTransactionsSorter =</span>
          new BaseFeePrioritizedTransactions(
              transactionPoolConfiguration,
<span class="fc" id="L332">              protocolContext.getBlockchain()::getChainHeadHeader,</span>
              readyTransactions,
              metrics,
              transactionReplacementTester,
              feeMarket,
              blobCache,
              miningParameters);
<span class="fc" id="L339">    } else {</span>
<span class="fc" id="L340">      pendingTransactionsSorter =</span>
          new GasPricePrioritizedTransactions(
              transactionPoolConfiguration,
              readyTransactions,
              metrics,
              transactionReplacementTester,
              blobCache,
              miningParameters);
    }

<span class="fc" id="L350">    return new LayeredPendingTransactions(transactionPoolConfiguration, pendingTransactionsSorter);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>