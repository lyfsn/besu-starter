<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EthPeers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.manager</a> &gt; <span class="el_source">EthPeers.java</span></div><h1>EthPeers.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.manager;

import org.hyperledger.besu.ethereum.eth.manager.EthPeer.DisconnectCallback;
import org.hyperledger.besu.ethereum.eth.peervalidation.PeerValidator;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;
import org.hyperledger.besu.ethereum.p2p.peers.Peer;
import org.hyperledger.besu.ethereum.p2p.rlpx.RlpxAgent;
import org.hyperledger.besu.ethereum.p2p.rlpx.connections.PeerConnection;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.messages.DisconnectMessage;
import org.hyperledger.besu.metrics.BesuMetricCategory;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.metrics.Counter;
import org.hyperledger.besu.plugin.services.permissioning.NodeMessagePermissioningProvider;
import org.hyperledger.besu.util.Subscribers;

import java.time.Clock;
import java.time.Duration;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nonnull;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.RemovalNotification;
import org.apache.tuweni.bytes.Bytes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class EthPeers {
<span class="fc" id="L55">  private static final Logger LOG = LoggerFactory.getLogger(EthPeers.class);</span>
<span class="fc" id="L56">  public static final Comparator&lt;EthPeer&gt; TOTAL_DIFFICULTY =</span>
<span class="fc" id="L57">      Comparator.comparing((final EthPeer p) -&gt; p.chainState().getEstimatedTotalDifficulty());</span>

<span class="fc" id="L59">  public static final Comparator&lt;EthPeer&gt; CHAIN_HEIGHT =</span>
<span class="fc" id="L60">      Comparator.comparing((final EthPeer p) -&gt; p.chainState().getEstimatedHeight());</span>

<span class="fc" id="L62">  public static final Comparator&lt;EthPeer&gt; MOST_USEFUL_PEER =</span>
<span class="fc" id="L63">      Comparator.comparing((final EthPeer p) -&gt; p.getReputation().getScore())</span>
<span class="fc" id="L64">          .thenComparing(CHAIN_HEIGHT);</span>

<span class="fc" id="L66">  public static final Comparator&lt;EthPeer&gt; HEAVIEST_CHAIN =</span>
<span class="fc" id="L67">      TOTAL_DIFFICULTY.thenComparing(CHAIN_HEIGHT);</span>

<span class="fc" id="L69">  public static final Comparator&lt;EthPeer&gt; LEAST_TO_MOST_BUSY =</span>
<span class="fc" id="L70">      Comparator.comparing(EthPeer::outstandingRequests)</span>
<span class="fc" id="L71">          .thenComparing(EthPeer::getLastRequestTimestamp);</span>
  public static final int NODE_ID_LENGTH = 64;
  public static final int USEFULL_PEER_SCORE_THRESHOLD = 102;

<span class="fc" id="L75">  private final Map&lt;Bytes, EthPeer&gt; completeConnections = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L77">  private final Cache&lt;PeerConnection, EthPeer&gt; incompleteConnections =</span>
<span class="fc" id="L78">      CacheBuilder.newBuilder()</span>
<span class="fc" id="L79">          .expireAfterWrite(Duration.ofSeconds(20L))</span>
<span class="fc" id="L80">          .concurrencyLevel(1)</span>
<span class="fc" id="L81">          .removalListener(this::onCacheRemoval)</span>
<span class="fc" id="L82">          .build();</span>
  private final String protocolName;
  private final Clock clock;
  private final List&lt;NodeMessagePermissioningProvider&gt; permissioningProviders;
  private final int maxMessageSize;
<span class="fc" id="L87">  private final Subscribers&lt;ConnectCallback&gt; connectCallbacks = Subscribers.create();</span>
<span class="fc" id="L88">  private final Subscribers&lt;DisconnectCallback&gt; disconnectCallbacks = Subscribers.create();</span>
<span class="fc" id="L89">  private final Collection&lt;PendingPeerRequest&gt; pendingRequests = new CopyOnWriteArrayList&lt;&gt;();</span>
  private final int peerUpperBound;
  private final int maxRemotelyInitiatedConnections;
  private final Boolean randomPeerPriority;
<span class="fc" id="L93">  private final Bytes nodeIdMask = Bytes.random(NODE_ID_LENGTH);</span>
  private final Supplier&lt;ProtocolSpec&gt; currentProtocolSpecSupplier;

  private Comparator&lt;EthPeer&gt; bestPeerComparator;
  private final Bytes localNodeId;
  private RlpxAgent rlpxAgent;

  private final Counter connectedPeersCounter;

  public EthPeers(
      final String protocolName,
      final Supplier&lt;ProtocolSpec&gt; currentProtocolSpecSupplier,
      final Clock clock,
      final MetricsSystem metricsSystem,
      final int maxMessageSize,
      final List&lt;NodeMessagePermissioningProvider&gt; permissioningProviders,
      final Bytes localNodeId,
      final int peerUpperBound,
      final int maxRemotelyInitiatedConnections,
<span class="fc" id="L112">      final Boolean randomPeerPriority) {</span>
<span class="fc" id="L113">    this.protocolName = protocolName;</span>
<span class="fc" id="L114">    this.currentProtocolSpecSupplier = currentProtocolSpecSupplier;</span>
<span class="fc" id="L115">    this.clock = clock;</span>
<span class="fc" id="L116">    this.permissioningProviders = permissioningProviders;</span>
<span class="fc" id="L117">    this.maxMessageSize = maxMessageSize;</span>
<span class="fc" id="L118">    this.bestPeerComparator = HEAVIEST_CHAIN;</span>
<span class="fc" id="L119">    this.localNodeId = localNodeId;</span>
<span class="fc" id="L120">    this.peerUpperBound = peerUpperBound;</span>
<span class="fc" id="L121">    this.maxRemotelyInitiatedConnections = maxRemotelyInitiatedConnections;</span>
<span class="fc" id="L122">    this.randomPeerPriority = randomPeerPriority;</span>
<span class="fc" id="L123">    LOG.trace(&quot;MaxPeers: {}, Max Remote: {}&quot;, peerUpperBound, maxRemotelyInitiatedConnections);</span>
<span class="fc" id="L124">    metricsSystem.createIntegerGauge(</span>
        BesuMetricCategory.ETHEREUM,
        &quot;peer_count&quot;,
        &quot;The current number of peers connected&quot;,
<span class="nc" id="L128">        () -&gt; (int) streamAvailablePeers().filter(p -&gt; p.readyForRequests()).count());</span>
<span class="fc" id="L129">    metricsSystem.createIntegerGauge(</span>
        BesuMetricCategory.PEERS,
        &quot;pending_peer_requests_current&quot;,
        &quot;Number of peer requests currently pending because peers are busy&quot;,
<span class="fc" id="L133">        pendingRequests::size);</span>
<span class="fc" id="L134">    metricsSystem.createIntegerGauge(</span>
        BesuMetricCategory.ETHEREUM,
        &quot;peer_limit&quot;,
        &quot;The maximum number of peers this node allows to connect&quot;,
<span class="nc" id="L138">        () -&gt; peerUpperBound);</span>

<span class="fc" id="L140">    connectedPeersCounter =</span>
<span class="fc" id="L141">        metricsSystem.createCounter(</span>
            BesuMetricCategory.PEERS, &quot;connected_total&quot;, &quot;Total number of peers connected&quot;);
<span class="fc" id="L143">  }</span>

  public void registerNewConnection(
      final PeerConnection newConnection, final List&lt;PeerValidator&gt; peerValidators) {
<span class="fc" id="L147">    final Bytes id = newConnection.getPeer().getId();</span>
<span class="fc" id="L148">    synchronized (this) {</span>
<span class="fc" id="L149">      EthPeer ethPeer = completeConnections.get(id);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">      if (ethPeer == null) {</span>
<span class="fc" id="L151">        final Optional&lt;EthPeer&gt; peerInList =</span>
<span class="fc" id="L152">            incompleteConnections.asMap().values().stream()</span>
<span class="fc" id="L153">                .filter(p -&gt; p.getId().equals(id))</span>
<span class="fc" id="L154">                .findFirst();</span>
<span class="fc" id="L155">        ethPeer =</span>
<span class="fc" id="L156">            peerInList.orElse(</span>
                new EthPeer(
                    newConnection,
                    protocolName,
                    this::ethPeerStatusExchanged,
                    peerValidators,
                    maxMessageSize,
                    clock,
                    permissioningProviders,
                    localNodeId));
      }
<span class="fc" id="L167">      incompleteConnections.put(newConnection, ethPeer);</span>
<span class="fc" id="L168">    }</span>
<span class="fc" id="L169">  }</span>

  @Nonnull
  private List&lt;PeerConnection&gt; getIncompleteConnections(final Bytes id) {
<span class="fc" id="L173">    return incompleteConnections.asMap().keySet().stream()</span>
<span class="fc" id="L174">        .filter(nrc -&gt; nrc.getPeer().getId().equals(id))</span>
<span class="fc" id="L175">        .collect(Collectors.toList());</span>
  }

  public boolean registerDisconnect(final PeerConnection connection) {
<span class="fc" id="L179">    final EthPeer peer = peer(connection);</span>
<span class="fc" id="L180">    return registerDisconnect(peer.getId(), peer, connection);</span>
  }

  private boolean registerDisconnect(
      final Bytes id, final EthPeer peer, final PeerConnection connection) {
<span class="fc" id="L185">    incompleteConnections.invalidate(connection);</span>
<span class="fc" id="L186">    boolean removed = false;</span>
<span class="pc bpc" id="L187" title="1 of 4 branches missed.">    if (peer != null &amp;&amp; peer.getConnection().equals(connection)) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      if (!peerHasIncompleteConnection(id)) {</span>
<span class="fc" id="L189">        removed = completeConnections.remove(id, peer);</span>
<span class="fc" id="L190">        disconnectCallbacks.forEach(callback -&gt; callback.onDisconnect(peer));</span>
<span class="fc" id="L191">        peer.handleDisconnect();</span>
<span class="fc" id="L192">        abortPendingRequestsAssignedToDisconnectedPeers();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (peer.getReputation().getScore() &gt; USEFULL_PEER_SCORE_THRESHOLD) {</span>
<span class="fc" id="L194">          LOG.debug(&quot;Disconnected USEFULL peer {}&quot;, peer);</span>
        } else {
<span class="fc" id="L196">          LOG.debug(&quot;Disconnected EthPeer {}&quot;, peer.getLoggableId());</span>
        }
      }
    }
<span class="fc" id="L200">    reattemptPendingPeerRequests();</span>
<span class="fc" id="L201">    return removed;</span>
  }

  private boolean peerHasIncompleteConnection(final Bytes id) {
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    return getIncompleteConnections(id).stream().anyMatch(conn -&gt; !conn.isDisconnected());</span>
  }

  private void abortPendingRequestsAssignedToDisconnectedPeers() {
<span class="fc" id="L209">    synchronized (this) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">      for (final PendingPeerRequest request : pendingRequests) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (request.getAssignedPeer().map(EthPeer::isDisconnected).orElse(false)) {</span>
<span class="fc" id="L212">          request.abort();</span>
        }
<span class="fc" id="L214">      }</span>
<span class="fc" id="L215">    }</span>
<span class="fc" id="L216">  }</span>

  public EthPeer peer(final PeerConnection connection) {
<span class="fc" id="L219">    final EthPeer ethPeer = incompleteConnections.getIfPresent(connection);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    return ethPeer != null ? ethPeer : completeConnections.get(connection.getPeer().getId());</span>
  }

  public PendingPeerRequest executePeerRequest(
      final PeerRequest request, final long minimumBlockNumber, final Optional&lt;EthPeer&gt; peer) {
    final long actualMinBlockNumber;
<span class="fc bfc" id="L226" title="All 4 branches covered.">    if (minimumBlockNumber &gt; 0 &amp;&amp; currentProtocolSpecSupplier.get().isPoS()) {</span>
      // if on PoS do not enforce a min block number, since the estimated chain height of the remote
      // peer is not updated anymore.
<span class="fc" id="L229">      actualMinBlockNumber = 0;</span>
    } else {
<span class="fc" id="L231">      actualMinBlockNumber = minimumBlockNumber;</span>
    }
<span class="fc" id="L233">    final PendingPeerRequest pendingPeerRequest =</span>
        new PendingPeerRequest(this, request, actualMinBlockNumber, peer);
<span class="fc" id="L235">    synchronized (this) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      if (!pendingPeerRequest.attemptExecution()) {</span>
<span class="fc" id="L237">        pendingRequests.add(pendingPeerRequest);</span>
      }
<span class="fc" id="L239">    }</span>
<span class="fc" id="L240">    return pendingPeerRequest;</span>
  }

  public void dispatchMessage(
      final EthPeer peer, final EthMessage ethMessage, final String protocolName) {
<span class="fc" id="L245">    final Optional&lt;RequestManager&gt; maybeRequestManager = peer.dispatch(ethMessage, protocolName);</span>
<span class="fc bfc" id="L246" title="All 4 branches covered.">    if (maybeRequestManager.isPresent() &amp;&amp; peer.hasAvailableRequestCapacity()) {</span>
<span class="fc" id="L247">      reattemptPendingPeerRequests();</span>
    }
<span class="fc" id="L249">  }</span>

  public void dispatchMessage(final EthPeer peer, final EthMessage ethMessage) {
<span class="fc" id="L252">    dispatchMessage(peer, ethMessage, protocolName);</span>
<span class="fc" id="L253">  }</span>

  @VisibleForTesting
  void reattemptPendingPeerRequests() {
<span class="fc" id="L257">    synchronized (this) {</span>
<span class="fc" id="L258">      final List&lt;EthPeer&gt; peers = streamAvailablePeers().collect(Collectors.toList());</span>
<span class="fc" id="L259">      final Iterator&lt;PendingPeerRequest&gt; iterator = pendingRequests.iterator();</span>
<span class="fc bfc" id="L260" title="All 4 branches covered.">      while (iterator.hasNext() &amp;&amp; peers.stream().anyMatch(EthPeer::hasAvailableRequestCapacity)) {</span>
<span class="fc" id="L261">        final PendingPeerRequest request = iterator.next();</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (request.attemptExecution()) {</span>
<span class="fc" id="L263">          pendingRequests.remove(request);</span>
        }
<span class="fc" id="L265">      }</span>
<span class="fc" id="L266">    }</span>
<span class="fc" id="L267">  }</span>

  public long subscribeConnect(final ConnectCallback callback) {
<span class="fc" id="L270">    return connectCallbacks.subscribe(callback);</span>
  }

  public void unsubscribeConnect(final long id) {
<span class="fc" id="L274">    connectCallbacks.unsubscribe(id);</span>
<span class="fc" id="L275">  }</span>

  public void subscribeDisconnect(final DisconnectCallback callback) {
<span class="fc" id="L278">    disconnectCallbacks.subscribe(callback);</span>
<span class="fc" id="L279">  }</span>

  public int peerCount() {
<span class="fc" id="L282">    removeDisconnectedPeers();</span>
<span class="fc" id="L283">    return completeConnections.size();</span>
  }

  public int getMaxPeers() {
<span class="fc" id="L287">    return peerUpperBound;</span>
  }

  public Stream&lt;EthPeer&gt; streamAllPeers() {
<span class="fc" id="L291">    return completeConnections.values().stream();</span>
  }

  private void removeDisconnectedPeers() {
<span class="fc" id="L295">    completeConnections</span>
<span class="fc" id="L296">        .values()</span>
<span class="fc" id="L297">        .forEach(</span>
            ep -&gt; {
<span class="fc bfc" id="L299" title="All 2 branches covered.">              if (ep.isDisconnected()) {</span>
<span class="fc" id="L300">                registerDisconnect(ep.getId(), ep, ep.getConnection());</span>
              }
<span class="fc" id="L302">            });</span>
<span class="fc" id="L303">  }</span>

  public Stream&lt;EthPeer&gt; streamAvailablePeers() {
<span class="fc" id="L306">    return streamAllPeers()</span>
<span class="fc" id="L307">        .filter(EthPeer::readyForRequests)</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        .filter(peer -&gt; !peer.isDisconnected());</span>
  }

  public Stream&lt;EthPeer&gt; streamBestPeers() {
<span class="fc" id="L312">    return streamAvailablePeers()</span>
<span class="fc" id="L313">        .filter(EthPeer::isFullyValidated)</span>
<span class="fc" id="L314">        .sorted(getBestChainComparator().reversed());</span>
  }

  public Optional&lt;EthPeer&gt; bestPeer() {
<span class="fc" id="L318">    return streamAvailablePeers().max(getBestChainComparator());</span>
  }

  public Optional&lt;EthPeer&gt; bestPeerWithHeightEstimate() {
<span class="fc" id="L322">    return bestPeerMatchingCriteria(</span>
<span class="fc bfc" id="L323" title="All 4 branches covered.">        p -&gt; p.isFullyValidated() &amp;&amp; p.chainState().hasEstimatedHeight());</span>
  }

  public Optional&lt;EthPeer&gt; bestPeerMatchingCriteria(final Predicate&lt;EthPeer&gt; matchesCriteria) {
<span class="fc" id="L327">    return streamAvailablePeers().filter(matchesCriteria).max(getBestChainComparator());</span>
  }

  public void setBestChainComparator(final Comparator&lt;EthPeer&gt; comparator) {
<span class="fc" id="L331">    LOG.info(&quot;Updating the default best peer comparator&quot;);</span>
<span class="fc" id="L332">    bestPeerComparator = comparator;</span>
<span class="fc" id="L333">  }</span>

  public Comparator&lt;EthPeer&gt; getBestChainComparator() {
<span class="fc" id="L336">    return bestPeerComparator;</span>
  }

  public void setRlpxAgent(final RlpxAgent rlpxAgent) {
<span class="fc" id="L340">    this.rlpxAgent = rlpxAgent;</span>
<span class="fc" id="L341">  }</span>

  public Stream&lt;PeerConnection&gt; getAllActiveConnections() {
<span class="fc" id="L344">    return completeConnections.values().stream()</span>
<span class="fc" id="L345">        .map(EthPeer::getConnection)</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        .filter(c -&gt; !c.isDisconnected());</span>
  }

  public Stream&lt;PeerConnection&gt; getAllConnections() {
<span class="fc" id="L350">    return Stream.concat(</span>
<span class="fc" id="L351">            completeConnections.values().stream().map(EthPeer::getConnection),</span>
<span class="fc" id="L352">            incompleteConnections.asMap().keySet().stream())</span>
<span class="fc" id="L353">        .distinct()</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        .filter(c -&gt; !c.isDisconnected());</span>
  }

  public boolean shouldConnect(final Peer peer, final boolean inbound) {
<span class="fc" id="L358">    final Bytes id = peer.getId();</span>
<span class="pc bpc" id="L359" title="3 of 4 branches missed.">    if (peerCount() &gt;= peerUpperBound &amp;&amp; !canExceedPeerLimits(id)) {</span>
<span class="nc" id="L360">      return false;</span>
    }
<span class="fc" id="L362">    final EthPeer ethPeer = completeConnections.get(id);</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">    if (ethPeer != null &amp;&amp; !ethPeer.isDisconnected()) {</span>
<span class="fc" id="L364">      return false;</span>
    }
<span class="fc" id="L366">    final List&lt;PeerConnection&gt; incompleteConnections = getIncompleteConnections(id);</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">    if (!incompleteConnections.isEmpty()) {</span>
<span class="nc" id="L368">      if (incompleteConnections.stream()</span>
<span class="nc bnc" id="L369" title="All 10 branches missed.">          .anyMatch(c -&gt; !c.isDisconnected() &amp;&amp; (!inbound || (inbound &amp;&amp; c.inboundInitiated())))) {</span>
<span class="nc" id="L370">        return false;</span>
      }
    }
<span class="fc" id="L373">    return true;</span>
  }

  public void disconnectWorstUselessPeer() {
<span class="nc" id="L377">    streamAvailablePeers()</span>
<span class="nc" id="L378">        .sorted(getBestChainComparator())</span>
<span class="nc" id="L379">        .findFirst()</span>
<span class="nc" id="L380">        .ifPresent(</span>
            peer -&gt; {
<span class="nc" id="L382">              LOG.atDebug()</span>
<span class="nc" id="L383">                  .setMessage(</span>
                      &quot;disconnecting peer {}. Waiting for better peers. Current {} of max {}&quot;)
<span class="nc" id="L385">                  .addArgument(peer::getLoggableId)</span>
<span class="nc" id="L386">                  .addArgument(this::peerCount)</span>
<span class="nc" id="L387">                  .addArgument(this::getMaxPeers)</span>
<span class="nc" id="L388">                  .log();</span>
<span class="nc" id="L389">              peer.disconnect(DisconnectMessage.DisconnectReason.USELESS_PEER);</span>
<span class="nc" id="L390">            });</span>
<span class="nc" id="L391">  }</span>

  @FunctionalInterface
  public interface ConnectCallback {
    void onPeerConnected(EthPeer newPeer);
  }

  @Override
  public String toString() {
<span class="fc bfc" id="L400" title="All 2 branches covered.">    if (completeConnections.isEmpty()) {</span>
<span class="fc" id="L401">      return &quot;0 EthPeers {}&quot;;</span>
    }
<span class="fc" id="L403">    final String connectionsList =</span>
<span class="fc" id="L404">        completeConnections.values().stream()</span>
<span class="fc" id="L405">            .sorted()</span>
<span class="fc" id="L406">            .map(EthPeer::toString)</span>
<span class="fc" id="L407">            .collect(Collectors.joining(&quot;, \n&quot;));</span>
<span class="fc" id="L408">    return completeConnections.size() + &quot; EthPeers {\n&quot; + connectionsList + '}';</span>
  }

  private void ethPeerStatusExchanged(final EthPeer peer) {
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">    if (addPeerToEthPeers(peer)) {</span>
<span class="fc" id="L413">      connectedPeersCounter.inc();</span>
<span class="fc" id="L414">      connectCallbacks.forEach(cb -&gt; cb.onPeerConnected(peer));</span>
    }
<span class="fc" id="L416">  }</span>

  private int comparePeerPriorities(final EthPeer p1, final EthPeer p2) {
<span class="nc" id="L419">    final PeerConnection a = p1.getConnection();</span>
<span class="nc" id="L420">    final PeerConnection b = p2.getConnection();</span>
<span class="nc" id="L421">    final boolean aCanExceedPeerLimits = canExceedPeerLimits(a.getPeer().getId());</span>
<span class="nc" id="L422">    final boolean bCanExceedPeerLimits = canExceedPeerLimits(b.getPeer().getId());</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">    if (aCanExceedPeerLimits &amp;&amp; !bCanExceedPeerLimits) {</span>
<span class="nc" id="L424">      return -1;</span>
<span class="nc bnc" id="L425" title="All 4 branches missed.">    } else if (bCanExceedPeerLimits &amp;&amp; !aCanExceedPeerLimits) {</span>
<span class="nc" id="L426">      return 1;</span>
    } else {
<span class="nc bnc" id="L428" title="All 2 branches missed.">      return randomPeerPriority</span>
<span class="nc" id="L429">          ? compareByMaskedNodeId(a, b)</span>
<span class="nc" id="L430">          : compareConnectionInitiationTimes(a, b);</span>
    }
  }

  private boolean canExceedPeerLimits(final Bytes peerId) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (rlpxAgent == null) {</span>
<span class="fc" id="L436">      return false;</span>
    }
<span class="fc" id="L438">    return rlpxAgent.canExceedConnectionLimits(peerId);</span>
  }

  private int compareConnectionInitiationTimes(final PeerConnection a, final PeerConnection b) {
<span class="nc" id="L442">    return Math.toIntExact(a.getInitiatedAt() - b.getInitiatedAt());</span>
  }

  private int compareByMaskedNodeId(final PeerConnection a, final PeerConnection b) {
<span class="nc" id="L446">    return a.getPeer().getId().xor(nodeIdMask).compareTo(b.getPeer().getId().xor(nodeIdMask));</span>
  }

  private void enforceRemoteConnectionLimits() {
<span class="nc bnc" id="L450" title="All 4 branches missed.">    if (!shouldLimitRemoteConnections() || peerCount() &lt; maxRemotelyInitiatedConnections) {</span>
      // Nothing to do
<span class="nc" id="L452">      return;</span>
    }

<span class="nc" id="L455">    getActivePrioritizedPeers()</span>
<span class="nc" id="L456">        .filter(p -&gt; p.getConnection().inboundInitiated())</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        .filter(p -&gt; !canExceedPeerLimits(p.getId()))</span>
<span class="nc" id="L458">        .skip(maxRemotelyInitiatedConnections)</span>
<span class="nc" id="L459">        .forEach(</span>
            conn -&gt; {
<span class="nc" id="L461">              LOG.trace(</span>
                  &quot;Too many remotely initiated connections. Disconnect low-priority connection: {}, maxRemote={}&quot;,
                  conn,
<span class="nc" id="L464">                  maxRemotelyInitiatedConnections);</span>
<span class="nc" id="L465">              conn.disconnect(DisconnectMessage.DisconnectReason.TOO_MANY_PEERS);</span>
<span class="nc" id="L466">            });</span>
<span class="nc" id="L467">  }</span>

  private Stream&lt;EthPeer&gt; getActivePrioritizedPeers() {
<span class="nc" id="L470">    return completeConnections.values().stream()</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        .filter(p -&gt; !p.isDisconnected())</span>
<span class="nc" id="L472">        .sorted(this::comparePeerPriorities);</span>
  }

  private void enforceConnectionLimits() {
<span class="nc bnc" id="L476" title="All 2 branches missed.">    if (peerCount() &lt; peerUpperBound) {</span>
      // Nothing to do - we're under our limits
<span class="nc" id="L478">      return;</span>
    }
<span class="nc" id="L480">    getActivePrioritizedPeers()</span>
<span class="nc" id="L481">        .skip(peerUpperBound)</span>
<span class="nc" id="L482">        .map(EthPeer::getConnection)</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        .filter(c -&gt; !canExceedPeerLimits(c.getPeer().getId()))</span>
<span class="nc" id="L484">        .forEach(</span>
            conn -&gt; {
<span class="nc" id="L486">              LOG.trace(</span>
                  &quot;Too many connections. Disconnect low-priority connection: {}, maxConnections={}&quot;,
                  conn,
<span class="nc" id="L489">                  peerUpperBound);</span>
<span class="nc" id="L490">              conn.disconnect(DisconnectMessage.DisconnectReason.TOO_MANY_PEERS);</span>
<span class="nc" id="L491">            });</span>
<span class="nc" id="L492">  }</span>

  private boolean remoteConnectionLimitReached() {
<span class="fc bfc" id="L495" title="All 2 branches covered.">    return shouldLimitRemoteConnections()</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        &amp;&amp; countUntrustedRemotelyInitiatedConnections() &gt;= maxRemotelyInitiatedConnections;</span>
  }

  private boolean shouldLimitRemoteConnections() {
<span class="fc bfc" id="L500" title="All 2 branches covered.">    return maxRemotelyInitiatedConnections &lt; peerUpperBound;</span>
  }

  private long countUntrustedRemotelyInitiatedConnections() {
<span class="fc" id="L504">    return completeConnections.values().stream()</span>
<span class="pc" id="L505">        .map(ep -&gt; ep.getConnection())</span>
<span class="pc" id="L506">        .filter(c -&gt; c.inboundInitiated())</span>
<span class="pc bnc" id="L507" title="All 2 branches missed.">        .filter(c -&gt; !c.isDisconnected())</span>
<span class="pc bnc" id="L508" title="All 2 branches missed.">        .filter(conn -&gt; !canExceedPeerLimits(conn.getPeer().getId()))</span>
<span class="fc" id="L509">        .count();</span>
  }

  private void onCacheRemoval(
      final RemovalNotification&lt;PeerConnection, EthPeer&gt; removalNotification) {
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">    if (removalNotification.wasEvicted()) {</span>
<span class="nc" id="L515">      final PeerConnection peerConnectionRemoved = removalNotification.getKey();</span>
<span class="nc" id="L516">      final PeerConnection peerConnectionOfEthPeer = removalNotification.getValue().getConnection();</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">      if (!peerConnectionRemoved.equals(peerConnectionOfEthPeer)) {</span>
        // If this connection is not the connection of the EthPeer by now we can disconnect
<span class="nc" id="L519">        peerConnectionRemoved.disconnect(DisconnectMessage.DisconnectReason.ALREADY_CONNECTED);</span>
      }
    }
<span class="fc" id="L522">  }</span>

  private boolean addPeerToEthPeers(final EthPeer peer) {
    // We have a connection to a peer that is on the right chain and is willing to connect to us.
    // Figure out whether we want to keep this peer and add it to the EthPeers connections.
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">    if (completeConnections.containsValue(peer)) {</span>
<span class="nc" id="L528">      return false;</span>
    }
<span class="fc" id="L530">    final PeerConnection connection = peer.getConnection();</span>
<span class="fc" id="L531">    final Bytes id = peer.getId();</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">    if (!randomPeerPriority) {</span>
      // Disconnect if too many peers
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">      if (!canExceedPeerLimits(id) &amp;&amp; peerCount() &gt;= peerUpperBound) {</span>
<span class="nc" id="L535">        LOG.trace(</span>
            &quot;Too many peers. Disconnect connection: {}, max connections {}&quot;,
            connection,
<span class="nc" id="L538">            peerUpperBound);</span>
<span class="nc" id="L539">        connection.disconnect(DisconnectMessage.DisconnectReason.TOO_MANY_PEERS);</span>
<span class="nc" id="L540">        return false;</span>
      }
      // Disconnect if too many remotely-initiated connections
<span class="fc bfc" id="L543" title="All 2 branches covered.">      if (connection.inboundInitiated()</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">          &amp;&amp; !canExceedPeerLimits(id)</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">          &amp;&amp; remoteConnectionLimitReached()) {</span>
<span class="nc" id="L546">        LOG.trace(</span>
            &quot;Too many remotely-initiated connections. Disconnect incoming connection: {}, maxRemote={}&quot;,
            connection,
<span class="nc" id="L549">            maxRemotelyInitiatedConnections);</span>
<span class="nc" id="L550">        connection.disconnect(DisconnectMessage.DisconnectReason.TOO_MANY_PEERS);</span>
<span class="nc" id="L551">        return false;</span>
      }
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">      final boolean added = (completeConnections.putIfAbsent(id, peer) == null);</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">      if (added) {</span>
<span class="fc" id="L555">        LOG.trace(&quot;Added peer {} with connection {} to completeConnections&quot;, id, connection);</span>
      } else {
<span class="nc" id="L557">        LOG.trace(&quot;Did not add peer {} with connection {} to completeConnections&quot;, id, connection);</span>
      }
<span class="fc" id="L559">      return added;</span>
    } else {
      // randomPeerPriority! Add the peer and if there are too many connections fix it
<span class="nc" id="L562">      completeConnections.putIfAbsent(id, peer);</span>
<span class="nc" id="L563">      enforceRemoteConnectionLimits();</span>
<span class="nc" id="L564">      enforceConnectionLimits();</span>
<span class="nc" id="L565">      return completeConnections.containsKey(id);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>