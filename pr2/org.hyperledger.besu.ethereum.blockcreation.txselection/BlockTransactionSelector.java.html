<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockTransactionSelector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.blockcreation.txselection</a> &gt; <span class="el_source">BlockTransactionSelector.java</span></div><h1>BlockTransactionSelector.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.blockcreation.txselection;

import static org.hyperledger.besu.plugin.data.TransactionSelectionResult.BLOCK_SELECTION_TIMEOUT;
import static org.hyperledger.besu.plugin.data.TransactionSelectionResult.SELECTED;
import static org.hyperledger.besu.plugin.data.TransactionSelectionResult.TX_EVALUATION_TOO_LONG;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.ethereum.GasLimitCalculator;
import org.hyperledger.besu.ethereum.blockcreation.txselection.selectors.AbstractTransactionSelector;
import org.hyperledger.besu.ethereum.blockcreation.txselection.selectors.BlobPriceTransactionSelector;
import org.hyperledger.besu.ethereum.blockcreation.txselection.selectors.BlockSizeTransactionSelector;
import org.hyperledger.besu.ethereum.blockcreation.txselection.selectors.MinPriorityFeePerGasTransactionSelector;
import org.hyperledger.besu.ethereum.blockcreation.txselection.selectors.PriceTransactionSelector;
import org.hyperledger.besu.ethereum.blockcreation.txselection.selectors.ProcessingResultTransactionSelector;
import org.hyperledger.besu.ethereum.chain.Blockchain;
import org.hyperledger.besu.ethereum.core.MiningParameters;
import org.hyperledger.besu.ethereum.core.MutableWorldState;
import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.hyperledger.besu.ethereum.core.TransactionReceipt;
import org.hyperledger.besu.ethereum.eth.manager.EthScheduler;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransaction;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;
import org.hyperledger.besu.ethereum.mainnet.AbstractBlockProcessor;
import org.hyperledger.besu.ethereum.mainnet.MainnetTransactionProcessor;
import org.hyperledger.besu.ethereum.mainnet.TransactionValidationParams;
import org.hyperledger.besu.ethereum.mainnet.feemarket.FeeMarket;
import org.hyperledger.besu.ethereum.processing.TransactionProcessingResult;
import org.hyperledger.besu.ethereum.vm.BlockHashLookup;
import org.hyperledger.besu.ethereum.vm.CachingBlockHashLookup;
import org.hyperledger.besu.evm.gascalculator.GasCalculator;
import org.hyperledger.besu.evm.worldstate.WorldUpdater;
import org.hyperledger.besu.plugin.data.TransactionSelectionResult;
import org.hyperledger.besu.plugin.services.tracer.BlockAwareOperationTracer;
import org.hyperledger.besu.plugin.services.txselection.PluginTransactionSelector;

import java.util.List;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

import com.google.common.base.Stopwatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Responsible for extracting transactions from PendingTransactions and determining if the
 * transaction is suitable for inclusion in the block defined by the provided
 * ProcessableBlockHeader.
 *
 * &lt;p&gt;If a transaction is suitable for inclusion, the world state must be updated, and a receipt
 * generated.
 *
 * &lt;p&gt;The output from this class's execution will be:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;A list of transactions to include in the block being constructed.
 *   &lt;li&gt;A list of receipts for inclusion in the block.
 *   &lt;li&gt;The root hash of the world state at the completion of transaction execution.
 *   &lt;li&gt;The amount of gas consumed when executing all transactions.
 *   &lt;li&gt;A list of transactions evaluated but not included in the block being constructed.
 * &lt;/ul&gt;
 *
 * Once &quot;used&quot; this class must be discarded and another created. This class contains state which is
 * not cleared between executions of buildTransactionListForBlock().
 */
public class BlockTransactionSelector {
<span class="fc" id="L86">  private static final Logger LOG = LoggerFactory.getLogger(BlockTransactionSelector.class);</span>
  private final Supplier&lt;Boolean&gt; isCancelled;
  private final MainnetTransactionProcessor transactionProcessor;
  private final Blockchain blockchain;
  private final MutableWorldState worldState;
  private final AbstractBlockProcessor.TransactionReceiptFactory transactionReceiptFactory;
  private final BlockSelectionContext blockSelectionContext;
<span class="fc" id="L93">  private final TransactionSelectionResults transactionSelectionResults =</span>
      new TransactionSelectionResults();
  private final List&lt;AbstractTransactionSelector&gt; transactionSelectors;
  private final PluginTransactionSelector pluginTransactionSelector;
  private final BlockAwareOperationTracer pluginOperationTracer;
  private final EthScheduler ethScheduler;
<span class="fc" id="L99">  private final AtomicBoolean isTimeout = new AtomicBoolean(false);</span>
  private final long blockTxsSelectionMaxTime;
  private WorldUpdater blockWorldStateUpdater;

  public BlockTransactionSelector(
      final MiningParameters miningParameters,
      final MainnetTransactionProcessor transactionProcessor,
      final Blockchain blockchain,
      final MutableWorldState worldState,
      final TransactionPool transactionPool,
      final ProcessableBlockHeader processableBlockHeader,
      final AbstractBlockProcessor.TransactionReceiptFactory transactionReceiptFactory,
      final Supplier&lt;Boolean&gt; isCancelled,
      final Address miningBeneficiary,
      final Wei blobGasPrice,
      final FeeMarket feeMarket,
      final GasCalculator gasCalculator,
      final GasLimitCalculator gasLimitCalculator,
      final PluginTransactionSelector pluginTransactionSelector,
<span class="fc" id="L118">      final EthScheduler ethScheduler) {</span>
<span class="fc" id="L119">    this.transactionProcessor = transactionProcessor;</span>
<span class="fc" id="L120">    this.blockchain = blockchain;</span>
<span class="fc" id="L121">    this.worldState = worldState;</span>
<span class="fc" id="L122">    this.transactionReceiptFactory = transactionReceiptFactory;</span>
<span class="fc" id="L123">    this.isCancelled = isCancelled;</span>
<span class="fc" id="L124">    this.ethScheduler = ethScheduler;</span>
<span class="fc" id="L125">    this.blockSelectionContext =</span>
        new BlockSelectionContext(
            miningParameters,
            gasCalculator,
            gasLimitCalculator,
            processableBlockHeader,
            feeMarket,
            blobGasPrice,
            miningBeneficiary,
            transactionPool);
<span class="fc" id="L135">    transactionSelectors = createTransactionSelectors(blockSelectionContext);</span>
<span class="fc" id="L136">    this.pluginTransactionSelector = pluginTransactionSelector;</span>
<span class="fc" id="L137">    this.pluginOperationTracer = pluginTransactionSelector.getOperationTracer();</span>
<span class="fc" id="L138">    blockWorldStateUpdater = worldState.updater();</span>
<span class="fc" id="L139">    blockTxsSelectionMaxTime = miningParameters.getBlockTxsSelectionMaxTime();</span>
<span class="fc" id="L140">  }</span>

  private List&lt;AbstractTransactionSelector&gt; createTransactionSelectors(
      final BlockSelectionContext context) {
<span class="fc" id="L144">    return List.of(</span>
        new BlockSizeTransactionSelector(context),
        new PriceTransactionSelector(context),
        new BlobPriceTransactionSelector(context),
        new MinPriorityFeePerGasTransactionSelector(context),
        new ProcessingResultTransactionSelector(context));
  }

  /**
   * Builds a list of transactions for a block by iterating over all transactions in the
   * PendingTransactions pool. This operation can be long-running and, if executed in a separate
   * thread, can be cancelled via the isCancelled supplier, which would result in a
   * CancellationException.
   *
   * @return The {@code TransactionSelectionResults} containing the results of transaction
   *     evaluation.
   */
  public TransactionSelectionResults buildTransactionListForBlock() {
<span class="fc" id="L162">    LOG.atDebug()</span>
<span class="fc" id="L163">        .setMessage(&quot;Transaction pool stats {}&quot;)</span>
<span class="fc" id="L164">        .addArgument(blockSelectionContext.transactionPool().logStats())</span>
<span class="fc" id="L165">        .log();</span>
<span class="fc" id="L166">    timeLimitedSelection();</span>
<span class="fc" id="L167">    LOG.atTrace()</span>
<span class="fc" id="L168">        .setMessage(&quot;Transaction selection result {}&quot;)</span>
<span class="fc" id="L169">        .addArgument(transactionSelectionResults::toTraceLog)</span>
<span class="fc" id="L170">        .log();</span>
<span class="fc" id="L171">    return transactionSelectionResults;</span>
  }

  private void timeLimitedSelection() {
<span class="fc" id="L175">    final var txSelection =</span>
<span class="fc" id="L176">        ethScheduler.scheduleBlockCreationTask(</span>
            () -&gt;
<span class="fc" id="L178">                blockSelectionContext</span>
<span class="fc" id="L179">                    .transactionPool()</span>
<span class="fc" id="L180">                    .selectTransactions(this::evaluateTransaction));</span>

    try {
<span class="fc" id="L183">      txSelection.get(blockTxsSelectionMaxTime, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L184">    } catch (InterruptedException | ExecutionException e) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (isCancelled.get()) {</span>
<span class="nc" id="L186">        throw new CancellationException(&quot;Cancelled during transaction selection&quot;);</span>
      }
<span class="nc" id="L188">      LOG.warn(&quot;Error during block transaction selection&quot;, e);</span>
<span class="fc" id="L189">    } catch (TimeoutException e) {</span>
      // synchronize since we want to be sure that there is no concurrent state update
<span class="fc" id="L191">      synchronized (isTimeout) {</span>
<span class="fc" id="L192">        isTimeout.set(true);</span>
<span class="fc" id="L193">      }</span>
<span class="fc" id="L194">      LOG.warn(</span>
          &quot;Interrupting the selection of transactions for block inclusion as it exceeds the maximum configured duration of &quot;
              + blockTxsSelectionMaxTime
              + &quot;ms&quot;,
          e);
<span class="pc" id="L199">    }</span>
<span class="fc" id="L200">  }</span>

  /**
   * Evaluates a list of transactions and updates the selection results accordingly. If a
   * transaction is not selected during the evaluation, it is updated as not selected in the
   * transaction selection results.
   *
   * @param transactions The list of transactions to be evaluated.
   * @return The {@code TransactionSelectionResults} containing the results of the transaction
   *     evaluations.
   */
  public TransactionSelectionResults evaluateTransactions(final List&lt;Transaction&gt; transactions) {
<span class="fc" id="L212">    transactions.forEach(</span>
<span class="fc" id="L213">        transaction -&gt; evaluateTransaction(new PendingTransaction.Local.Priority(transaction)));</span>
<span class="fc" id="L214">    return transactionSelectionResults;</span>
  }

  /**
   * Passed into the PendingTransactions, and is called on each transaction until sufficient
   * transactions are found which fill a block worth of gas. This function will continue to be
   * called until the block under construction is suitably full (in terms of gasLimit) and the
   * provided transaction's gasLimit does not fit within the space remaining in the block.
   *
   * @param pendingTransaction The transaction to be evaluated.
   * @return The result of the transaction evaluation process.
   * @throws CancellationException if the transaction selection process is cancelled.
   */
  private TransactionSelectionResult evaluateTransaction(
      final PendingTransaction pendingTransaction) {
<span class="fc" id="L229">    checkCancellation();</span>

<span class="fc" id="L231">    final TransactionEvaluationContext evaluationContext =</span>
<span class="fc" id="L232">        createTransactionEvaluationContext(pendingTransaction);</span>

<span class="fc" id="L234">    TransactionSelectionResult selectionResult = evaluatePreProcessing(evaluationContext);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (!selectionResult.selected()) {</span>
<span class="fc" id="L236">      return handleTransactionNotSelected(evaluationContext, selectionResult);</span>
    }

<span class="fc" id="L239">    final WorldUpdater txWorldStateUpdater = blockWorldStateUpdater.updater();</span>
<span class="fc" id="L240">    final TransactionProcessingResult processingResult =</span>
<span class="fc" id="L241">        processTransaction(pendingTransaction, txWorldStateUpdater);</span>

<span class="fc" id="L243">    var postProcessingSelectionResult = evaluatePostProcessing(evaluationContext, processingResult);</span>

<span class="fc bfc" id="L245" title="All 2 branches covered.">    if (postProcessingSelectionResult.selected()) {</span>
<span class="fc" id="L246">      return handleTransactionSelected(evaluationContext, processingResult, txWorldStateUpdater);</span>
    }
<span class="fc" id="L248">    return handleTransactionNotSelected(</span>
        evaluationContext, postProcessingSelectionResult, txWorldStateUpdater);
  }

  private TransactionEvaluationContext createTransactionEvaluationContext(
      final PendingTransaction pendingTransaction) {
<span class="fc" id="L254">    final Wei transactionGasPriceInBlock =</span>
        blockSelectionContext
<span class="fc" id="L256">            .feeMarket()</span>
<span class="fc" id="L257">            .getTransactionPriceCalculator()</span>
<span class="fc" id="L258">            .price(</span>
<span class="fc" id="L259">                pendingTransaction.getTransaction(),</span>
<span class="fc" id="L260">                blockSelectionContext.processableBlockHeader().getBaseFee());</span>

<span class="fc" id="L262">    return new TransactionEvaluationContext(</span>
        pendingTransaction,
<span class="fc" id="L264">        Stopwatch.createStarted(),</span>
        transactionGasPriceInBlock,
<span class="fc" id="L266">        blockSelectionContext.miningParameters().getMinTransactionGasPrice());</span>
  }

  /**
   * This method evaluates a transaction by pre-processing it through a series of selectors. It
   * first processes the transaction through internal selectors, and if the transaction is selected,
   * it then processes it through external selectors. If the transaction is selected by all
   * selectors, it returns SELECTED.
   *
   * @param evaluationContext The current selection session data.
   * @return The result of the transaction selection process.
   */
  private TransactionSelectionResult evaluatePreProcessing(
      final TransactionEvaluationContext evaluationContext) {

<span class="fc bfc" id="L281" title="All 2 branches covered.">    for (var selector : transactionSelectors) {</span>
<span class="fc" id="L282">      TransactionSelectionResult result =</span>
<span class="fc" id="L283">          selector.evaluateTransactionPreProcessing(evaluationContext, transactionSelectionResults);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">      if (!result.equals(SELECTED)) {</span>
<span class="fc" id="L285">        return result;</span>
      }
<span class="fc" id="L287">    }</span>
<span class="fc" id="L288">    return pluginTransactionSelector.evaluateTransactionPreProcessing(evaluationContext);</span>
  }

  /**
   * This method evaluates a transaction by processing it through a series of selectors. Each
   * selector may use the transaction and/or the result of the transaction processing to decide
   * whether the transaction should be included in a block. If the transaction is selected by all
   * selectors, it returns SELECTED.
   *
   * @param evaluationContext The current selection session data.
   * @param processingResult The result of the transaction processing.
   * @return The result of the transaction selection process.
   */
  private TransactionSelectionResult evaluatePostProcessing(
      final TransactionEvaluationContext evaluationContext,
      final TransactionProcessingResult processingResult) {

<span class="fc bfc" id="L305" title="All 2 branches covered.">    for (var selector : transactionSelectors) {</span>
<span class="fc" id="L306">      TransactionSelectionResult result =</span>
<span class="fc" id="L307">          selector.evaluateTransactionPostProcessing(</span>
              evaluationContext, transactionSelectionResults, processingResult);
<span class="fc bfc" id="L309" title="All 2 branches covered.">      if (!result.equals(SELECTED)) {</span>
<span class="fc" id="L310">        return result;</span>
      }
<span class="fc" id="L312">    }</span>
<span class="fc" id="L313">    return pluginTransactionSelector.evaluateTransactionPostProcessing(</span>
        evaluationContext, processingResult);
  }

  /**
   * Processes a transaction
   *
   * @param pendingTransaction The transaction to be processed.
   * @param worldStateUpdater The world state updater.
   * @return The result of the transaction processing.
   */
  private TransactionProcessingResult processTransaction(
      final PendingTransaction pendingTransaction, final WorldUpdater worldStateUpdater) {
<span class="fc" id="L326">    final BlockHashLookup blockHashLookup =</span>
<span class="fc" id="L327">        new CachingBlockHashLookup(blockSelectionContext.processableBlockHeader(), blockchain);</span>
<span class="fc" id="L328">    return transactionProcessor.processTransaction(</span>
        blockchain,
        worldStateUpdater,
<span class="fc" id="L331">        blockSelectionContext.processableBlockHeader(),</span>
<span class="fc" id="L332">        pendingTransaction.getTransaction(),</span>
<span class="fc" id="L333">        blockSelectionContext.miningBeneficiary(),</span>
        pluginOperationTracer,
        blockHashLookup,
<span class="fc" id="L336">        false,</span>
<span class="fc" id="L337">        TransactionValidationParams.mining(),</span>
<span class="fc" id="L338">        blockSelectionContext.blobGasPrice());</span>
  }

  /**
   * Handles a selected transaction by committing the world state updates, creating a transaction
   * receipt, updating the TransactionSelectionResults with the selected transaction, and notifying
   * the external transaction selector.
   *
   * @param evaluationContext The current selection session data.
   * @param processingResult The result of the transaction processing.
   * @param txWorldStateUpdater The world state updater.
   * @return The result of the transaction selection process.
   */
  private TransactionSelectionResult handleTransactionSelected(
      final TransactionEvaluationContext evaluationContext,
      final TransactionProcessingResult processingResult,
      final WorldUpdater txWorldStateUpdater) {
<span class="fc" id="L355">    final Transaction transaction = evaluationContext.getTransaction();</span>

<span class="fc" id="L357">    final long gasUsedByTransaction =</span>
<span class="fc" id="L358">        transaction.getGasLimit() - processingResult.getGasRemaining();</span>
<span class="fc" id="L359">    final long cumulativeGasUsed =</span>
<span class="fc" id="L360">        transactionSelectionResults.getCumulativeGasUsed() + gasUsedByTransaction;</span>
<span class="fc" id="L361">    final long blobGasUsed =</span>
<span class="fc" id="L362">        blockSelectionContext.gasCalculator().blobGasCost(transaction.getBlobCount());</span>

    final boolean tooLate;

    // only add this tx to the selected set if it is not too late,
    // this need to be done synchronously to avoid that a concurrent timeout
    // could start packing a block while we are updating the state here
<span class="fc" id="L369">    synchronized (isTimeout) {</span>
<span class="fc" id="L370">      tooLate = isTimeout.get();</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">      if (!tooLate) {</span>
<span class="fc" id="L372">        txWorldStateUpdater.commit();</span>
<span class="fc" id="L373">        blockWorldStateUpdater.commit();</span>
<span class="fc" id="L374">        final TransactionReceipt receipt =</span>
<span class="fc" id="L375">            transactionReceiptFactory.create(</span>
<span class="fc" id="L376">                transaction.getType(), processingResult, worldState, cumulativeGasUsed);</span>

<span class="fc" id="L378">        transactionSelectionResults.updateSelected(</span>
            transaction, receipt, gasUsedByTransaction, blobGasUsed);
      }
<span class="fc" id="L381">    }</span>

<span class="fc bfc" id="L383" title="All 2 branches covered.">    if (tooLate) {</span>
      // even if this tx passed all the checks, it is too late to include it in this block,
      // so we need to treat it as not selected

      // do not rely on the presence of this result, since by the time it is added, the code
      // reading it could have been already executed by another thread
<span class="fc" id="L389">      return handleTransactionNotSelected(</span>
          evaluationContext, BLOCK_SELECTION_TIMEOUT, txWorldStateUpdater);
    }

<span class="fc" id="L393">    pluginTransactionSelector.onTransactionSelected(evaluationContext, processingResult);</span>
<span class="fc" id="L394">    blockWorldStateUpdater = worldState.updater();</span>
<span class="fc" id="L395">    LOG.atTrace()</span>
<span class="fc" id="L396">        .setMessage(&quot;Selected {} for block creation, evaluated in {}&quot;)</span>
<span class="fc" id="L397">        .addArgument(transaction::toTraceLog)</span>
<span class="fc" id="L398">        .addArgument(evaluationContext.getPendingTransaction())</span>
<span class="fc" id="L399">        .log();</span>
<span class="fc" id="L400">    return SELECTED;</span>
  }

  /**
   * Handles the scenario when a transaction is not selected. It updates the
   * TransactionSelectionResults with the unselected transaction, and notifies the external
   * transaction selector.
   *
   * @param evaluationContext The current selection session data.
   * @param selectionResult The result of the transaction selection process.
   * @return The result of the transaction selection process.
   */
  private TransactionSelectionResult handleTransactionNotSelected(
      final TransactionEvaluationContext evaluationContext,
      final TransactionSelectionResult selectionResult) {

<span class="fc" id="L416">    final var pendingTransaction = evaluationContext.getPendingTransaction();</span>

    // check if this tx took too much to evaluate, and in case remove it from the pool
    final TransactionSelectionResult actualResult =
<span class="fc bfc" id="L420" title="All 2 branches covered.">        isTimeout.get()</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">            ? transactionTookTooLong(evaluationContext)</span>
<span class="fc" id="L422">                ? TX_EVALUATION_TOO_LONG</span>
<span class="fc" id="L423">                : BLOCK_SELECTION_TIMEOUT</span>
<span class="fc" id="L424">            : selectionResult;</span>

<span class="fc" id="L426">    transactionSelectionResults.updateNotSelected(evaluationContext.getTransaction(), actualResult);</span>
<span class="fc" id="L427">    pluginTransactionSelector.onTransactionNotSelected(evaluationContext, actualResult);</span>
<span class="fc" id="L428">    LOG.atTrace()</span>
<span class="fc" id="L429">        .setMessage(</span>
            &quot;Not selected {} for block creation with result {} (original result {}), evaluated in {}&quot;)
<span class="fc" id="L431">        .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L432">        .addArgument(actualResult)</span>
<span class="fc" id="L433">        .addArgument(selectionResult)</span>
<span class="fc" id="L434">        .addArgument(evaluationContext.getEvaluationTimer())</span>
<span class="fc" id="L435">        .log();</span>

<span class="fc" id="L437">    return actualResult;</span>
  }

  private boolean transactionTookTooLong(final TransactionEvaluationContext evaluationContext) {
<span class="fc" id="L441">    final var evaluationTimer = evaluationContext.getEvaluationTimer();</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">    if (evaluationTimer.elapsed(TimeUnit.MILLISECONDS) &gt; blockTxsSelectionMaxTime) {</span>
<span class="fc" id="L443">      LOG.atWarn()</span>
<span class="fc" id="L444">          .setMessage(</span>
              &quot;Transaction {} is too late for inclusion, evaluated in {} that is over the max limit of {}ms&quot;
                  + &quot;, removing it from the pool&quot;)
<span class="fc" id="L447">          .addArgument(evaluationContext.getPendingTransaction()::getHash)</span>
<span class="fc" id="L448">          .addArgument(evaluationTimer)</span>
<span class="fc" id="L449">          .addArgument(blockTxsSelectionMaxTime)</span>
<span class="fc" id="L450">          .log();</span>
<span class="fc" id="L451">      return true;</span>
    }
<span class="fc" id="L453">    LOG.atTrace()</span>
<span class="fc" id="L454">        .setMessage(&quot;Transaction {} is too late for inclusion&quot;)</span>
<span class="fc" id="L455">        .addArgument(evaluationContext.getPendingTransaction()::toTraceLog)</span>
<span class="fc" id="L456">        .log();</span>

<span class="fc" id="L458">    return false;</span>
  }

  private TransactionSelectionResult handleTransactionNotSelected(
      final TransactionEvaluationContext evaluationContext,
      final TransactionSelectionResult selectionResult,
      final WorldUpdater txWorldStateUpdater) {
<span class="fc" id="L465">    txWorldStateUpdater.revert();</span>
<span class="fc" id="L466">    return handleTransactionNotSelected(evaluationContext, selectionResult);</span>
  }

  private void checkCancellation() {
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">    if (isCancelled.get()) {</span>
<span class="nc" id="L471">      throw new CancellationException(&quot;Cancelled during transaction selection.&quot;);</span>
    }
<span class="fc" id="L473">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>