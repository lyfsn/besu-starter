<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetricsHttpService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.metrics.prometheus</a> &gt; <span class="el_source">MetricsHttpService.java</span></div><h1>MetricsHttpService.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.metrics.prometheus;

import static com.google.common.base.Preconditions.checkArgument;

import org.hyperledger.besu.metrics.MetricsService;
import org.hyperledger.besu.plugin.services.MetricsSystem;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CompletableFuture;

import io.netty.handler.codec.http.HttpResponseStatus;
import io.prometheus.client.exporter.common.TextFormat;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.net.HostAndPort;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Metrics http service. */
public class MetricsHttpService implements MetricsService {
<span class="fc" id="L50">  private static final Logger LOG = LoggerFactory.getLogger(MetricsHttpService.class);</span>

<span class="fc" id="L52">  private static final InetSocketAddress EMPTY_SOCKET_ADDRESS = new InetSocketAddress(&quot;0.0.0.0&quot;, 0);</span>

  private final Vertx vertx;
  private final MetricsConfiguration config;
  private final MetricsSystem metricsSystem;

  private HttpServer httpServer;

  /**
   * Instantiates a new Metrics http service.
   *
   * @param vertx the vertx
   * @param configuration the configuration
   * @param metricsSystem the metrics system
   */
  public MetricsHttpService(
      final Vertx vertx,
      final MetricsConfiguration configuration,
<span class="fc" id="L70">      final MetricsSystem metricsSystem) {</span>
<span class="fc" id="L71">    validateConfig(configuration);</span>
<span class="fc" id="L72">    this.vertx = vertx;</span>
<span class="fc" id="L73">    this.config = configuration;</span>
<span class="fc" id="L74">    this.metricsSystem = metricsSystem;</span>
<span class="fc" id="L75">  }</span>

  private void validateConfig(final MetricsConfiguration config) {
<span class="pc bpc" id="L78" title="2 of 4 branches missed.">    checkArgument(config.getPort() &gt;= 0 &amp;&amp; config.getPort() &lt; 65535, &quot;Invalid port configuration.&quot;);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">    checkArgument(config.getHost() != null, &quot;Required host is not configured.&quot;);</span>
<span class="fc" id="L80">    checkArgument(</span>
<span class="pc bpc" id="L81" title="2 of 4 branches missed.">        !(config.isEnabled() &amp;&amp; config.isPushEnabled()),</span>
        &quot;Metrics Http Service cannot run concurrent with push metrics.&quot;);
<span class="fc" id="L83">  }</span>

  @Override
  public CompletableFuture&lt;?&gt; start() {
<span class="fc" id="L87">    LOG.info(&quot;Starting metrics http service on {}:{}&quot;, config.getHost(), config.getPort());</span>
    // Create the HTTP server and a router object.
<span class="fc" id="L89">    httpServer =</span>
<span class="fc" id="L90">        vertx.createHttpServer(</span>
            new HttpServerOptions()
<span class="fc" id="L92">                .setHost(config.getHost())</span>
<span class="fc" id="L93">                .setPort(config.getPort())</span>
<span class="fc" id="L94">                .setIdleTimeout(config.getIdleTimeout())</span>
<span class="fc" id="L95">                .setHandle100ContinueAutomatically(true)</span>
<span class="fc" id="L96">                .setCompressionSupported(true));</span>

<span class="fc" id="L98">    final Router router = Router.router(vertx);</span>

    // Verify Host header.
<span class="fc" id="L101">    router.route().handler(checkAllowlistHostHeader());</span>

    // Endpoint for AWS health check.
<span class="fc" id="L104">    router.route(&quot;/&quot;).method(HttpMethod.GET).handler(this::handleEmptyRequest);</span>

    // Endpoint for Prometheus metrics monitoring.
<span class="fc" id="L107">    router.route(&quot;/metrics&quot;).method(HttpMethod.GET).handler(this::metricsRequest);</span>

<span class="fc" id="L109">    final CompletableFuture&lt;?&gt; resultFuture = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L110">    httpServer</span>
<span class="fc" id="L111">        .requestHandler(router)</span>
<span class="fc" id="L112">        .listen(</span>
            res -&gt; {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">              if (!res.failed()) {</span>
<span class="fc" id="L115">                resultFuture.complete(null);</span>
<span class="fc" id="L116">                final int actualPort = httpServer.actualPort();</span>
<span class="fc" id="L117">                config.setActualPort(actualPort);</span>
<span class="fc" id="L118">                LOG.info(</span>
<span class="fc" id="L119">                    &quot;Metrics service started and listening on {}:{}&quot;, config.getHost(), actualPort);</span>
<span class="fc" id="L120">                return;</span>
              }
<span class="nc" id="L122">              httpServer = null;</span>
<span class="nc" id="L123">              final Throwable cause = res.cause();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">              if (cause instanceof SocketException) {</span>
<span class="nc" id="L125">                resultFuture.completeExceptionally(</span>
                    new RuntimeException(
<span class="nc" id="L127">                        String.format(</span>
                            &quot;Failed to bind metrics listener to %s:%s (actual port %s): %s&quot;,
<span class="nc" id="L129">                            config.getHost(),</span>
<span class="nc" id="L130">                            config.getPort(),</span>
<span class="nc" id="L131">                            config.getActualPort(),</span>
<span class="nc" id="L132">                            cause.getMessage())));</span>
<span class="nc" id="L133">                return;</span>
              }
<span class="nc" id="L135">              resultFuture.completeExceptionally(cause);</span>
<span class="nc" id="L136">            });</span>
<span class="fc" id="L137">    return resultFuture;</span>
  }

  private Handler&lt;RoutingContext&gt; checkAllowlistHostHeader() {
<span class="fc" id="L141">    return event -&gt; {</span>
<span class="fc" id="L142">      final Optional&lt;String&gt; hostHeader = getAndValidateHostHeader(event);</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">      if (config.getHostsAllowlist().contains(&quot;*&quot;)</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">          || (hostHeader.isPresent() &amp;&amp; hostIsInAllowlist(hostHeader.get()))) {</span>
<span class="fc" id="L145">        event.next();</span>
      } else {
<span class="nc" id="L147">        final HttpServerResponse response = event.response();</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (!response.closed()) {</span>
<span class="nc" id="L149">          response</span>
<span class="nc" id="L150">              .setStatusCode(403)</span>
<span class="nc" id="L151">              .putHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;)</span>
<span class="nc" id="L152">              .end(&quot;{\&quot;message\&quot;:\&quot;Host not authorized.\&quot;}&quot;);</span>
        }
      }
<span class="fc" id="L155">    };</span>
  }

  private Optional&lt;String&gt; getAndValidateHostHeader(final RoutingContext event) {
<span class="fc" id="L159">    return Optional.ofNullable(event.request().authority()).map(HostAndPort::host);</span>
  }

  private boolean hostIsInAllowlist(final String hostHeader) {
<span class="nc" id="L163">    if (config.getHostsAllowlist().stream()</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        .anyMatch(</span>
            allowlistEntry -&gt;
<span class="nc" id="L166">                allowlistEntry</span>
<span class="nc" id="L167">                    .toLowerCase(Locale.ROOT)</span>
<span class="nc" id="L168">                    .equals(hostHeader.toLowerCase(Locale.ROOT)))) {</span>
<span class="nc" id="L169">      return true;</span>
    } else {
<span class="nc" id="L171">      LOG.trace(&quot;Host not in allowlist: '{}'&quot;, hostHeader);</span>
<span class="nc" id="L172">      return false;</span>
    }
  }

  @Override
  public CompletableFuture&lt;?&gt; stop() {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">    if (httpServer == null) {</span>
<span class="nc" id="L179">      return CompletableFuture.completedFuture(null);</span>
    }

<span class="fc" id="L182">    final CompletableFuture&lt;?&gt; resultFuture = new CompletableFuture&lt;&gt;();</span>
<span class="fc" id="L183">    httpServer.close(</span>
        res -&gt; {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">          if (res.failed()) {</span>
<span class="nc" id="L186">            resultFuture.completeExceptionally(res.cause());</span>
          } else {
<span class="fc" id="L188">            httpServer = null;</span>
<span class="fc" id="L189">            resultFuture.complete(null);</span>
          }
<span class="fc" id="L191">        });</span>
<span class="fc" id="L192">    return resultFuture;</span>
  }

  private void metricsRequest(final RoutingContext routingContext) {
<span class="fc" id="L196">    final Set&lt;String&gt; names = new TreeSet&lt;&gt;(routingContext.queryParam(&quot;name[]&quot;));</span>
<span class="fc" id="L197">    final HttpServerResponse response = routingContext.response();</span>
<span class="fc" id="L198">    vertx.&lt;String&gt;executeBlocking(</span>
        future -&gt; {
          try {
<span class="fc" id="L201">            final ByteArrayOutputStream metrics = new ByteArrayOutputStream(16 * 1024);</span>
<span class="fc" id="L202">            final OutputStreamWriter osw = new OutputStreamWriter(metrics, StandardCharsets.UTF_8);</span>
<span class="fc" id="L203">            TextFormat.write004(</span>
                osw,
                ((PrometheusMetricsSystem) (metricsSystem))
<span class="fc" id="L206">                    .getRegistry()</span>
<span class="fc" id="L207">                    .filteredMetricFamilySamples(names));</span>
<span class="fc" id="L208">            osw.flush();</span>
<span class="fc" id="L209">            osw.close();</span>
<span class="fc" id="L210">            metrics.flush();</span>
<span class="fc" id="L211">            metrics.close();</span>
<span class="fc" id="L212">            future.complete(metrics.toString(StandardCharsets.UTF_8.name()));</span>
<span class="nc" id="L213">          } catch (final IOException ioe) {</span>
<span class="nc" id="L214">            future.fail(ioe);</span>
<span class="fc" id="L215">          }</span>
<span class="fc" id="L216">        },</span>
        false,
        (res) -&gt; {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">          if (response.closed()) {</span>
            // Request for metrics closed before response was generated
<span class="nc" id="L221">            return;</span>
          }
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">          if (res.failed()) {</span>
<span class="nc" id="L224">            LOG.error(&quot;Request for metrics failed&quot;, res.cause());</span>
<span class="nc" id="L225">            response.setStatusCode(HttpResponseStatus.INTERNAL_SERVER_ERROR.code()).end();</span>
          } else {
<span class="fc" id="L227">            response.setStatusCode(HttpResponseStatus.OK.code());</span>
<span class="fc" id="L228">            response.putHeader(&quot;Content-Type&quot;, TextFormat.CONTENT_TYPE_004);</span>
<span class="fc" id="L229">            response.end(res.result());</span>
          }
<span class="fc" id="L231">        });</span>
<span class="fc" id="L232">  }</span>

  /**
   * Socket address inet socket address.
   *
   * @return the inet socket address
   */
  InetSocketAddress socketAddress() {
<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (httpServer == null) {</span>
<span class="fc" id="L241">      return EMPTY_SOCKET_ADDRESS;</span>
    }
<span class="fc" id="L243">    return new InetSocketAddress(config.getHost(), httpServer.actualPort());</span>
  }

  @Override
  public Optional&lt;Integer&gt; getPort() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (httpServer == null) {</span>
<span class="nc" id="L249">      return Optional.empty();</span>
    }
<span class="nc" id="L251">    return Optional.of(httpServer.actualPort());</span>
  }

  // Facilitate remote health-checks in AWS, inter alia.
  private void handleEmptyRequest(final RoutingContext routingContext) {
<span class="fc" id="L256">    routingContext.response().setStatusCode(201).end();</span>
<span class="fc" id="L257">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>