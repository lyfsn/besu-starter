<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockBody.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.core</a> &gt; <span class="el_source">BlockBody.java</span></div><h1>BlockBody.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.core;

import org.hyperledger.besu.ethereum.rlp.RLPInput;
import org.hyperledger.besu.ethereum.rlp.RLPOutput;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class BlockBody implements org.hyperledger.besu.plugin.data.BlockBody {

<span class="fc" id="L27">  private static final BlockBody EMPTY =</span>
<span class="fc" id="L28">      new BlockBody(Collections.emptyList(), Collections.emptyList());</span>

  /**
   * Adding a new field with a corresponding root hash in the block header will require a change in
   * {@link org.hyperledger.besu.ethereum.eth.manager.task.GetBodiesFromPeerTask.BodyIdentifier}
   * Also requires adding the new field to the constructor used in the {@link
   * org.hyperledger.besu.ethereum.util.RawBlockIterator }
   */
  private final List&lt;Transaction&gt; transactions;

  private final List&lt;BlockHeader&gt; ommers;
  private final Optional&lt;List&lt;Withdrawal&gt;&gt; withdrawals;
  private final Optional&lt;List&lt;Deposit&gt;&gt; deposits;
  private final Optional&lt;List&lt;ValidatorExit&gt;&gt; exits;

<span class="fc" id="L43">  public BlockBody(final List&lt;Transaction&gt; transactions, final List&lt;BlockHeader&gt; ommers) {</span>
<span class="fc" id="L44">    this.transactions = transactions;</span>
<span class="fc" id="L45">    this.ommers = ommers;</span>
<span class="fc" id="L46">    this.withdrawals = Optional.empty();</span>
<span class="fc" id="L47">    this.deposits = Optional.empty();</span>
<span class="fc" id="L48">    this.exits = Optional.empty();</span>
<span class="fc" id="L49">  }</span>

  public BlockBody(
      final List&lt;Transaction&gt; transactions,
      final List&lt;BlockHeader&gt; ommers,
      final Optional&lt;List&lt;Withdrawal&gt;&gt; withdrawals,
      final Optional&lt;List&lt;Deposit&gt;&gt; deposits,
<span class="fc" id="L56">      final Optional&lt;List&lt;ValidatorExit&gt;&gt; exits) {</span>
<span class="fc" id="L57">    this.transactions = transactions;</span>
<span class="fc" id="L58">    this.ommers = ommers;</span>
<span class="fc" id="L59">    this.withdrawals = withdrawals;</span>
<span class="fc" id="L60">    this.deposits = deposits;</span>
<span class="fc" id="L61">    this.exits = exits;</span>
<span class="fc" id="L62">  }</span>

  public static BlockBody empty() {
<span class="fc" id="L65">    return EMPTY;</span>
  }

  /**
   * @return The list of transactions of the block.
   */
  @Override
  public List&lt;Transaction&gt; getTransactions() {
<span class="fc" id="L73">    return transactions;</span>
  }

  /**
   * @return The list of ommers of the block.
   */
  @Override
  public List&lt;BlockHeader&gt; getOmmers() {
<span class="fc" id="L81">    return ommers;</span>
  }

  /**
   * Returns the withdrawals of the block.
   *
   * @return The optional list of withdrawals included in the block.
   */
  @Override
  public Optional&lt;List&lt;Withdrawal&gt;&gt; getWithdrawals() {
<span class="fc" id="L91">    return withdrawals;</span>
  }

  /**
   * Returns the exits of the block.
   *
   * @return The optional list of exits included in the block.
   */
  @Override
  public Optional&lt;List&lt;ValidatorExit&gt;&gt; getExits() {
<span class="fc" id="L101">    return exits;</span>
  }

  /**
   * Returns the deposits of the block.
   *
   * @return The optional list of deposits included in the block.
   */
  @Override
  public Optional&lt;List&lt;Deposit&gt;&gt; getDeposits() {
<span class="fc" id="L111">    return deposits;</span>
  }

  /**
   * Writes Block to {@link RLPOutput}.
   *
   * @param output Output to write to
   */
  public void writeWrappedBodyTo(final RLPOutput output) {
<span class="fc" id="L120">    output.startList();</span>
<span class="fc" id="L121">    writeTo(output);</span>
<span class="fc" id="L122">    output.endList();</span>
<span class="fc" id="L123">  }</span>

  public void writeTo(final RLPOutput output) {
<span class="fc" id="L126">    output.writeList(getTransactions(), Transaction::writeTo);</span>
<span class="fc" id="L127">    output.writeList(getOmmers(), BlockHeader::writeTo);</span>
<span class="fc" id="L128">    withdrawals.ifPresent(withdrawals -&gt; output.writeList(withdrawals, Withdrawal::writeTo));</span>
<span class="pc" id="L129">    deposits.ifPresent(deposits -&gt; output.writeList(deposits, Deposit::writeTo));</span>
<span class="pc" id="L130">    exits.ifPresent(exits -&gt; output.writeList(exits, ValidatorExit::writeTo));</span>
<span class="fc" id="L131">  }</span>

  public static BlockBody readWrappedBodyFrom(
      final RLPInput input, final BlockHeaderFunctions blockHeaderFunctions) {
<span class="fc" id="L135">    return readWrappedBodyFrom(input, blockHeaderFunctions, false);</span>
  }

  /**
   * Read all fields from the block body expecting a list wrapping them An example of valid body
   * structure that this method would be able to read is: [[txs],[ommers],[withdrawals]] This is
   * used for decoding list of bodies
   *
   * @param input The RLP-encoded input
   * @param blockHeaderFunctions The block header functions used for parsing block headers
   * @param allowEmptyBody A flag indicating whether an empty body is allowed
   * @return the decoded BlockBody from the RLP
   */
  public static BlockBody readWrappedBodyFrom(
      final RLPInput input,
      final BlockHeaderFunctions blockHeaderFunctions,
      final boolean allowEmptyBody) {
<span class="fc" id="L152">    input.enterList();</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">    if (input.isEndOfCurrentList() &amp;&amp; allowEmptyBody) {</span>
      // empty block [] -&gt; Return empty body.
<span class="fc" id="L155">      input.leaveList();</span>
<span class="fc" id="L156">      return empty();</span>
    }
<span class="fc" id="L158">    final BlockBody body = readFrom(input, blockHeaderFunctions);</span>
<span class="fc" id="L159">    input.leaveList();</span>
<span class="fc" id="L160">    return body;</span>
  }

  /**
   * Read all fields from the block body expecting no list wrapping them. An example of a valid body
   * would be: [txs],[ommers],[withdrawals],[deposits] this method is called directly when importing
   * a single block
   *
   * @param input The RLP-encoded input
   * @param blockHeaderFunctions The block header functions used for parsing block headers
   * @return the BlockBody decoded from the RLP
   */
  public static BlockBody readFrom(
      final RLPInput input, final BlockHeaderFunctions blockHeaderFunctions) {
<span class="fc" id="L174">    return new BlockBody(</span>
<span class="fc" id="L175">        input.readList(Transaction::readFrom),</span>
<span class="fc" id="L176">        input.readList(rlp -&gt; BlockHeader.readFrom(rlp, blockHeaderFunctions)),</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">        input.isEndOfCurrentList()</span>
<span class="fc" id="L178">            ? Optional.empty()</span>
<span class="fc" id="L179">            : Optional.of(input.readList(Withdrawal::readFrom)),</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        input.isEndOfCurrentList()</span>
<span class="fc" id="L181">            ? Optional.empty()</span>
<span class="nc" id="L182">            : Optional.of(input.readList(Deposit::readFrom)),</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        input.isEndOfCurrentList()</span>
<span class="fc" id="L184">            ? Optional.empty()</span>
<span class="pc" id="L185">            : Optional.of(input.readList(ValidatorExit::readFrom)));</span>
  }

  @Override
  public boolean equals(final Object o) {
<span class="fc bfc" id="L190" title="All 2 branches covered.">    if (this == o) return true;</span>
<span class="pc bpc" id="L191" title="2 of 4 branches missed.">    if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L192">    BlockBody blockBody = (BlockBody) o;</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">    return Objects.equals(transactions, blockBody.transactions)</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        &amp;&amp; Objects.equals(ommers, blockBody.ommers)</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        &amp;&amp; Objects.equals(withdrawals, blockBody.withdrawals)</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        &amp;&amp; Objects.equals(deposits, blockBody.deposits)</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        &amp;&amp; Objects.equals(exits, blockBody.exits);</span>
  }

  @Override
  public int hashCode() {
<span class="fc" id="L202">    return Objects.hash(transactions, ommers, withdrawals, deposits, exits);</span>
  }

  public boolean isEmpty() {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">    return transactions.isEmpty()</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        &amp;&amp; ommers.isEmpty()</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        &amp;&amp; withdrawals.isEmpty()</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        &amp;&amp; deposits.isEmpty()</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        &amp;&amp; exits.isEmpty();</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L215">    return &quot;BlockBody{&quot;</span>
        + &quot;transactions=&quot;
        + transactions
        + &quot;, ommers=&quot;
        + ommers
        + &quot;, withdrawals=&quot;
        + withdrawals
        + &quot;, deposits=&quot;
        + deposits
        + &quot;, exits=&quot;
        + exits
        + '}';
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>