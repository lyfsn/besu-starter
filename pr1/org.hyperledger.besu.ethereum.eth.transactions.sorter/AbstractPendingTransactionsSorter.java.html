<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractPendingTransactionsSorter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.transactions.sorter</a> &gt; <span class="el_source">AbstractPendingTransactionsSorter.java</span></div><h1>AbstractPendingTransactionsSorter.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.transactions.sorter;

import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.ADDED;
import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.ALREADY_KNOWN;
import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.NONCE_TOO_FAR_IN_FUTURE_FOR_SENDER;
import static org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult.REJECTED_UNDERPRICED_REPLACEMENT;

import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.Transaction;
import org.hyperledger.besu.ethereum.eth.transactions.BlobCache;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransaction;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransactionAddedListener;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransactionDroppedListener;
import org.hyperledger.besu.ethereum.eth.transactions.PendingTransactions;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionAddedResult;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolConfiguration;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPoolReplacementHandler;
import org.hyperledger.besu.ethereum.mainnet.feemarket.FeeMarket;
import org.hyperledger.besu.evm.account.Account;
import org.hyperledger.besu.evm.account.AccountState;
import org.hyperledger.besu.metrics.BesuMetricCategory;
import org.hyperledger.besu.plugin.data.TransactionSelectionResult;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.metrics.Counter;
import org.hyperledger.besu.plugin.services.metrics.LabelledMetric;
import org.hyperledger.besu.util.Subscribers;

import java.time.Clock;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalLong;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Holds the current set of pending transactions with the ability to iterate them based on priority
 * for mining or look-up by hash.
 *
 * &lt;p&gt;This class is safe for use across multiple threads.
 */
public abstract class AbstractPendingTransactionsSorter implements PendingTransactions {
<span class="fc" id="L72">  private static final Logger LOG =</span>
<span class="fc" id="L73">      LoggerFactory.getLogger(AbstractPendingTransactionsSorter.class);</span>

  protected final Clock clock;
  protected final TransactionPoolConfiguration poolConfig;

<span class="fc" id="L78">  protected final Object lock = new Object();</span>
  protected final Map&lt;Hash, PendingTransaction&gt; pendingTransactions;

<span class="fc" id="L81">  protected final Map&lt;Address, PendingTransactionsForSender&gt; transactionsBySender =</span>
      new ConcurrentHashMap&lt;&gt;();

<span class="fc" id="L84">  protected final Subscribers&lt;PendingTransactionAddedListener&gt; pendingTransactionSubscribers =</span>
<span class="fc" id="L85">      Subscribers.create();</span>

<span class="fc" id="L87">  protected final Subscribers&lt;PendingTransactionDroppedListener&gt; transactionDroppedListeners =</span>
<span class="fc" id="L88">      Subscribers.create();</span>

  protected final LabelledMetric&lt;Counter&gt; transactionRemovedCounter;
  protected final Counter localTransactionAddedCounter;
  protected final Counter remoteTransactionAddedCounter;

  protected final TransactionPoolReplacementHandler transactionReplacementHandler;
  protected final Supplier&lt;BlockHeader&gt; chainHeadHeaderSupplier;

  private final BlobCache blobCache;

  public AbstractPendingTransactionsSorter(
      final TransactionPoolConfiguration poolConfig,
      final Clock clock,
      final MetricsSystem metricsSystem,
<span class="fc" id="L103">      final Supplier&lt;BlockHeader&gt; chainHeadHeaderSupplier) {</span>
<span class="fc" id="L104">    this.poolConfig = poolConfig;</span>
<span class="fc" id="L105">    this.pendingTransactions = new ConcurrentHashMap&lt;&gt;(poolConfig.getTxPoolMaxSize());</span>
<span class="fc" id="L106">    this.clock = clock;</span>
<span class="fc" id="L107">    this.chainHeadHeaderSupplier = chainHeadHeaderSupplier;</span>
<span class="fc" id="L108">    this.transactionReplacementHandler =</span>
<span class="fc" id="L109">        new TransactionPoolReplacementHandler(poolConfig.getPriceBump());</span>
<span class="fc" id="L110">    final LabelledMetric&lt;Counter&gt; transactionAddedCounter =</span>
<span class="fc" id="L111">        metricsSystem.createLabelledCounter(</span>
            BesuMetricCategory.TRANSACTION_POOL,
            &quot;transactions_added_total&quot;,
            &quot;Count of transactions added to the transaction pool&quot;,
            &quot;source&quot;);
<span class="fc" id="L116">    localTransactionAddedCounter = transactionAddedCounter.labels(&quot;local&quot;);</span>
<span class="fc" id="L117">    remoteTransactionAddedCounter = transactionAddedCounter.labels(&quot;remote&quot;);</span>

<span class="fc" id="L119">    transactionRemovedCounter =</span>
<span class="fc" id="L120">        metricsSystem.createLabelledCounter(</span>
            BesuMetricCategory.TRANSACTION_POOL,
            &quot;transactions_removed_total&quot;,
            &quot;Count of transactions removed from the transaction pool&quot;,
            &quot;source&quot;,
            &quot;operation&quot;);

<span class="fc" id="L127">    metricsSystem.createIntegerGauge(</span>
        BesuMetricCategory.TRANSACTION_POOL,
        &quot;transactions&quot;,
        &quot;Current size of the transaction pool&quot;,
<span class="fc" id="L131">        pendingTransactions::size);</span>

<span class="fc" id="L133">    this.blobCache = new BlobCache();</span>
<span class="fc" id="L134">  }</span>

  @Override
  public void reset() {
<span class="nc" id="L138">    pendingTransactions.clear();</span>
<span class="nc" id="L139">    transactionsBySender.clear();</span>
<span class="nc" id="L140">  }</span>

  @Override
  public void evictOldTransactions() {
<span class="fc" id="L144">    final long removeTransactionsBefore =</span>
        clock
<span class="fc" id="L146">            .instant()</span>
<span class="fc" id="L147">            .minus(poolConfig.getPendingTxRetentionPeriod(), ChronoUnit.HOURS)</span>
<span class="fc" id="L148">            .toEpochMilli();</span>

<span class="fc" id="L150">    pendingTransactions.values().stream()</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        .filter(transaction -&gt; transaction.getAddedAt() &lt; removeTransactionsBefore)</span>
<span class="fc" id="L152">        .forEach(</span>
            transactionInfo -&gt; {
<span class="fc" id="L154">              LOG.atTrace()</span>
<span class="fc" id="L155">                  .setMessage(&quot;Evicted {} due to age&quot;)</span>
<span class="fc" id="L156">                  .addArgument(transactionInfo::toTraceLog)</span>
<span class="fc" id="L157">                  .log();</span>
<span class="fc" id="L158">              removeTransaction(transactionInfo.getTransaction());</span>
<span class="fc" id="L159">            });</span>
<span class="fc" id="L160">  }</span>

  @Override
  public List&lt;Transaction&gt; getLocalTransactions() {
<span class="fc" id="L164">    return pendingTransactions.values().stream()</span>
<span class="fc" id="L165">        .filter(PendingTransaction::isReceivedFromLocalSource)</span>
<span class="fc" id="L166">        .map(PendingTransaction::getTransaction)</span>
<span class="fc" id="L167">        .collect(Collectors.toList());</span>
  }

  @Override
  public List&lt;Transaction&gt; getPriorityTransactions() {
<span class="fc" id="L172">    return pendingTransactions.values().stream()</span>
<span class="fc" id="L173">        .filter(PendingTransaction::hasPriority)</span>
<span class="fc" id="L174">        .map(PendingTransaction::getTransaction)</span>
<span class="fc" id="L175">        .collect(Collectors.toList());</span>
  }

  @Override
  public TransactionAddedResult addTransaction(
      final PendingTransaction transaction, final Optional&lt;Account&gt; maybeSenderAccount) {

<span class="fc" id="L182">    final TransactionAddedResult transactionAddedStatus =</span>
<span class="fc" id="L183">        internalAddTransaction(transaction, maybeSenderAccount);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (transactionAddedStatus.equals(ADDED)) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">      if (!transaction.isReceivedFromLocalSource()) {</span>
<span class="fc" id="L186">        remoteTransactionAddedCounter.inc();</span>
      } else {
<span class="fc" id="L188">        localTransactionAddedCounter.inc();</span>
      }
    }
<span class="fc" id="L191">    return transactionAddedStatus;</span>
  }

  void removeTransaction(final Transaction transaction) {
<span class="fc" id="L195">    removeTransaction(transaction, false);</span>
<span class="fc" id="L196">    notifyTransactionDropped(transaction);</span>
<span class="fc" id="L197">  }</span>

  @Override
  public void manageBlockAdded(
      final BlockHeader blockHeader,
      final List&lt;Transaction&gt; confirmedTransactions,
      final List&lt;Transaction&gt; reorgTransactions,
      final FeeMarket feeMarket) {
<span class="fc" id="L205">    synchronized (lock) {</span>
<span class="fc" id="L206">      confirmedTransactions.forEach(this::transactionAddedToBlock);</span>
<span class="fc" id="L207">      manageBlockAdded(blockHeader);</span>
<span class="fc" id="L208">    }</span>
<span class="fc" id="L209">  }</span>

  protected abstract void manageBlockAdded(final BlockHeader blockHeader);

  public void transactionAddedToBlock(final Transaction transaction) {
<span class="fc" id="L214">    removeTransaction(transaction, true);</span>
<span class="fc" id="L215">  }</span>

  private void incrementTransactionRemovedCounter(
      final boolean receivedFromLocalSource, final boolean addedToBlock) {
<span class="fc bfc" id="L219" title="All 2 branches covered.">    final String location = receivedFromLocalSource ? &quot;local&quot; : &quot;remote&quot;;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    final String operation = addedToBlock ? &quot;addedToBlock&quot; : &quot;dropped&quot;;</span>
<span class="fc" id="L221">    transactionRemovedCounter.labels(location, operation).inc();</span>
<span class="fc" id="L222">  }</span>

  // There's a small edge case here we could encounter.
  // When we pass an upgrade block that has a new transaction type, we start allowing transactions
  // of that new type into our pool.
  // If we then reorg to a block lower than the upgrade block height _and_ we create a block, that
  // block could end up with transactions of the new type.
  // This seems like it would be very rare but worth it to document that we don't handle that case
  // right now.
  @Override
  public void selectTransactions(final TransactionSelector selector) {
<span class="fc" id="L233">    synchronized (lock) {</span>
<span class="fc" id="L234">      final Set&lt;Transaction&gt; transactionsToRemove = new HashSet&lt;&gt;();</span>
<span class="fc" id="L235">      final Map&lt;Address, AccountTransactionOrder&gt; accountTransactions = new HashMap&lt;&gt;();</span>
<span class="fc" id="L236">      final Iterator&lt;PendingTransaction&gt; prioritizedTransactions = prioritizedTransactions();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">      while (prioritizedTransactions.hasNext()) {</span>
<span class="fc" id="L238">        final PendingTransaction highestPriorityPendingTransaction = prioritizedTransactions.next();</span>
<span class="fc" id="L239">        final AccountTransactionOrder accountTransactionOrder =</span>
<span class="fc" id="L240">            accountTransactions.computeIfAbsent(</span>
<span class="fc" id="L241">                highestPriorityPendingTransaction.getSender(), this::createSenderTransactionOrder);</span>

        for (final PendingTransaction transactionToProcess :
<span class="fc bfc" id="L244" title="All 2 branches covered.">            accountTransactionOrder.transactionsToProcess(highestPriorityPendingTransaction)) {</span>
<span class="fc" id="L245">          final TransactionSelectionResult result =</span>
<span class="fc" id="L246">              selector.evaluateTransaction(transactionToProcess);</span>

<span class="fc bfc" id="L248" title="All 2 branches covered.">          if (result.discard()) {</span>
<span class="fc" id="L249">            transactionsToRemove.add(transactionToProcess.getTransaction());</span>
          }

<span class="fc bfc" id="L252" title="All 2 branches covered.">          if (result.stop()) {</span>
<span class="fc" id="L253">            transactionsToRemove.forEach(this::removeTransaction);</span>
<span class="fc" id="L254">            return;</span>
          }
<span class="fc" id="L256">        }</span>
<span class="fc" id="L257">      }</span>
<span class="fc" id="L258">      transactionsToRemove.forEach(this::removeTransaction);</span>
<span class="fc" id="L259">    }</span>
<span class="fc" id="L260">  }</span>

  private AccountTransactionOrder createSenderTransactionOrder(final Address address) {
<span class="fc" id="L263">    return new AccountTransactionOrder(</span>
<span class="fc" id="L264">        transactionsBySender.get(address).streamPendingTransactions());</span>
  }

  private TransactionAddedResult addTransactionForSenderAndNonce(
      final PendingTransaction pendingTransaction, final Optional&lt;Account&gt; maybeSenderAccount) {

<span class="fc" id="L270">    PendingTransactionsForSender pendingTxsForSender =</span>
<span class="fc" id="L271">        transactionsBySender.computeIfAbsent(</span>
<span class="fc" id="L272">            pendingTransaction.getSender(),</span>
<span class="fc" id="L273">            address -&gt; new PendingTransactionsForSender(maybeSenderAccount));</span>

<span class="fc" id="L275">    PendingTransaction existingPendingTx =</span>
<span class="fc" id="L276">        pendingTxsForSender.getPendingTransactionForNonce(pendingTransaction.getNonce());</span>

    final Optional&lt;Transaction&gt; maybeReplacedTransaction;
<span class="fc bfc" id="L279" title="All 2 branches covered.">    if (existingPendingTx != null) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">      if (!transactionReplacementHandler.shouldReplace(</span>
<span class="fc" id="L281">          existingPendingTx, pendingTransaction, chainHeadHeaderSupplier.get())) {</span>
<span class="fc" id="L282">        LOG.atTrace()</span>
<span class="fc" id="L283">            .setMessage(&quot;Reject underpriced transaction replacement {}&quot;)</span>
<span class="fc" id="L284">            .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L285">            .log();</span>
<span class="fc" id="L286">        return REJECTED_UNDERPRICED_REPLACEMENT;</span>
      }
<span class="fc" id="L288">      LOG.atTrace()</span>
<span class="fc" id="L289">          .setMessage(&quot;Replace existing transaction {}, with new transaction {}&quot;)</span>
<span class="fc" id="L290">          .addArgument(existingPendingTx::toTraceLog)</span>
<span class="fc" id="L291">          .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L292">          .log();</span>
<span class="fc" id="L293">      maybeReplacedTransaction = Optional.of(existingPendingTx.getTransaction());</span>
    } else {
<span class="fc" id="L295">      maybeReplacedTransaction = Optional.empty();</span>
    }

<span class="fc" id="L298">    pendingTxsForSender.updateSenderAccount(maybeSenderAccount);</span>
<span class="fc" id="L299">    pendingTxsForSender.trackPendingTransaction(pendingTransaction);</span>
<span class="fc" id="L300">    LOG.atTrace()</span>
<span class="fc" id="L301">        .setMessage(&quot;Tracked transaction by sender {}&quot;)</span>
<span class="fc" id="L302">        .addArgument(pendingTxsForSender::toTraceLog)</span>
<span class="fc" id="L303">        .log();</span>
<span class="fc" id="L304">    maybeReplacedTransaction.ifPresent(this::removeTransaction);</span>
<span class="fc" id="L305">    return ADDED;</span>
  }

  private void removePendingTransactionBySenderAndNonce(
      final PendingTransaction pendingTransaction) {
<span class="fc" id="L310">    final Transaction transaction = pendingTransaction.getTransaction();</span>
<span class="fc" id="L311">    Optional.ofNullable(transactionsBySender.get(transaction.getSender()))</span>
<span class="fc" id="L312">        .ifPresent(</span>
            pendingTxsForSender -&gt; {
<span class="fc" id="L314">              pendingTxsForSender.removeTrackedPendingTransaction(pendingTransaction);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">              if (pendingTxsForSender.transactionCount() == 0) {</span>
<span class="fc" id="L316">                LOG.trace(</span>
                    &quot;Removing sender {} from transactionBySender since no more tracked transactions&quot;,
<span class="fc" id="L318">                    transaction.getSender());</span>
<span class="fc" id="L319">                transactionsBySender.remove(transaction.getSender());</span>
              } else {
<span class="fc" id="L321">                LOG.atTrace()</span>
<span class="fc" id="L322">                    .setMessage(&quot;Tracked transaction by sender {} after the removal of {}&quot;)</span>
<span class="fc" id="L323">                    .addArgument(pendingTxsForSender::toTraceLog)</span>
<span class="fc" id="L324">                    .addArgument(transaction::toTraceLog)</span>
<span class="fc" id="L325">                    .log();</span>
              }
<span class="fc" id="L327">            });</span>
<span class="fc" id="L328">  }</span>

  private void notifyTransactionAdded(final Transaction transaction) {
<span class="fc" id="L331">    pendingTransactionSubscribers.forEach(listener -&gt; listener.onTransactionAdded(transaction));</span>
<span class="fc" id="L332">  }</span>

  private void notifyTransactionDropped(final Transaction transaction) {
<span class="fc" id="L335">    transactionDroppedListeners.forEach(listener -&gt; listener.onTransactionDropped(transaction));</span>
<span class="fc" id="L336">  }</span>

  @Override
  public long maxSize() {
<span class="nc" id="L340">    return poolConfig.getTxPoolMaxSize();</span>
  }

  @Override
  public int size() {
<span class="fc" id="L345">    return pendingTransactions.size();</span>
  }

  @Override
  public boolean containsTransaction(final Transaction transaction) {
<span class="fc" id="L350">    return pendingTransactions.containsKey(transaction.getHash());</span>
  }

  @Override
  public Optional&lt;Transaction&gt; getTransactionByHash(final Hash transactionHash) {
<span class="fc" id="L355">    return Optional.ofNullable(pendingTransactions.get(transactionHash))</span>
<span class="fc" id="L356">        .map(PendingTransaction::getTransaction);</span>
  }

  @Override
  public List&lt;PendingTransaction&gt; getPendingTransactions() {
<span class="fc" id="L361">    return new ArrayList&lt;&gt;(pendingTransactions.values());</span>
  }

  @Override
  public long subscribePendingTransactions(final PendingTransactionAddedListener listener) {
<span class="fc" id="L366">    return pendingTransactionSubscribers.subscribe(listener);</span>
  }

  @Override
  public void unsubscribePendingTransactions(final long id) {
<span class="fc" id="L371">    pendingTransactionSubscribers.unsubscribe(id);</span>
<span class="fc" id="L372">  }</span>

  @Override
  public long subscribeDroppedTransactions(final PendingTransactionDroppedListener listener) {
<span class="fc" id="L376">    return transactionDroppedListeners.subscribe(listener);</span>
  }

  @Override
  public void unsubscribeDroppedTransactions(final long id) {
<span class="fc" id="L381">    transactionDroppedListeners.unsubscribe(id);</span>
<span class="fc" id="L382">  }</span>

  @Override
  public OptionalLong getNextNonceForSender(final Address sender) {
<span class="fc" id="L386">    final PendingTransactionsForSender pendingTransactionsForSender =</span>
<span class="fc" id="L387">        transactionsBySender.get(sender);</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">    return pendingTransactionsForSender == null</span>
<span class="fc" id="L389">        ? OptionalLong.empty()</span>
<span class="fc" id="L390">        : pendingTransactionsForSender.maybeNextNonce();</span>
  }

  private void removeTransaction(final Transaction transaction, final boolean addedToBlock) {
<span class="fc" id="L394">    synchronized (lock) {</span>
<span class="fc" id="L395">      final PendingTransaction removedPendingTx = pendingTransactions.remove(transaction.getHash());</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">      if (removedPendingTx != null) {</span>
<span class="fc" id="L397">        removePrioritizedTransaction(removedPendingTx);</span>
<span class="fc" id="L398">        removePendingTransactionBySenderAndNonce(removedPendingTx);</span>
<span class="fc" id="L399">        incrementTransactionRemovedCounter(</span>
<span class="fc" id="L400">            removedPendingTx.isReceivedFromLocalSource(), addedToBlock);</span>
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">        if (removedPendingTx.getTransaction().getBlobsWithCommitments().isPresent()</span>
            &amp;&amp; addedToBlock) {
<span class="fc" id="L403">          this.blobCache.cacheBlobs(removedPendingTx.getTransaction());</span>
        }
      }
<span class="fc" id="L406">    }</span>
<span class="fc" id="L407">  }</span>

  protected abstract void removePrioritizedTransaction(PendingTransaction removedPendingTx);

  protected abstract Iterator&lt;PendingTransaction&gt; prioritizedTransactions();

  protected abstract void prioritizeTransaction(final PendingTransaction pendingTransaction);

  private TransactionAddedResult internalAddTransaction(
      final PendingTransaction pendingTransaction, final Optional&lt;Account&gt; maybeSenderAccount) {
<span class="fc" id="L417">    final Transaction transaction = pendingTransaction.getTransaction();</span>
<span class="fc" id="L418">    synchronized (lock) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">      if (pendingTransactions.containsKey(pendingTransaction.getHash())) {</span>
<span class="fc" id="L420">        LOG.atTrace()</span>
<span class="fc" id="L421">            .setMessage(&quot;Already known transaction {}&quot;)</span>
<span class="fc" id="L422">            .addArgument(pendingTransaction::toTraceLog)</span>
<span class="fc" id="L423">            .log();</span>
<span class="fc" id="L424">        return ALREADY_KNOWN;</span>
      }

<span class="fc" id="L427">      if (transaction.getNonce() - maybeSenderAccount.map(AccountState::getNonce).orElse(0L)</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">          &gt;= poolConfig.getTxPoolMaxFutureTransactionByAccount()) {</span>
<span class="fc" id="L429">        LOG.atTrace()</span>
<span class="fc" id="L430">            .setMessage(</span>
                &quot;Transaction {} not added because nonce too far in the future for sender {}&quot;)
<span class="fc" id="L432">            .addArgument(transaction::toTraceLog)</span>
<span class="fc" id="L433">            .addArgument(</span>
                () -&gt;
<span class="nc" id="L435">                    maybeSenderAccount</span>
<span class="nc" id="L436">                        .map(Account::getAddress)</span>
<span class="nc" id="L437">                        .map(Address::toString)</span>
<span class="nc" id="L438">                        .orElse(&quot;unknown&quot;))</span>
<span class="fc" id="L439">            .log();</span>
<span class="fc" id="L440">        return NONCE_TOO_FAR_IN_FUTURE_FOR_SENDER;</span>
      }

<span class="fc" id="L443">      final TransactionAddedResult transactionAddedStatus =</span>
<span class="fc" id="L444">          addTransactionForSenderAndNonce(pendingTransaction, maybeSenderAccount);</span>

<span class="fc bfc" id="L446" title="All 2 branches covered.">      if (!transactionAddedStatus.equals(ADDED)) {</span>
<span class="fc" id="L447">        return transactionAddedStatus;</span>
      }

<span class="fc" id="L450">      pendingTransactions.put(pendingTransaction.getHash(), pendingTransaction);</span>
<span class="fc" id="L451">      prioritizeTransaction(pendingTransaction);</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">      if (pendingTransactions.size() &gt; poolConfig.getTxPoolMaxSize()) {</span>
<span class="fc" id="L454">        evictLessPriorityTransactions();</span>
      }
<span class="fc" id="L456">    }</span>
<span class="fc" id="L457">    notifyTransactionAdded(pendingTransaction.getTransaction());</span>
<span class="fc" id="L458">    return ADDED;</span>
  }

  protected abstract PendingTransaction getLeastPriorityTransaction();

  private void evictLessPriorityTransactions() {
<span class="fc" id="L464">    final PendingTransaction leastPriorityTx = getLeastPriorityTransaction();</span>
    // evict all txs for the sender with nonce &gt;= the least priority one to avoid gaps
<span class="fc" id="L466">    final var pendingTxsForSender = transactionsBySender.get(leastPriorityTx.getSender());</span>
<span class="fc" id="L467">    final var txsToEvict = pendingTxsForSender.getPendingTransactions(leastPriorityTx.getNonce());</span>

    // remove backward to avoid gaps
<span class="fc bfc" id="L470" title="All 2 branches covered.">    for (int i = txsToEvict.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L471">      removeTransaction(txsToEvict.get(i).getTransaction());</span>
    }
<span class="fc" id="L473">  }</span>

  @Override
  public String logStats() {
<span class="fc" id="L477">    return &quot;Pending &quot; + pendingTransactions.size();</span>
  }

  @Override
  public String toTraceLog() {
<span class="nc" id="L482">    synchronized (lock) {</span>
<span class="nc" id="L483">      StringBuilder sb =</span>
          new StringBuilder(
              &quot;Prioritized transactions { &quot;
<span class="nc" id="L486">                  + StreamSupport.stream(</span>
<span class="nc" id="L487">                          Spliterators.spliteratorUnknownSize(</span>
<span class="nc" id="L488">                              prioritizedTransactions(), Spliterator.ORDERED),</span>
                          false)
<span class="nc" id="L490">                      .map(PendingTransaction::toTraceLog)</span>
<span class="nc" id="L491">                      .collect(Collectors.joining(&quot;; &quot;))</span>
                  + &quot; }&quot;);

<span class="nc" id="L494">      return sb.toString();</span>
    }
  }
  /**
   * @param transaction to restore blobs onto
   * @return an optional copy of the supplied transaction, but with the BlobsWithCommitments
   *     restored. If none could be restored, empty.
   */
  @Override
  public Optional&lt;Transaction&gt; restoreBlob(final Transaction transaction) {
<span class="fc" id="L504">    return blobCache.restoreBlob(transaction);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>