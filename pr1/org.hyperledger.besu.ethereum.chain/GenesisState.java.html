<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenesisState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.chain</a> &gt; <span class="el_source">GenesisState.java</span></div><h1>GenesisState.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.chain;

import static java.util.Collections.emptyList;
import static org.hyperledger.besu.ethereum.trie.common.GenesisWorldStateProvider.createGenesisWorldState;

import org.hyperledger.besu.config.GenesisAllocation;
import org.hyperledger.besu.config.GenesisConfigFile;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.datatypes.BlobGas;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.datatypes.Wei;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockBody;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockHeaderBuilder;
import org.hyperledger.besu.ethereum.core.Deposit;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.core.MutableWorldState;
import org.hyperledger.besu.ethereum.core.Withdrawal;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.ScheduleBasedBlockHeaderFunctions;
import org.hyperledger.besu.ethereum.worldstate.DataStorageConfiguration;
import org.hyperledger.besu.evm.account.MutableAccount;
import org.hyperledger.besu.evm.log.LogsBloomFilter;
import org.hyperledger.besu.evm.worldstate.WorldUpdater;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalLong;
import java.util.function.Function;
import java.util.stream.Stream;

import com.google.common.base.MoreObjects;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;
import org.apache.tuweni.units.bigints.UInt256;

public final class GenesisState {

  private final Block block;
  private final List&lt;GenesisAccount&gt; genesisAccounts;

<span class="fc" id="L61">  private GenesisState(final Block block, final List&lt;GenesisAccount&gt; genesisAccounts) {</span>
<span class="fc" id="L62">    this.block = block;</span>
<span class="fc" id="L63">    this.genesisAccounts = genesisAccounts;</span>
<span class="fc" id="L64">  }</span>

  /**
   * Construct a {@link GenesisState} from a JSON string.
   *
   * @param json A JSON string describing the genesis block
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromJson(final String json, final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L74">    return fromConfig(GenesisConfigFile.fromConfig(json), protocolSchedule);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON string.
   *
   * @param dataStorageConfiguration A {@link DataStorageConfiguration} describing the storage
   *     configuration
   * @param json A JSON string describing the genesis block
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromJson(
      final DataStorageConfiguration dataStorageConfiguration,
      final String json,
      final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L90">    return fromConfig(</span>
<span class="fc" id="L91">        dataStorageConfiguration, GenesisConfigFile.fromConfig(json), protocolSchedule);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON object.
   *
   * @param config A {@link GenesisConfigFile} describing the genesis block.
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromConfig(
      final GenesisConfigFile config, final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L103">    return fromConfig(DataStorageConfiguration.DEFAULT_CONFIG, config, protocolSchedule);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON object.
   *
   * @param dataStorageConfiguration A {@link DataStorageConfiguration} describing the storage
   *     configuration
   * @param config A {@link GenesisConfigFile} describing the genesis block.
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromConfig(
      final DataStorageConfiguration dataStorageConfiguration,
      final GenesisConfigFile config,
      final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L119">    final List&lt;GenesisAccount&gt; genesisAccounts = parseAllocations(config).toList();</span>
<span class="fc" id="L120">    final Block block =</span>
        new Block(
<span class="fc" id="L122">            buildHeader(</span>
                config,
<span class="fc" id="L124">                calculateGenesisStateHash(dataStorageConfiguration, genesisAccounts),</span>
                protocolSchedule),
<span class="fc" id="L126">            buildBody(config));</span>
<span class="fc" id="L127">    return new GenesisState(block, genesisAccounts);</span>
  }

  /**
   * Construct a {@link GenesisState} from a JSON object.
   *
   * @param genesisStateHash The hash of the genesis state.
   * @param config A {@link GenesisConfigFile} describing the genesis block.
   * @param protocolSchedule A protocol Schedule associated with
   * @return A new {@link GenesisState}.
   */
  public static GenesisState fromConfig(
      final Hash genesisStateHash,
      final GenesisConfigFile config,
      final ProtocolSchedule protocolSchedule) {
<span class="fc" id="L142">    final List&lt;GenesisAccount&gt; genesisAccounts = parseAllocations(config).toList();</span>
<span class="fc" id="L143">    final Block block =</span>
<span class="fc" id="L144">        new Block(buildHeader(config, genesisStateHash, protocolSchedule), buildBody(config));</span>
<span class="fc" id="L145">    return new GenesisState(block, genesisAccounts);</span>
  }

  private static BlockBody buildBody(final GenesisConfigFile config) {
    final Optional&lt;List&lt;Withdrawal&gt;&gt; withdrawals =
<span class="fc bfc" id="L150" title="All 2 branches covered.">        isShanghaiAtGenesis(config) ? Optional.of(emptyList()) : Optional.empty();</span>
    final Optional&lt;List&lt;Deposit&gt;&gt; deposits =
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        isExperimentalEipsTimeAtGenesis(config) ? Optional.of(emptyList()) : Optional.empty();</span>

<span class="fc" id="L154">    return new BlockBody(emptyList(), emptyList(), withdrawals, deposits);</span>
  }

  public Block getBlock() {
<span class="fc" id="L158">    return block;</span>
  }

  /**
   * Writes the genesis block's world state to the given {@link MutableWorldState}.
   *
   * @param target WorldView to write genesis state to
   */
  public void writeStateTo(final MutableWorldState target) {
<span class="fc" id="L167">    writeAccountsTo(target, genesisAccounts, block.getHeader());</span>
<span class="fc" id="L168">  }</span>

  private static void writeAccountsTo(
      final MutableWorldState target,
      final List&lt;GenesisAccount&gt; genesisAccounts,
      final BlockHeader rootHeader) {
<span class="fc" id="L174">    final WorldUpdater updater = target.updater();</span>
<span class="fc" id="L175">    genesisAccounts.forEach(</span>
        genesisAccount -&gt; {
<span class="fc" id="L177">          final MutableAccount account = updater.getOrCreate(genesisAccount.address);</span>
<span class="fc" id="L178">          account.setNonce(genesisAccount.nonce);</span>
<span class="fc" id="L179">          account.setBalance(genesisAccount.balance);</span>
<span class="fc" id="L180">          account.setCode(genesisAccount.code);</span>
<span class="fc" id="L181">          genesisAccount.storage.forEach(account::setStorageValue);</span>
<span class="fc" id="L182">        });</span>
<span class="fc" id="L183">    updater.commit();</span>
<span class="fc" id="L184">    target.persist(rootHeader);</span>
<span class="fc" id="L185">  }</span>

  private static Hash calculateGenesisStateHash(
      final DataStorageConfiguration dataStorageConfiguration,
      final List&lt;GenesisAccount&gt; genesisAccounts) {
<span class="fc" id="L190">    try (var worldState = createGenesisWorldState(dataStorageConfiguration)) {</span>
<span class="fc" id="L191">      writeAccountsTo(worldState, genesisAccounts, null);</span>
<span class="fc" id="L192">      return worldState.rootHash();</span>
<span class="nc" id="L193">    } catch (Exception e) {</span>
<span class="nc" id="L194">      throw new RuntimeException(e);</span>
    }
  }

  private static BlockHeader buildHeader(
      final GenesisConfigFile genesis,
      final Hash genesisRootHash,
      final ProtocolSchedule protocolSchedule) {

<span class="fc" id="L203">    return BlockHeaderBuilder.create()</span>
<span class="fc" id="L204">        .parentHash(parseParentHash(genesis))</span>
<span class="fc" id="L205">        .ommersHash(Hash.EMPTY_LIST_HASH)</span>
<span class="fc" id="L206">        .coinbase(parseCoinbase(genesis))</span>
<span class="fc" id="L207">        .stateRoot(genesisRootHash)</span>
<span class="fc" id="L208">        .transactionsRoot(Hash.EMPTY_TRIE_HASH)</span>
<span class="fc" id="L209">        .receiptsRoot(Hash.EMPTY_TRIE_HASH)</span>
<span class="fc" id="L210">        .logsBloom(LogsBloomFilter.empty())</span>
<span class="fc" id="L211">        .difficulty(parseDifficulty(genesis))</span>
<span class="fc" id="L212">        .number(BlockHeader.GENESIS_BLOCK_NUMBER)</span>
<span class="fc" id="L213">        .gasLimit(genesis.getGasLimit())</span>
<span class="fc" id="L214">        .gasUsed(0L)</span>
<span class="fc" id="L215">        .timestamp(genesis.getTimestamp())</span>
<span class="fc" id="L216">        .extraData(parseExtraData(genesis))</span>
<span class="fc" id="L217">        .mixHash(parseMixHash(genesis))</span>
<span class="fc" id="L218">        .nonce(parseNonce(genesis))</span>
<span class="fc" id="L219">        .blockHeaderFunctions(ScheduleBasedBlockHeaderFunctions.create(protocolSchedule))</span>
<span class="fc" id="L220">        .baseFee(genesis.getGenesisBaseFeePerGas().orElse(null))</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        .withdrawalsRoot(isShanghaiAtGenesis(genesis) ? Hash.EMPTY_TRIE_HASH : null)</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        .blobGasUsed(isCancunAtGenesis(genesis) ? parseBlobGasUsed(genesis) : null)</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        .excessBlobGas(isCancunAtGenesis(genesis) ? parseExcessBlobGas(genesis) : null)</span>
<span class="fc" id="L224">        .parentBeaconBlockRoot(</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            (isCancunAtGenesis(genesis) ? parseParentBeaconBlockRoot(genesis) : null))</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        .depositsRoot(isExperimentalEipsTimeAtGenesis(genesis) ? Hash.EMPTY_TRIE_HASH : null)</span>
<span class="fc" id="L227">        .buildBlockHeader();</span>
  }

  private static Address parseCoinbase(final GenesisConfigFile genesis) {
<span class="fc" id="L231">    return genesis</span>
<span class="fc" id="L232">        .getCoinbase()</span>
<span class="fc" id="L233">        .map(str -&gt; withNiceErrorMessage(&quot;coinbase&quot;, str, Address::fromHexString))</span>
<span class="fc" id="L234">        .orElseGet(() -&gt; Address.wrap(Bytes.wrap(new byte[Address.SIZE])));</span>
  }

  private static &lt;T&gt; T withNiceErrorMessage(
      final String name, final String value, final Function&lt;String, T&gt; parser) {
    try {
<span class="fc" id="L240">      return parser.apply(value);</span>
<span class="nc" id="L241">    } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L242">      throw createInvalidBlockConfigException(name, value, e);</span>
    }
  }

  private static IllegalArgumentException createInvalidBlockConfigException(
      final String name, final String value, final IllegalArgumentException e) {
<span class="nc" id="L248">    return new IllegalArgumentException(</span>
        &quot;Invalid &quot; + name + &quot; in genesis block configuration: &quot; + value, e);
  }

  private static Hash parseParentHash(final GenesisConfigFile genesis) {
<span class="fc" id="L253">    return withNiceErrorMessage(&quot;parentHash&quot;, genesis.getParentHash(), Hash::fromHexStringLenient);</span>
  }

  private static Bytes parseExtraData(final GenesisConfigFile genesis) {
<span class="fc" id="L257">    return withNiceErrorMessage(&quot;extraData&quot;, genesis.getExtraData(), Bytes::fromHexString);</span>
  }

  private static Difficulty parseDifficulty(final GenesisConfigFile genesis) {
<span class="fc" id="L261">    return withNiceErrorMessage(&quot;difficulty&quot;, genesis.getDifficulty(), Difficulty::fromHexString);</span>
  }

  private static Hash parseMixHash(final GenesisConfigFile genesis) {
<span class="fc" id="L265">    return withNiceErrorMessage(&quot;mixHash&quot;, genesis.getMixHash(), Hash::fromHexStringLenient);</span>
  }

  private static Stream&lt;GenesisAccount&gt; parseAllocations(final GenesisConfigFile genesis) {
<span class="fc" id="L269">    return genesis.streamAllocations().map(GenesisAccount::fromAllocation);</span>
  }

  private static long parseNonce(final GenesisConfigFile genesis) {
<span class="fc" id="L273">    return withNiceErrorMessage(&quot;nonce&quot;, genesis.getNonce(), GenesisState::parseUnsignedLong);</span>
  }

  private static long parseBlobGasUsed(final GenesisConfigFile genesis) {
<span class="fc" id="L277">    return withNiceErrorMessage(</span>
<span class="fc" id="L278">        &quot;blobGasUsed&quot;, genesis.getBlobGasUsed(), GenesisState::parseUnsignedLong);</span>
  }

  private static BlobGas parseExcessBlobGas(final GenesisConfigFile genesis) {
<span class="fc" id="L282">    long excessBlobGas =</span>
<span class="fc" id="L283">        withNiceErrorMessage(</span>
<span class="fc" id="L284">            &quot;excessBlobGas&quot;, genesis.getExcessBlobGas(), GenesisState::parseUnsignedLong);</span>
<span class="fc" id="L285">    return BlobGas.of(excessBlobGas);</span>
  }

  private static Bytes32 parseParentBeaconBlockRoot(final GenesisConfigFile genesis) {
<span class="fc" id="L289">    return withNiceErrorMessage(</span>
<span class="fc" id="L290">        &quot;parentBeaconBlockRoot&quot;, genesis.getParentBeaconBlockRoot(), Bytes32::fromHexString);</span>
  }

  private static long parseUnsignedLong(final String value) {
<span class="fc" id="L294">    String v = value.toLowerCase(Locale.US);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (v.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L296">      v = v.substring(2);</span>
    }
<span class="fc" id="L298">    return Long.parseUnsignedLong(v, 16);</span>
  }

  private static boolean isShanghaiAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L302">    final OptionalLong shanghaiTimestamp = genesis.getConfigOptions().getShanghaiTime();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (shanghaiTimestamp.isPresent()) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">      return genesis.getTimestamp() &gt;= shanghaiTimestamp.getAsLong();</span>
    }
<span class="fc" id="L306">    return isCancunAtGenesis(genesis);</span>
  }

  private static boolean isCancunAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L310">    final OptionalLong cancunTimestamp = genesis.getConfigOptions().getCancunTime();</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">    if (cancunTimestamp.isPresent()) {</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">      return genesis.getTimestamp() &gt;= cancunTimestamp.getAsLong();</span>
    }
<span class="fc" id="L314">    return isPragueAtGenesis(genesis);</span>
  }

  private static boolean isPragueAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L318">    final OptionalLong pragueTimestamp = genesis.getConfigOptions().getPragueTime();</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    if (pragueTimestamp.isPresent()) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">      return genesis.getTimestamp() &gt;= pragueTimestamp.getAsLong();</span>
    }
<span class="fc" id="L322">    return isFutureEipsTimeAtGenesis(genesis);</span>
  }

  private static boolean isFutureEipsTimeAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L326">    final OptionalLong futureEipsTime = genesis.getConfigOptions().getFutureEipsTime();</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">    if (futureEipsTime.isPresent()) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">      return genesis.getTimestamp() &gt;= futureEipsTime.getAsLong();</span>
    }
<span class="fc" id="L330">    return isExperimentalEipsTimeAtGenesis(genesis);</span>
  }

  private static boolean isExperimentalEipsTimeAtGenesis(final GenesisConfigFile genesis) {
<span class="fc" id="L334">    final OptionalLong experimentalEipsTime = genesis.getConfigOptions().getExperimentalEipsTime();</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">    if (experimentalEipsTime.isPresent()) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">      return genesis.getTimestamp() &gt;= experimentalEipsTime.getAsLong();</span>
    }
<span class="fc" id="L338">    return false;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L343">    return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L344">        .add(&quot;block&quot;, block)</span>
<span class="nc" id="L345">        .add(&quot;genesisAccounts&quot;, genesisAccounts)</span>
<span class="nc" id="L346">        .toString();</span>
  }

  private static final class GenesisAccount {

    final long nonce;
    final Address address;
    final Wei balance;
    final Map&lt;UInt256, UInt256&gt; storage;
    final Bytes code;

    static GenesisAccount fromAllocation(final GenesisAllocation allocation) {
<span class="fc" id="L358">      return new GenesisAccount(</span>
<span class="fc" id="L359">          allocation.getNonce(),</span>
<span class="fc" id="L360">          allocation.getAddress(),</span>
<span class="fc" id="L361">          allocation.getBalance(),</span>
<span class="fc" id="L362">          allocation.getStorage(),</span>
<span class="fc" id="L363">          allocation.getCode());</span>
    }

    private GenesisAccount(
        final String hexNonce,
        final String hexAddress,
        final String balance,
        final Map&lt;String, String&gt; storage,
<span class="fc" id="L371">        final String hexCode) {</span>
<span class="fc" id="L372">      this.nonce = withNiceErrorMessage(&quot;nonce&quot;, hexNonce, GenesisState::parseUnsignedLong);</span>
<span class="fc" id="L373">      this.address = withNiceErrorMessage(&quot;address&quot;, hexAddress, Address::fromHexString);</span>
<span class="fc" id="L374">      this.balance = withNiceErrorMessage(&quot;balance&quot;, balance, this::parseBalance);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">      this.code = hexCode != null ? Bytes.fromHexString(hexCode) : null;</span>
<span class="fc" id="L376">      this.storage = parseStorage(storage);</span>
<span class="fc" id="L377">    }</span>

    private Wei parseBalance(final String balance) {
      final BigInteger val;
<span class="fc bfc" id="L381" title="All 2 branches covered.">      if (balance.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L382">        val = new BigInteger(1, Bytes.fromHexStringLenient(balance).toArrayUnsafe());</span>
      } else {
<span class="fc" id="L384">        val = new BigInteger(balance);</span>
      }

<span class="fc" id="L387">      return Wei.of(val);</span>
    }

    private Map&lt;UInt256, UInt256&gt; parseStorage(final Map&lt;String, String&gt; storage) {
<span class="fc" id="L391">      final Map&lt;UInt256, UInt256&gt; parsedStorage = new HashMap&lt;&gt;();</span>
<span class="fc" id="L392">      storage.forEach(</span>
          (key1, value1) -&gt; {
<span class="fc" id="L394">            final UInt256 key = withNiceErrorMessage(&quot;storage key&quot;, key1, UInt256::fromHexString);</span>
<span class="fc" id="L395">            final UInt256 value =</span>
<span class="fc" id="L396">                withNiceErrorMessage(&quot;storage value&quot;, value1, UInt256::fromHexString);</span>
<span class="fc" id="L397">            parsedStorage.put(key, value);</span>
<span class="fc" id="L398">          });</span>

<span class="fc" id="L400">      return parsedStorage;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L405">      return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L406">          .add(&quot;address&quot;, address)</span>
<span class="nc" id="L407">          .add(&quot;nonce&quot;, nonce)</span>
<span class="nc" id="L408">          .add(&quot;balance&quot;, balance)</span>
<span class="nc" id="L409">          .add(&quot;storage&quot;, storage)</span>
<span class="nc" id="L410">          .add(&quot;code&quot;, code)</span>
<span class="nc" id="L411">          .toString();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>