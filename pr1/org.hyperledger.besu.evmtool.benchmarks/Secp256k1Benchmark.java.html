<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Secp256k1Benchmark.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.evmtool.benchmarks</a> &gt; <span class="el_source">Secp256k1Benchmark.java</span></div><h1>Secp256k1Benchmark.java</h1><pre class="source lang-java linenums">/*
 * Copyright contributors to Hyperledger Besu
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.evmtool.benchmarks;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.hyperledger.besu.crypto.Hash.keccak256;

import org.hyperledger.besu.crypto.KeyPair;
import org.hyperledger.besu.crypto.SECP256K1;
import org.hyperledger.besu.crypto.SECPPrivateKey;
import org.hyperledger.besu.crypto.SECPSignature;

import java.io.PrintStream;
import java.math.BigInteger;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Stopwatch;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.Bytes32;

/** Benchmark secp256k1 public key extraction */
public class Secp256k1Benchmark extends BenchmarkExecutor {

  /** secp256k1 benchmark using default math warmup and iterations */
  public Secp256k1Benchmark() {
<span class="fc" id="L38">    super(MATH_WARMUP, MATH_ITERATIONS);</span>
<span class="fc" id="L39">  }</span>

  @Override
  public void runBenchmark(
      final PrintStream output, final Boolean attemptNative, final String fork) {
<span class="nc" id="L44">    final SECP256K1 signatureAlgorithm = new SECP256K1();</span>
<span class="nc bnc" id="L45" title="All 6 branches missed.">    if (attemptNative != null &amp;&amp; (!attemptNative || !signatureAlgorithm.maybeEnableNative())) {</span>
<span class="nc" id="L46">      signatureAlgorithm.disableNative();</span>
    }
<span class="nc bnc" id="L48" title="All 2 branches missed.">    output.println(signatureAlgorithm.isNative() ? &quot;Native secp256k1&quot; : &quot;Java secp256k1&quot;);</span>

<span class="nc" id="L50">    final SECPPrivateKey privateKey =</span>
<span class="nc" id="L51">        signatureAlgorithm.createPrivateKey(</span>
            new BigInteger(&quot;c85ef7d79691fe79573b1a7064c19c1a9819ebdbd1faaab1a8ec92344438aaf4&quot;, 16));
<span class="nc" id="L53">    final KeyPair keyPair = signatureAlgorithm.createKeyPair(privateKey);</span>

<span class="nc" id="L55">    final Bytes data = Bytes.wrap(&quot;This is an example of a signed message.&quot;.getBytes(UTF_8));</span>
<span class="nc" id="L56">    final Bytes32 dataHash = keccak256(data);</span>
<span class="nc" id="L57">    final SECPSignature signature = signatureAlgorithm.sign(dataHash, keyPair);</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">    for (int i = 0; i &lt; warmup; i++) {</span>
<span class="nc" id="L59">      signatureAlgorithm.recoverPublicKeyFromSignature(dataHash, signature);</span>
    }
<span class="nc" id="L61">    final Stopwatch timer = Stopwatch.createStarted();</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">    for (int i = 0; i &lt; iterations; i++) {</span>
<span class="nc" id="L63">      signatureAlgorithm.recoverPublicKeyFromSignature(dataHash, signature);</span>
    }
<span class="nc" id="L65">    timer.stop();</span>

<span class="nc" id="L67">    final double elapsed = timer.elapsed(TimeUnit.NANOSECONDS) / 1.0e9D;</span>
<span class="nc" id="L68">    final double perCall = elapsed / MATH_ITERATIONS;</span>

<span class="nc" id="L70">    output.printf(&quot;secp256k1 signature recovery for %,.1f Âµs%n&quot;, perCall * 1_000_000);</span>
<span class="nc" id="L71">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>