<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RunnerBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu</a> &gt; <span class="el_source">RunnerBuilder.java</span></div><h1>RunnerBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.Objects.isNull;
import static java.util.function.Predicate.isEqual;
import static java.util.function.Predicate.not;
import static org.hyperledger.besu.controller.BesuController.CACHE_PATH;
import static org.hyperledger.besu.ethereum.core.PrivacyParameters.FLEXIBLE_PRIVACY;

import org.hyperledger.besu.cli.config.EthNetworkConfig;
import org.hyperledger.besu.cli.config.NetworkName;
import org.hyperledger.besu.cli.options.stable.EthstatsOptions;
import org.hyperledger.besu.controller.BesuController;
import org.hyperledger.besu.cryptoservices.NodeKey;
import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.api.ApiConfiguration;
import org.hyperledger.besu.ethereum.api.graphql.GraphQLConfiguration;
import org.hyperledger.besu.ethereum.api.graphql.GraphQLContextType;
import org.hyperledger.besu.ethereum.api.graphql.GraphQLDataFetchers;
import org.hyperledger.besu.ethereum.api.graphql.GraphQLHttpService;
import org.hyperledger.besu.ethereum.api.graphql.GraphQLProvider;
import org.hyperledger.besu.ethereum.api.jsonrpc.EngineJsonRpcService;
import org.hyperledger.besu.ethereum.api.jsonrpc.JsonRpcConfiguration;
import org.hyperledger.besu.ethereum.api.jsonrpc.JsonRpcHttpService;
import org.hyperledger.besu.ethereum.api.jsonrpc.authentication.AuthenticationService;
import org.hyperledger.besu.ethereum.api.jsonrpc.authentication.DefaultAuthenticationService;
import org.hyperledger.besu.ethereum.api.jsonrpc.authentication.EngineAuthService;
import org.hyperledger.besu.ethereum.api.jsonrpc.execution.AuthenticatedJsonRpcProcessor;
import org.hyperledger.besu.ethereum.api.jsonrpc.execution.BaseJsonRpcProcessor;
import org.hyperledger.besu.ethereum.api.jsonrpc.execution.JsonRpcExecutor;
import org.hyperledger.besu.ethereum.api.jsonrpc.execution.JsonRpcProcessor;
import org.hyperledger.besu.ethereum.api.jsonrpc.health.HealthService;
import org.hyperledger.besu.ethereum.api.jsonrpc.health.LivenessCheck;
import org.hyperledger.besu.ethereum.api.jsonrpc.health.ReadinessCheck;
import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;
import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManagerBuilder;
import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;
import org.hyperledger.besu.ethereum.api.jsonrpc.ipc.JsonRpcIpcConfiguration;
import org.hyperledger.besu.ethereum.api.jsonrpc.ipc.JsonRpcIpcService;
import org.hyperledger.besu.ethereum.api.jsonrpc.methods.JsonRpcMethodsFactory;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketConfiguration;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketMessageHandler;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketService;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.methods.PrivateWebSocketMethodsFactory;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.methods.WebSocketMethodsFactory;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.subscription.SubscriptionManager;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.subscription.blockheaders.NewBlockHeadersSubscriptionService;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.subscription.logs.LogsSubscriptionService;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.subscription.pending.PendingTransactionDroppedSubscriptionService;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.subscription.pending.PendingTransactionSubscriptionService;
import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.subscription.syncing.SyncingSubscriptionService;
import org.hyperledger.besu.ethereum.api.query.BlockchainQueries;
import org.hyperledger.besu.ethereum.api.query.PrivacyQueries;
import org.hyperledger.besu.ethereum.blockcreation.MiningCoordinator;
import org.hyperledger.besu.ethereum.blockcreation.PoWMiningCoordinator;
import org.hyperledger.besu.ethereum.chain.Blockchain;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.MiningParameters;
import org.hyperledger.besu.ethereum.core.PrivacyParameters;
import org.hyperledger.besu.ethereum.core.Synchronizer;
import org.hyperledger.besu.ethereum.eth.manager.EthPeers;
import org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.precompiles.privacy.FlexiblePrivacyPrecompiledContract;
import org.hyperledger.besu.ethereum.p2p.config.DiscoveryConfiguration;
import org.hyperledger.besu.ethereum.p2p.config.NetworkingConfiguration;
import org.hyperledger.besu.ethereum.p2p.config.RlpxConfiguration;
import org.hyperledger.besu.ethereum.p2p.config.SubProtocolConfiguration;
import org.hyperledger.besu.ethereum.p2p.network.DefaultP2PNetwork;
import org.hyperledger.besu.ethereum.p2p.network.NetworkRunner;
import org.hyperledger.besu.ethereum.p2p.network.NetworkRunner.NetworkBuilder;
import org.hyperledger.besu.ethereum.p2p.network.NoopP2PNetwork;
import org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;
import org.hyperledger.besu.ethereum.p2p.network.ProtocolManager;
import org.hyperledger.besu.ethereum.p2p.peers.DefaultPeer;
import org.hyperledger.besu.ethereum.p2p.peers.EnodeDnsConfiguration;
import org.hyperledger.besu.ethereum.p2p.permissions.PeerPermissions;
import org.hyperledger.besu.ethereum.p2p.permissions.PeerPermissionsDenylist;
import org.hyperledger.besu.ethereum.p2p.rlpx.connections.netty.TLSConfiguration;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.SubProtocol;
import org.hyperledger.besu.ethereum.permissioning.AccountLocalConfigPermissioningController;
import org.hyperledger.besu.ethereum.permissioning.NodeLocalConfigPermissioningController;
import org.hyperledger.besu.ethereum.permissioning.NodePermissioningControllerFactory;
import org.hyperledger.besu.ethereum.permissioning.PermissioningConfiguration;
import org.hyperledger.besu.ethereum.permissioning.account.AccountPermissioningController;
import org.hyperledger.besu.ethereum.permissioning.account.AccountPermissioningControllerFactory;
import org.hyperledger.besu.ethereum.permissioning.node.InsufficientPeersPermissioningProvider;
import org.hyperledger.besu.ethereum.permissioning.node.NodePermissioningController;
import org.hyperledger.besu.ethereum.permissioning.node.PeerPermissionsAdapter;
import org.hyperledger.besu.ethereum.privacy.PrivateTransactionObserver;
import org.hyperledger.besu.ethereum.storage.StorageProvider;
import org.hyperledger.besu.ethereum.stratum.StratumServer;
import org.hyperledger.besu.ethereum.transaction.TransactionSimulator;
import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;
import org.hyperledger.besu.ethstats.EthStatsService;
import org.hyperledger.besu.ethstats.util.EthStatsConnectOptions;
import org.hyperledger.besu.metrics.MetricsService;
import org.hyperledger.besu.metrics.ObservableMetricsSystem;
import org.hyperledger.besu.metrics.prometheus.MetricsConfiguration;
import org.hyperledger.besu.nat.NatMethod;
import org.hyperledger.besu.nat.NatService;
import org.hyperledger.besu.nat.core.NatManager;
import org.hyperledger.besu.nat.docker.DockerDetector;
import org.hyperledger.besu.nat.docker.DockerNatManager;
import org.hyperledger.besu.nat.kubernetes.KubernetesDetector;
import org.hyperledger.besu.nat.kubernetes.KubernetesNatManager;
import org.hyperledger.besu.nat.upnp.UpnpNatManager;
import org.hyperledger.besu.plugin.BesuPlugin;
import org.hyperledger.besu.plugin.data.EnodeURL;
import org.hyperledger.besu.services.BesuPluginContextImpl;
import org.hyperledger.besu.services.PermissioningServiceImpl;
import org.hyperledger.besu.services.RpcEndpointServiceImpl;
import org.hyperledger.besu.util.NetworkUtility;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import graphql.GraphQL;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.units.bigints.UInt256;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The builder for Runner class. */
<span class="fc" id="L155">public class RunnerBuilder {</span>

<span class="fc" id="L157">  private static final Logger LOG = LoggerFactory.getLogger(RunnerBuilder.class);</span>

  private Vertx vertx;
  private BesuController besuController;

<span class="fc" id="L162">  private NetworkingConfiguration networkingConfiguration = NetworkingConfiguration.create();</span>
<span class="fc" id="L163">  private final Collection&lt;Bytes&gt; bannedNodeIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L164">  private boolean p2pEnabled = true;</span>
<span class="fc" id="L165">  private Optional&lt;TLSConfiguration&gt; p2pTLSConfiguration = Optional.empty();</span>
  private boolean discovery;
  private String p2pAdvertisedHost;
<span class="fc" id="L168">  private String p2pListenInterface = NetworkUtility.INADDR_ANY;</span>
  private int p2pListenPort;
<span class="fc" id="L170">  private NatMethod natMethod = NatMethod.AUTO;</span>
  private String natManagerServiceName;
  private boolean natMethodFallbackEnabled;
  private EthNetworkConfig ethNetworkConfig;
  private EthstatsOptions ethstatsOptions;
  private JsonRpcConfiguration jsonRpcConfiguration;
<span class="fc" id="L176">  private Optional&lt;JsonRpcConfiguration&gt; engineJsonRpcConfiguration = Optional.empty();</span>
  private GraphQLConfiguration graphQLConfiguration;
  private WebSocketConfiguration webSocketConfiguration;
  private ApiConfiguration apiConfiguration;
  private Path dataDir;
<span class="fc" id="L181">  private Optional&lt;Path&gt; pidPath = Optional.empty();</span>
  private MetricsConfiguration metricsConfiguration;
  private ObservableMetricsSystem metricsSystem;
  private PermissioningServiceImpl permissioningService;
<span class="fc" id="L185">  private Optional&lt;PermissioningConfiguration&gt; permissioningConfiguration = Optional.empty();</span>
<span class="fc" id="L186">  private Collection&lt;EnodeURL&gt; staticNodes = Collections.emptyList();</span>
<span class="fc" id="L187">  private Optional&lt;String&gt; identityString = Optional.empty();</span>
  private BesuPluginContextImpl besuPluginContext;
<span class="fc" id="L189">  private boolean autoLogBloomCaching = true;</span>
  private StorageProvider storageProvider;
  private RpcEndpointServiceImpl rpcEndpointServiceImpl;
  private JsonRpcIpcConfiguration jsonRpcIpcConfiguration;
  private boolean legacyForkIdEnabled;
  private Optional&lt;EnodeDnsConfiguration&gt; enodeDnsConfiguration;

  /**
   * Add Vertx.
   *
   * @param vertx the vertx instance
   * @return runner builder
   */
  public RunnerBuilder vertx(final Vertx vertx) {
<span class="fc" id="L203">    this.vertx = vertx;</span>
<span class="fc" id="L204">    return this;</span>
  }

  /**
   * Add Besu controller.
   *
   * @param besuController the besu controller
   * @return the runner builder
   */
  public RunnerBuilder besuController(final BesuController besuController) {
<span class="fc" id="L214">    this.besuController = besuController;</span>
<span class="fc" id="L215">    return this;</span>
  }

  /**
   * P2p enabled.
   *
   * @param p2pEnabled the p 2 p enabled
   * @return the runner builder
   */
  public RunnerBuilder p2pEnabled(final boolean p2pEnabled) {
<span class="fc" id="L225">    this.p2pEnabled = p2pEnabled;</span>
<span class="fc" id="L226">    return this;</span>
  }

  /**
   * TLSConfiguration p2pTLSConfiguration.
   *
   * @param p2pTLSConfiguration the TLSConfiguration p2pTLSConfiguration
   * @return the runner builder
   */
  public RunnerBuilder p2pTLSConfiguration(final TLSConfiguration p2pTLSConfiguration) {
<span class="nc" id="L236">    this.p2pTLSConfiguration = Optional.of(p2pTLSConfiguration);</span>
<span class="nc" id="L237">    return this;</span>
  }

  /**
   * Optional TLSConfiguration p2pTLSConfiguration.
   *
   * @param p2pTLSConfiguration the TLSConfiguration p2pTLSConfiguration
   * @return the runner builder
   */
  public RunnerBuilder p2pTLSConfiguration(final Optional&lt;TLSConfiguration&gt; p2pTLSConfiguration) {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">    if (null != p2pTLSConfiguration) {</span>
<span class="fc" id="L248">      this.p2pTLSConfiguration = p2pTLSConfiguration;</span>
    }
<span class="fc" id="L250">    return this;</span>
  }

  /**
   * Enable Discovery.
   *
   * @param discovery the discovery
   * @return the runner builder
   */
  public RunnerBuilder discovery(final boolean discovery) {
<span class="fc" id="L260">    this.discovery = discovery;</span>
<span class="fc" id="L261">    return this;</span>
  }

  /**
   * Add Eth network config.
   *
   * @param ethNetworkConfig the eth network config
   * @return the runner builder
   */
  public RunnerBuilder ethNetworkConfig(final EthNetworkConfig ethNetworkConfig) {
<span class="fc" id="L271">    this.ethNetworkConfig = ethNetworkConfig;</span>
<span class="fc" id="L272">    return this;</span>
  }

  /**
   * Add Networking configuration.
   *
   * @param networkingConfiguration the networking configuration
   * @return the runner builder
   */
  public RunnerBuilder networkingConfiguration(
      final NetworkingConfiguration networkingConfiguration) {
<span class="fc" id="L283">    this.networkingConfiguration = networkingConfiguration;</span>
<span class="fc" id="L284">    return this;</span>
  }

  /**
   * Add P2p advertised host.
   *
   * @param p2pAdvertisedHost the P2P advertised host
   * @return the runner builder
   */
  public RunnerBuilder p2pAdvertisedHost(final String p2pAdvertisedHost) {
<span class="fc" id="L294">    this.p2pAdvertisedHost = p2pAdvertisedHost;</span>
<span class="fc" id="L295">    return this;</span>
  }

  /**
   * Add P2P Listener interface ip/host name.
   *
   * @param ip the ip
   * @return the runner builder
   */
  public RunnerBuilder p2pListenInterface(final String ip) {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">    checkArgument(!isNull(ip), &quot;Invalid null value supplied for p2pListenInterface&quot;);</span>
<span class="fc" id="L306">    this.p2pListenInterface = ip;</span>
<span class="fc" id="L307">    return this;</span>
  }

  /**
   * Add P2P listen port.
   *
   * @param p2pListenPort the p 2 p listen port
   * @return the runner builder
   */
  public RunnerBuilder p2pListenPort(final int p2pListenPort) {
<span class="fc" id="L317">    this.p2pListenPort = p2pListenPort;</span>
<span class="fc" id="L318">    return this;</span>
  }

  /**
   * Add Nat method.
   *
   * @param natMethod the nat method
   * @return the runner builder
   */
  public RunnerBuilder natMethod(final NatMethod natMethod) {
<span class="fc" id="L328">    this.natMethod = natMethod;</span>
<span class="fc" id="L329">    return this;</span>
  }

  /**
   * Add Nat manager service name.
   *
   * @param natManagerServiceName the nat manager service name
   * @return the runner builder
   */
  public RunnerBuilder natManagerServiceName(final String natManagerServiceName) {
<span class="nc" id="L339">    this.natManagerServiceName = natManagerServiceName;</span>
<span class="nc" id="L340">    return this;</span>
  }

  /**
   * Enable Nat method fallback.
   *
   * @param natMethodFallbackEnabled the nat method fallback enabled
   * @return the runner builder
   */
  public RunnerBuilder natMethodFallbackEnabled(final boolean natMethodFallbackEnabled) {
<span class="nc" id="L350">    this.natMethodFallbackEnabled = natMethodFallbackEnabled;</span>
<span class="nc" id="L351">    return this;</span>
  }

  /**
   * Add EthStatsOptions
   *
   * @param ethstatsOptions the ethstats options
   * @return Runner builder instance
   */
  public RunnerBuilder ethstatsOptions(final EthstatsOptions ethstatsOptions) {
<span class="nc" id="L361">    this.ethstatsOptions = ethstatsOptions;</span>
<span class="nc" id="L362">    return this;</span>
  }

  /**
   * Add Json RPC configuration.
   *
   * @param jsonRpcConfiguration the json rpc configuration
   * @return the runner builder
   */
  public RunnerBuilder jsonRpcConfiguration(final JsonRpcConfiguration jsonRpcConfiguration) {
<span class="fc" id="L372">    this.jsonRpcConfiguration = jsonRpcConfiguration;</span>
<span class="fc" id="L373">    return this;</span>
  }

  /**
   * Add Engine json RPC configuration.
   *
   * @param engineJsonRpcConfiguration the engine json rpc configuration
   * @return the runner builder
   */
  public RunnerBuilder engineJsonRpcConfiguration(
      final JsonRpcConfiguration engineJsonRpcConfiguration) {
<span class="fc" id="L384">    this.engineJsonRpcConfiguration = Optional.ofNullable(engineJsonRpcConfiguration);</span>
<span class="fc" id="L385">    return this;</span>
  }

  /**
   * Add GraphQl configuration.
   *
   * @param graphQLConfiguration the graph ql configuration
   * @return the runner builder
   */
  public RunnerBuilder graphQLConfiguration(final GraphQLConfiguration graphQLConfiguration) {
<span class="fc" id="L395">    this.graphQLConfiguration = graphQLConfiguration;</span>
<span class="fc" id="L396">    return this;</span>
  }

  /**
   * Add Web socket configuration.
   *
   * @param webSocketConfiguration the web socket configuration
   * @return the runner builder
   */
  public RunnerBuilder webSocketConfiguration(final WebSocketConfiguration webSocketConfiguration) {
<span class="fc" id="L406">    this.webSocketConfiguration = webSocketConfiguration;</span>
<span class="fc" id="L407">    return this;</span>
  }

  /**
   * Add Api configuration.
   *
   * @param apiConfiguration the api configuration
   * @return the runner builder
   */
  public RunnerBuilder apiConfiguration(final ApiConfiguration apiConfiguration) {
<span class="fc" id="L417">    this.apiConfiguration = apiConfiguration;</span>
<span class="fc" id="L418">    return this;</span>
  }

  /**
   * Add Permissioning configuration.
   *
   * @param permissioningConfiguration the permissioning configuration
   * @return the runner builder
   */
  public RunnerBuilder permissioningConfiguration(
      final Optional&lt;PermissioningConfiguration&gt; permissioningConfiguration) {
<span class="fc" id="L429">    this.permissioningConfiguration = permissioningConfiguration;</span>
<span class="fc" id="L430">    return this;</span>
  }

  /**
   * Add pid path.
   *
   * @param pidPath the pid path
   * @return the runner builder
   */
  public RunnerBuilder pidPath(final Path pidPath) {
<span class="fc" id="L440">    this.pidPath = Optional.ofNullable(pidPath);</span>
<span class="fc" id="L441">    return this;</span>
  }

  /**
   * Add Data dir.
   *
   * @param dataDir the data dir
   * @return the runner builder
   */
  public RunnerBuilder dataDir(final Path dataDir) {
<span class="fc" id="L451">    this.dataDir = dataDir;</span>
<span class="fc" id="L452">    return this;</span>
  }

  /**
   * Add list of Banned node id.
   *
   * @param bannedNodeIds the banned node ids
   * @return the runner builder
   */
  public RunnerBuilder bannedNodeIds(final Collection&lt;Bytes&gt; bannedNodeIds) {
<span class="nc" id="L462">    this.bannedNodeIds.addAll(bannedNodeIds);</span>
<span class="nc" id="L463">    return this;</span>
  }

  /**
   * Add Metrics configuration.
   *
   * @param metricsConfiguration the metrics configuration
   * @return the runner builder
   */
  public RunnerBuilder metricsConfiguration(final MetricsConfiguration metricsConfiguration) {
<span class="fc" id="L473">    this.metricsConfiguration = metricsConfiguration;</span>
<span class="fc" id="L474">    return this;</span>
  }

  /**
   * Add Metrics system.
   *
   * @param metricsSystem the metrics system
   * @return the runner builder
   */
  public RunnerBuilder metricsSystem(final ObservableMetricsSystem metricsSystem) {
<span class="fc" id="L484">    this.metricsSystem = metricsSystem;</span>
<span class="fc" id="L485">    return this;</span>
  }

  /**
   * Add Permissioning service.
   *
   * @param permissioningService the permissioning service
   * @return the runner builder
   */
  public RunnerBuilder permissioningService(final PermissioningServiceImpl permissioningService) {
<span class="fc" id="L495">    this.permissioningService = permissioningService;</span>
<span class="fc" id="L496">    return this;</span>
  }

  /**
   * Add Static nodes collection.
   *
   * @param staticNodes the static nodes
   * @return the runner builder
   */
  public RunnerBuilder staticNodes(final Collection&lt;EnodeURL&gt; staticNodes) {
<span class="fc" id="L506">    this.staticNodes = staticNodes;</span>
<span class="fc" id="L507">    return this;</span>
  }

  /**
   * Add Node identity string.
   *
   * @param identityString the identity string
   * @return the runner builder
   */
  public RunnerBuilder identityString(final Optional&lt;String&gt; identityString) {
<span class="nc" id="L517">    this.identityString = identityString;</span>
<span class="nc" id="L518">    return this;</span>
  }

  /**
   * Add Besu plugin context.
   *
   * @param besuPluginContext the besu plugin context
   * @return the runner builder
   */
  public RunnerBuilder besuPluginContext(final BesuPluginContextImpl besuPluginContext) {
<span class="fc" id="L528">    this.besuPluginContext = besuPluginContext;</span>
<span class="fc" id="L529">    return this;</span>
  }

  /**
   * Enable Auto log bloom caching.
   *
   * @param autoLogBloomCaching the auto log bloom caching
   * @return the runner builder
   */
  public RunnerBuilder autoLogBloomCaching(final boolean autoLogBloomCaching) {
<span class="fc" id="L539">    this.autoLogBloomCaching = autoLogBloomCaching;</span>
<span class="fc" id="L540">    return this;</span>
  }

  /**
   * Add Storage provider.
   *
   * @param storageProvider the storage provider
   * @return the runner builder
   */
  public RunnerBuilder storageProvider(final StorageProvider storageProvider) {
<span class="fc" id="L550">    this.storageProvider = storageProvider;</span>
<span class="fc" id="L551">    return this;</span>
  }

  /**
   * Add Rpc endpoint service.
   *
   * @param rpcEndpointService the rpc endpoint service
   * @return the runner builder
   */
  public RunnerBuilder rpcEndpointService(final RpcEndpointServiceImpl rpcEndpointService) {
<span class="fc" id="L561">    this.rpcEndpointServiceImpl = rpcEndpointService;</span>
<span class="fc" id="L562">    return this;</span>
  }

  /**
   * Add Json Rpc Ipc configuration.
   *
   * @param jsonRpcIpcConfiguration the json rpc ipc configuration
   * @return the runner builder
   */
  public RunnerBuilder jsonRpcIpcConfiguration(
      final JsonRpcIpcConfiguration jsonRpcIpcConfiguration) {
<span class="fc" id="L573">    this.jsonRpcIpcConfiguration = jsonRpcIpcConfiguration;</span>
<span class="fc" id="L574">    return this;</span>
  }

  /**
   * Add enode DNS configuration
   *
   * @param enodeDnsConfiguration the DNS configuration for enodes
   * @return the runner builder
   */
  public RunnerBuilder enodeDnsConfiguration(final EnodeDnsConfiguration enodeDnsConfiguration) {
<span class="nc" id="L584">    this.enodeDnsConfiguration =</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        enodeDnsConfiguration != null ? Optional.of(enodeDnsConfiguration) : Optional.empty();</span>
<span class="nc" id="L586">    return this;</span>
  }

  /**
   * Build Runner instance.
   *
   * @return the runner
   */
  public Runner build() {

<span class="fc" id="L596">    Preconditions.checkNotNull(besuController);</span>

    final DiscoveryConfiguration discoveryConfiguration =
<span class="fc" id="L599">        DiscoveryConfiguration.create()</span>
<span class="fc" id="L600">            .setBindHost(p2pListenInterface)</span>
<span class="fc" id="L601">            .setBindPort(p2pListenPort)</span>
<span class="fc" id="L602">            .setAdvertisedHost(p2pAdvertisedHost);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">    if (discovery) {</span>
      final List&lt;EnodeURL&gt; bootstrap;
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">      if (ethNetworkConfig.getBootNodes() == null) {</span>
<span class="nc" id="L606">        bootstrap = EthNetworkConfig.getNetworkConfig(NetworkName.MAINNET).getBootNodes();</span>
      } else {
<span class="fc" id="L608">        bootstrap = ethNetworkConfig.getBootNodes();</span>
      }
<span class="fc" id="L610">      discoveryConfiguration.setBootnodes(bootstrap);</span>
<span class="fc" id="L611">      LOG.info(&quot;Resolved {} bootnodes.&quot;, bootstrap.size());</span>
<span class="fc" id="L612">      LOG.debug(&quot;Bootnodes = {}&quot;, bootstrap);</span>
<span class="fc" id="L613">      discoveryConfiguration.setDnsDiscoveryURL(ethNetworkConfig.getDnsDiscoveryUrl());</span>
<span class="fc" id="L614">      discoveryConfiguration.setDiscoveryV5Enabled(</span>
<span class="fc" id="L615">          networkingConfiguration.getDiscovery().isDiscoveryV5Enabled());</span>
<span class="fc" id="L616">      discoveryConfiguration.setFilterOnEnrForkId(</span>
<span class="fc" id="L617">          networkingConfiguration.getDiscovery().isFilterOnEnrForkIdEnabled());</span>
<span class="fc" id="L618">    } else {</span>
<span class="fc" id="L619">      discoveryConfiguration.setActive(false);</span>
    }

<span class="fc" id="L622">    final NodeKey nodeKey = besuController.getNodeKey();</span>

<span class="fc" id="L624">    final SubProtocolConfiguration subProtocolConfiguration =</span>
<span class="fc" id="L625">        besuController.getSubProtocolConfiguration();</span>

<span class="fc" id="L627">    final ProtocolSchedule protocolSchedule = besuController.getProtocolSchedule();</span>
<span class="fc" id="L628">    final ProtocolContext context = besuController.getProtocolContext();</span>

<span class="fc" id="L630">    final List&lt;SubProtocol&gt; subProtocols = subProtocolConfiguration.getSubProtocols();</span>
<span class="fc" id="L631">    final List&lt;ProtocolManager&gt; protocolManagers = subProtocolConfiguration.getProtocolManagers();</span>
<span class="fc" id="L632">    final Set&lt;Capability&gt; supportedCapabilities =</span>
<span class="fc" id="L633">        protocolManagers.stream()</span>
<span class="fc" id="L634">            .flatMap(protocolManager -&gt; protocolManager.getSupportedCapabilities().stream())</span>
<span class="fc" id="L635">            .collect(Collectors.toSet());</span>

    final RlpxConfiguration rlpxConfiguration =
<span class="fc" id="L638">        RlpxConfiguration.create()</span>
<span class="fc" id="L639">            .setBindHost(p2pListenInterface)</span>
<span class="fc" id="L640">            .setBindPort(p2pListenPort)</span>
<span class="fc" id="L641">            .setSupportedProtocols(subProtocols)</span>
<span class="fc" id="L642">            .setClientId(BesuInfo.nodeName(identityString));</span>
<span class="fc" id="L643">    networkingConfiguration.setRlpx(rlpxConfiguration).setDiscovery(discoveryConfiguration);</span>

<span class="fc" id="L645">    final PeerPermissionsDenylist bannedNodes = PeerPermissionsDenylist.create();</span>
<span class="fc" id="L646">    bannedNodeIds.forEach(bannedNodes::add);</span>

<span class="fc" id="L648">    final List&lt;EnodeURL&gt; bootnodes = discoveryConfiguration.getBootnodes();</span>

<span class="fc" id="L650">    final Synchronizer synchronizer = besuController.getSynchronizer();</span>

<span class="fc" id="L652">    final TransactionSimulator transactionSimulator =</span>
        new TransactionSimulator(
<span class="fc" id="L654">            context.getBlockchain(),</span>
<span class="fc" id="L655">            context.getWorldStateArchive(),</span>
            protocolSchedule,
<span class="fc" id="L657">            apiConfiguration.getGasCap());</span>

<span class="fc" id="L659">    final Bytes localNodeId = nodeKey.getPublicKey().getEncodedBytes();</span>
<span class="fc" id="L660">    final Optional&lt;NodePermissioningController&gt; nodePermissioningController =</span>
<span class="fc" id="L661">        buildNodePermissioningController(</span>
<span class="fc" id="L662">            bootnodes, synchronizer, transactionSimulator, localNodeId, context.getBlockchain());</span>

<span class="fc" id="L664">    final PeerPermissions peerPermissions =</span>
        nodePermissioningController
<span class="pc" id="L666">            .map(nodePC -&gt; new PeerPermissionsAdapter(nodePC, bootnodes, context.getBlockchain()))</span>
<span class="pc" id="L667">            .map(nodePerms -&gt; PeerPermissions.combine(nodePerms, bannedNodes))</span>
<span class="fc" id="L668">            .orElse(bannedNodes);</span>

<span class="fc" id="L670">    LOG.info(&quot;Detecting NAT service.&quot;);</span>
<span class="pc bpc" id="L671" title="1 of 4 branches missed.">    final boolean fallbackEnabled = natMethod == NatMethod.AUTO || natMethodFallbackEnabled;</span>
<span class="fc" id="L672">    final NatService natService = new NatService(buildNatManager(natMethod), fallbackEnabled);</span>
<span class="pc" id="L673">    final NetworkBuilder inactiveNetwork = caps -&gt; new NoopP2PNetwork();</span>
<span class="fc" id="L674">    final NetworkBuilder activeNetwork =</span>
        caps -&gt; {
<span class="fc" id="L676">          final EthPeers ethPeers = besuController.getEthPeers();</span>
<span class="fc" id="L677">          return DefaultP2PNetwork.builder()</span>
<span class="fc" id="L678">              .vertx(vertx)</span>
<span class="fc" id="L679">              .nodeKey(nodeKey)</span>
<span class="fc" id="L680">              .config(networkingConfiguration)</span>
<span class="fc" id="L681">              .legacyForkIdEnabled(legacyForkIdEnabled)</span>
<span class="fc" id="L682">              .peerPermissions(peerPermissions)</span>
<span class="fc" id="L683">              .metricsSystem(metricsSystem)</span>
<span class="fc" id="L684">              .supportedCapabilities(caps)</span>
<span class="fc" id="L685">              .natService(natService)</span>
<span class="fc" id="L686">              .storageProvider(storageProvider)</span>
<span class="fc" id="L687">              .p2pTLSConfiguration(p2pTLSConfiguration)</span>
<span class="fc" id="L688">              .blockchain(context.getBlockchain())</span>
<span class="fc" id="L689">              .blockNumberForks(besuController.getGenesisConfigOptions().getForkBlockNumbers())</span>
<span class="fc" id="L690">              .timestampForks(besuController.getGenesisConfigOptions().getForkBlockTimestamps())</span>
<span class="fc" id="L691">              .allConnectionsSupplier(ethPeers::getAllConnections)</span>
<span class="fc" id="L692">              .allActiveConnectionsSupplier(ethPeers::getAllActiveConnections)</span>
<span class="fc" id="L693">              .maxPeers(ethPeers.getMaxPeers())</span>
<span class="fc" id="L694">              .build();</span>
        };

    final NetworkRunner networkRunner =
<span class="fc" id="L698">        NetworkRunner.builder()</span>
<span class="fc" id="L699">            .protocolManagers(protocolManagers)</span>
<span class="fc" id="L700">            .subProtocols(subProtocols)</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">            .network(p2pEnabled ? activeNetwork : inactiveNetwork)</span>
<span class="fc" id="L702">            .metricsSystem(metricsSystem)</span>
<span class="fc" id="L703">            .build();</span>

<span class="fc" id="L705">    besuController.getEthPeers().setRlpxAgent(networkRunner.getRlpxAgent());</span>

<span class="fc" id="L707">    final P2PNetwork network = networkRunner.getNetwork();</span>
    // ForkId in Ethereum Node Record needs updating when we transition to a new protocol spec
<span class="fc" id="L709">    context</span>
<span class="fc" id="L710">        .getBlockchain()</span>
<span class="fc" id="L711">        .observeBlockAdded(</span>
            blockAddedEvent -&gt; {
<span class="fc bfc" id="L713" title="All 2 branches covered.">              if (protocolSchedule.isOnMilestoneBoundary(blockAddedEvent.getBlock().getHeader())) {</span>
<span class="fc" id="L714">                network.updateNodeRecord();</span>
              }
<span class="fc" id="L716">            });</span>
<span class="fc" id="L717">    nodePermissioningController.ifPresent(</span>
        n -&gt;
<span class="nc" id="L719">            n.setInsufficientPeersPermissioningProvider(</span>
                new InsufficientPeersPermissioningProvider(network, bootnodes)));

<span class="fc" id="L722">    final TransactionPool transactionPool = besuController.getTransactionPool();</span>
<span class="fc" id="L723">    final MiningCoordinator miningCoordinator = besuController.getMiningCoordinator();</span>

<span class="fc" id="L725">    final BlockchainQueries blockchainQueries =</span>
        new BlockchainQueries(
<span class="fc" id="L727">            context.getBlockchain(),</span>
<span class="fc" id="L728">            context.getWorldStateArchive(),</span>
<span class="fc" id="L729">            Optional.of(dataDir.resolve(CACHE_PATH)),</span>
<span class="fc" id="L730">            Optional.of(besuController.getProtocolManager().ethContext().getScheduler()),</span>
            apiConfiguration);

<span class="fc" id="L733">    final PrivacyParameters privacyParameters = besuController.getPrivacyParameters();</span>

<span class="fc" id="L735">    final FilterManager filterManager =</span>
        new FilterManagerBuilder()
<span class="fc" id="L737">            .blockchainQueries(blockchainQueries)</span>
<span class="fc" id="L738">            .transactionPool(transactionPool)</span>
<span class="fc" id="L739">            .privacyParameters(privacyParameters)</span>
<span class="fc" id="L740">            .build();</span>
<span class="fc" id="L741">    vertx.deployVerticle(filterManager);</span>

<span class="fc" id="L743">    createPrivateTransactionObserver(</span>
<span class="fc" id="L744">        filterManager, privacyParameters, context.getBlockchain().getGenesisBlockHeader());</span>

<span class="fc" id="L746">    final P2PNetwork peerNetwork = networkRunner.getNetwork();</span>

<span class="fc" id="L748">    final MiningParameters miningParameters = besuController.getMiningParameters();</span>
<span class="fc" id="L749">    Optional&lt;StratumServer&gt; stratumServer = Optional.empty();</span>

<span class="pc bpc" id="L751" title="1 of 2 branches missed.">    if (miningParameters.isStratumMiningEnabled()) {</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">      if (!(miningCoordinator instanceof PoWMiningCoordinator powMiningCoordinator)) {</span>
<span class="nc" id="L753">        throw new IllegalArgumentException(</span>
            &quot;Stratum server requires an PoWMiningCoordinator not &quot;
<span class="nc bnc" id="L755" title="All 2 branches missed.">                + ((miningCoordinator == null) ? &quot;null&quot; : miningCoordinator.getClass().getName()));</span>
      }
<span class="nc" id="L757">      stratumServer =</span>
<span class="nc" id="L758">          Optional.of(</span>
              new StratumServer(
                  vertx,
                  powMiningCoordinator,
<span class="nc" id="L762">                  miningParameters.getStratumPort(),</span>
<span class="nc" id="L763">                  miningParameters.getStratumNetworkInterface(),</span>
<span class="nc" id="L764">                  miningParameters.getUnstable().getStratumExtranonce(),</span>
                  metricsSystem));
<span class="nc" id="L766">      miningCoordinator.addEthHashObserver(stratumServer.get());</span>
<span class="nc" id="L767">      LOG.debug(&quot;added ethash observer: {}&quot;, stratumServer.get());</span>
    }

<span class="fc" id="L770">    sanitizePeers(network, staticNodes)</span>
<span class="fc" id="L771">        .map(DefaultPeer::fromEnodeURL)</span>
<span class="fc" id="L772">        .forEach(peerNetwork::addMaintainedConnectionPeer);</span>

<span class="fc" id="L774">    final Optional&lt;NodeLocalConfigPermissioningController&gt; nodeLocalConfigPermissioningController =</span>
<span class="fc" id="L775">        nodePermissioningController.flatMap(NodePermissioningController::localConfigController);</span>

<span class="fc" id="L777">    final Optional&lt;AccountPermissioningController&gt; accountPermissioningController =</span>
<span class="fc" id="L778">        buildAccountPermissioningController(</span>
            permissioningConfiguration, besuController, transactionSimulator);

    final Optional&lt;AccountLocalConfigPermissioningController&gt;
<span class="fc" id="L782">        accountLocalConfigPermissioningController =</span>
<span class="fc" id="L783">            accountPermissioningController.flatMap(</span>
                AccountPermissioningController::getAccountLocalConfigPermissioningController);

<span class="fc" id="L786">    Optional&lt;JsonRpcHttpService&gt; jsonRpcHttpService = Optional.empty();</span>

<span class="fc bfc" id="L788" title="All 2 branches covered.">    if (jsonRpcConfiguration.isEnabled()) {</span>
<span class="fc" id="L789">      final Map&lt;String, JsonRpcMethod&gt; nonEngineMethods =</span>
<span class="fc" id="L790">          jsonRpcMethods(</span>
              protocolSchedule,
              context,
              besuController,
              peerNetwork,
              blockchainQueries,
              synchronizer,
              transactionPool,
              miningParameters,
              miningCoordinator,
              metricsSystem,
              supportedCapabilities,
<span class="fc" id="L802">              jsonRpcConfiguration.getRpcApis().stream()</span>
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">                  .filter(apiGroup -&gt; !apiGroup.toLowerCase().startsWith(&quot;engine&quot;))</span>
<span class="fc" id="L804">                  .collect(Collectors.toList()),</span>
              filterManager,
              accountLocalConfigPermissioningController,
              nodeLocalConfigPermissioningController,
              privacyParameters,
              jsonRpcConfiguration,
              webSocketConfiguration,
              metricsConfiguration,
              natService,
<span class="fc" id="L813">              besuPluginContext.getNamedPlugins(),</span>
              dataDir,
              rpcEndpointServiceImpl);

<span class="fc" id="L817">      jsonRpcHttpService =</span>
<span class="fc" id="L818">          Optional.of(</span>
              new JsonRpcHttpService(
                  vertx,
                  dataDir,
                  jsonRpcConfiguration,
                  metricsSystem,
                  natService,
                  nonEngineMethods,
                  new HealthService(new LivenessCheck()),
                  new HealthService(new ReadinessCheck(peerNetwork, synchronizer))));
    }

<span class="fc" id="L830">    final SubscriptionManager subscriptionManager =</span>
<span class="fc" id="L831">        createSubscriptionManager(vertx, transactionPool, blockchainQueries);</span>

<span class="fc" id="L833">    Optional&lt;EngineJsonRpcService&gt; engineJsonRpcService = Optional.empty();</span>
<span class="fc bfc" id="L834" title="All 4 branches covered.">    if (engineJsonRpcConfiguration.isPresent() &amp;&amp; engineJsonRpcConfiguration.get().isEnabled()) {</span>
<span class="fc" id="L835">      final Map&lt;String, JsonRpcMethod&gt; engineMethods =</span>
<span class="fc" id="L836">          jsonRpcMethods(</span>
              protocolSchedule,
              context,
              besuController,
              peerNetwork,
              blockchainQueries,
              synchronizer,
              transactionPool,
              miningParameters,
              miningCoordinator,
              metricsSystem,
              supportedCapabilities,
<span class="fc" id="L848">              engineJsonRpcConfiguration.get().getRpcApis(),</span>
              filterManager,
              accountLocalConfigPermissioningController,
              nodeLocalConfigPermissioningController,
              privacyParameters,
<span class="fc" id="L853">              engineJsonRpcConfiguration.get(),</span>
              webSocketConfiguration,
              metricsConfiguration,
              natService,
<span class="fc" id="L857">              besuPluginContext.getNamedPlugins(),</span>
              dataDir,
              rpcEndpointServiceImpl);

      final Optional&lt;AuthenticationService&gt; authToUse =
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">          engineJsonRpcConfiguration.get().isAuthenticationEnabled()</span>
<span class="fc" id="L863">              ? Optional.of(</span>
                  new EngineAuthService(
                      vertx,
<span class="fc" id="L866">                      Optional.ofNullable(</span>
<span class="fc" id="L867">                          engineJsonRpcConfiguration.get().getAuthenticationPublicKeyFile()),</span>
                      dataDir))
<span class="pc" id="L869">              : Optional.empty();</span>

      final WebSocketConfiguration engineSocketConfig =
<span class="fc bfc" id="L872" title="All 2 branches covered.">          webSocketConfiguration.isEnabled()</span>
<span class="fc" id="L873">              ? webSocketConfiguration</span>
<span class="fc" id="L874">              : WebSocketConfiguration.createEngineDefault();</span>

<span class="fc" id="L876">      final WebSocketMethodsFactory websocketMethodsFactory =</span>
          new WebSocketMethodsFactory(subscriptionManager, engineMethods);

<span class="fc" id="L879">      engineJsonRpcService =</span>
<span class="fc" id="L880">          Optional.of(</span>
              new EngineJsonRpcService(
                  vertx,
                  dataDir,
<span class="fc" id="L884">                  engineJsonRpcConfiguration.orElse(JsonRpcConfiguration.createEngineDefault()),</span>
                  metricsSystem,
                  natService,
<span class="fc" id="L887">                  websocketMethodsFactory.methods(),</span>
<span class="fc" id="L888">                  Optional.ofNullable(engineSocketConfig),</span>
<span class="fc" id="L889">                  besuController.getProtocolManager().ethContext().getScheduler(),</span>
                  authToUse,
                  new HealthService(new LivenessCheck()),
                  new HealthService(new ReadinessCheck(peerNetwork, synchronizer))));
    }

<span class="fc" id="L895">    Optional&lt;GraphQLHttpService&gt; graphQLHttpService = Optional.empty();</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">    if (graphQLConfiguration.isEnabled()) {</span>
<span class="nc" id="L897">      final GraphQLDataFetchers fetchers = new GraphQLDataFetchers(supportedCapabilities);</span>
<span class="nc" id="L898">      final Map&lt;GraphQLContextType, Object&gt; graphQlContextMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L899">      graphQlContextMap.putIfAbsent(GraphQLContextType.BLOCKCHAIN_QUERIES, blockchainQueries);</span>
<span class="nc" id="L900">      graphQlContextMap.putIfAbsent(GraphQLContextType.PROTOCOL_SCHEDULE, protocolSchedule);</span>
<span class="nc" id="L901">      graphQlContextMap.putIfAbsent(GraphQLContextType.TRANSACTION_POOL, transactionPool);</span>
<span class="nc" id="L902">      graphQlContextMap.putIfAbsent(GraphQLContextType.MINING_COORDINATOR, miningCoordinator);</span>
<span class="nc" id="L903">      graphQlContextMap.putIfAbsent(GraphQLContextType.SYNCHRONIZER, synchronizer);</span>
<span class="nc" id="L904">      graphQlContextMap.putIfAbsent(</span>
<span class="nc" id="L905">          GraphQLContextType.CHAIN_ID, protocolSchedule.getChainId().map(UInt256::valueOf));</span>
<span class="nc" id="L906">      graphQlContextMap.putIfAbsent(GraphQLContextType.GAS_CAP, apiConfiguration.getGasCap());</span>
      final GraphQL graphQL;
      try {
<span class="nc" id="L909">        graphQL = GraphQLProvider.buildGraphQL(fetchers);</span>
<span class="nc" id="L910">      } catch (final IOException ioe) {</span>
<span class="nc" id="L911">        throw new RuntimeException(ioe);</span>
<span class="nc" id="L912">      }</span>

<span class="nc" id="L914">      graphQLHttpService =</span>
<span class="nc" id="L915">          Optional.of(</span>
              new GraphQLHttpService(
                  vertx,
                  dataDir,
                  graphQLConfiguration,
                  graphQL,
                  graphQlContextMap,
<span class="nc" id="L922">                  besuController.getProtocolManager().ethContext().getScheduler()));</span>
    }

<span class="fc" id="L925">    Optional&lt;WebSocketService&gt; webSocketService = Optional.empty();</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">    if (webSocketConfiguration.isEnabled()) {</span>
<span class="fc" id="L927">      final Map&lt;String, JsonRpcMethod&gt; nonEngineMethods =</span>
<span class="fc" id="L928">          jsonRpcMethods(</span>
              protocolSchedule,
              context,
              besuController,
              peerNetwork,
              blockchainQueries,
              synchronizer,
              transactionPool,
              miningParameters,
              miningCoordinator,
              metricsSystem,
              supportedCapabilities,
<span class="fc" id="L940">              webSocketConfiguration.getRpcApis().stream()</span>
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">                  .filter(apiGroup -&gt; !apiGroup.toLowerCase().startsWith(&quot;engine&quot;))</span>
<span class="fc" id="L942">                  .collect(Collectors.toList()),</span>
              filterManager,
              accountLocalConfigPermissioningController,
              nodeLocalConfigPermissioningController,
              privacyParameters,
              jsonRpcConfiguration,
              webSocketConfiguration,
              metricsConfiguration,
              natService,
<span class="fc" id="L951">              besuPluginContext.getNamedPlugins(),</span>
              dataDir,
              rpcEndpointServiceImpl);

<span class="fc" id="L955">      createLogsSubscriptionService(</span>
<span class="fc" id="L956">          context.getBlockchain(),</span>
<span class="fc" id="L957">          context.getWorldStateArchive(),</span>
          subscriptionManager,
          privacyParameters);

<span class="fc" id="L961">      createNewBlockHeadersSubscriptionService(</span>
<span class="fc" id="L962">          context.getBlockchain(), blockchainQueries, subscriptionManager);</span>

<span class="fc" id="L964">      createSyncingSubscriptionService(synchronizer, subscriptionManager);</span>

<span class="fc" id="L966">      webSocketService =</span>
<span class="fc" id="L967">          Optional.of(</span>
<span class="fc" id="L968">              createWebsocketService(</span>
                  vertx,
                  webSocketConfiguration,
                  subscriptionManager,
                  nonEngineMethods,
                  privacyParameters,
                  protocolSchedule,
                  blockchainQueries,
<span class="fc" id="L976">                  DefaultAuthenticationService.create(vertx, webSocketConfiguration),</span>
                  metricsSystem));

<span class="fc" id="L979">      createPrivateTransactionObserver(</span>
<span class="fc" id="L980">          subscriptionManager, privacyParameters, context.getBlockchain().getGenesisBlockHeader());</span>
    }

<span class="fc" id="L983">    final Optional&lt;MetricsService&gt; metricsService =</span>
<span class="fc" id="L984">        createMetricsService(vertx, metricsConfiguration);</span>

    final Optional&lt;EthStatsService&gt; ethStatsService;
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">    if (isEthStatsEnabled()) {</span>
<span class="nc" id="L988">      ethStatsService =</span>
<span class="nc" id="L989">          Optional.of(</span>
              new EthStatsService(
<span class="nc" id="L991">                  EthStatsConnectOptions.fromParams(</span>
<span class="nc" id="L992">                      ethstatsOptions.getEthstatsUrl(),</span>
<span class="nc" id="L993">                      ethstatsOptions.getEthstatsContact(),</span>
<span class="nc" id="L994">                      ethstatsOptions.getEthstatsCaCert()),</span>
                  blockchainQueries,
<span class="nc" id="L996">                  besuController.getProtocolManager(),</span>
                  transactionPool,
                  miningCoordinator,
<span class="nc" id="L999">                  besuController.getSyncState(),</span>
                  vertx,
<span class="nc" id="L1001">                  BesuInfo.nodeName(identityString),</span>
<span class="nc" id="L1002">                  besuController.getGenesisConfigOptions(),</span>
                  network));
    } else {
<span class="fc" id="L1005">      ethStatsService = Optional.empty();</span>
    }

    final Optional&lt;JsonRpcIpcService&gt; jsonRpcIpcService;
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">    if (jsonRpcIpcConfiguration.isEnabled()) {</span>
<span class="nc" id="L1010">      final Map&lt;String, JsonRpcMethod&gt; ipcMethods =</span>
<span class="nc" id="L1011">          jsonRpcMethods(</span>
              protocolSchedule,
              context,
              besuController,
              peerNetwork,
              blockchainQueries,
              synchronizer,
              transactionPool,
              miningParameters,
              miningCoordinator,
              metricsSystem,
              supportedCapabilities,
<span class="nc" id="L1023">              jsonRpcIpcConfiguration.getEnabledApis().stream()</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                  .filter(apiGroup -&gt; !apiGroup.toLowerCase().startsWith(&quot;engine&quot;))</span>
<span class="nc" id="L1025">                  .collect(Collectors.toList()),</span>
              filterManager,
              accountLocalConfigPermissioningController,
              nodeLocalConfigPermissioningController,
              privacyParameters,
              jsonRpcConfiguration,
              webSocketConfiguration,
              metricsConfiguration,
              natService,
<span class="nc" id="L1034">              besuPluginContext.getNamedPlugins(),</span>
              dataDir,
              rpcEndpointServiceImpl);

<span class="nc" id="L1038">      jsonRpcIpcService =</span>
<span class="nc" id="L1039">          Optional.of(</span>
              new JsonRpcIpcService(
                  vertx,
<span class="nc" id="L1042">                  jsonRpcIpcConfiguration.getPath(),</span>
                  new JsonRpcExecutor(new BaseJsonRpcProcessor(), ipcMethods)));
<span class="nc" id="L1044">    } else {</span>
<span class="fc" id="L1045">      jsonRpcIpcService = Optional.empty();</span>
    }

<span class="fc" id="L1048">    return new Runner(</span>
        vertx,
        networkRunner,
        natService,
        jsonRpcHttpService,
        engineJsonRpcService,
        graphQLHttpService,
        webSocketService,
        jsonRpcIpcService,
        stratumServer,
        metricsService,
        ethStatsService,
        besuController,
        dataDir,
        pidPath,
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        autoLogBloomCaching ? blockchainQueries.getTransactionLogBloomCacher() : Optional.empty(),</span>
<span class="fc" id="L1064">        context.getBlockchain());</span>
  }

  private boolean isEthStatsEnabled() {
<span class="pc bpc" id="L1068" title="3 of 4 branches missed.">    return ethstatsOptions != null &amp;&amp; !Strings.isNullOrEmpty(ethstatsOptions.getEthstatsUrl());</span>
  }

  private Stream&lt;EnodeURL&gt; sanitizePeers(
      final P2PNetwork network, final Collection&lt;EnodeURL&gt; enodeURLS) {
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">    if (network.getLocalEnode().isEmpty()) {</span>
<span class="fc" id="L1074">      return enodeURLS.stream();</span>
    }
<span class="nc" id="L1076">    final EnodeURL localEnodeURL = network.getLocalEnode().get();</span>
<span class="nc" id="L1077">    return enodeURLS.stream()</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        .filter(enodeURL -&gt; !enodeURL.getNodeId().equals(localEnodeURL.getNodeId()));</span>
  }

  private Optional&lt;NodePermissioningController&gt; buildNodePermissioningController(
      final List&lt;EnodeURL&gt; bootnodesAsEnodeURLs,
      final Synchronizer synchronizer,
      final TransactionSimulator transactionSimulator,
      final Bytes localNodeId,
      final Blockchain blockchain) {
<span class="fc" id="L1087">    final Collection&lt;EnodeURL&gt; fixedNodes = getFixedNodes(bootnodesAsEnodeURLs, staticNodes);</span>

<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">    if (permissioningConfiguration.isPresent()) {</span>
<span class="nc" id="L1090">      final PermissioningConfiguration configuration = this.permissioningConfiguration.get();</span>
<span class="nc" id="L1091">      final NodePermissioningController nodePermissioningController =</span>
          new NodePermissioningControllerFactory()
<span class="nc" id="L1093">              .create(</span>
                  configuration,
                  synchronizer,
                  fixedNodes,
                  localNodeId,
                  transactionSimulator,
                  metricsSystem,
                  blockchain,
<span class="nc" id="L1101">                  permissioningService.getConnectionPermissioningProviders());</span>

<span class="nc" id="L1103">      return Optional.of(nodePermissioningController);</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">    } else if (permissioningService.getConnectionPermissioningProviders().size() &gt; 0) {</span>
<span class="nc" id="L1105">      final NodePermissioningController nodePermissioningController =</span>
          new NodePermissioningControllerFactory()
<span class="nc" id="L1107">              .create(</span>
<span class="nc" id="L1108">                  new PermissioningConfiguration(Optional.empty(), Optional.empty()),</span>
                  synchronizer,
                  fixedNodes,
                  localNodeId,
                  transactionSimulator,
                  metricsSystem,
                  blockchain,
<span class="nc" id="L1115">                  permissioningService.getConnectionPermissioningProviders());</span>

<span class="nc" id="L1117">      return Optional.of(nodePermissioningController);</span>
    } else {
<span class="fc" id="L1119">      return Optional.empty();</span>
    }
  }

  private Optional&lt;AccountPermissioningController&gt; buildAccountPermissioningController(
      final Optional&lt;PermissioningConfiguration&gt; permissioningConfiguration,
      final BesuController besuController,
      final TransactionSimulator transactionSimulator) {

<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">    if (permissioningConfiguration.isPresent()) {</span>
<span class="nc" id="L1129">      final Optional&lt;AccountPermissioningController&gt; accountPermissioningController =</span>
<span class="nc" id="L1130">          AccountPermissioningControllerFactory.create(</span>
<span class="nc" id="L1131">              permissioningConfiguration.get(), transactionSimulator, metricsSystem);</span>

<span class="nc" id="L1133">      accountPermissioningController.ifPresent(</span>
          permissioningController -&gt;
<span class="nc" id="L1135">              besuController</span>
<span class="nc" id="L1136">                  .getProtocolSchedule()</span>
<span class="nc" id="L1137">                  .setPermissionTransactionFilter(permissioningController::isPermitted));</span>

<span class="nc" id="L1139">      return accountPermissioningController;</span>
    } else {
<span class="fc" id="L1141">      return Optional.empty();</span>
    }
  }

  private Optional&lt;NatManager&gt; buildNatManager(final NatMethod natMethod) {

<span class="fc" id="L1147">    final NatMethod detectedNatMethod =</span>
<span class="fc" id="L1148">        Optional.of(natMethod)</span>
<span class="fc" id="L1149">            .filter(not(isEqual(NatMethod.AUTO)))</span>
<span class="fc" id="L1150">            .orElse(NatService.autoDetectNatMethod(new KubernetesDetector(), new DockerDetector()));</span>
<span class="pc bpc" id="L1151" title="3 of 4 branches missed.">    switch (detectedNatMethod) {</span>
      case UPNP:
<span class="nc" id="L1153">        return Optional.of(new UpnpNatManager());</span>
      case DOCKER:
<span class="nc" id="L1155">        return Optional.of(</span>
<span class="nc" id="L1156">            new DockerNatManager(p2pAdvertisedHost, p2pListenPort, jsonRpcConfiguration.getPort()));</span>
      case KUBERNETES:
<span class="nc" id="L1158">        return Optional.of(new KubernetesNatManager(natManagerServiceName));</span>
      case NONE:
      default:
<span class="fc" id="L1161">        return Optional.empty();</span>
    }
  }

  /**
   * Gets fixed nodes. Visible for testing.
   *
   * @param someFixedNodes the fixed nodes
   * @param moreFixedNodes nodes added to fixed nodes
   * @return the fixed and more nodes combined
   */
  @VisibleForTesting
  public static Collection&lt;EnodeURL&gt; getFixedNodes(
      final Collection&lt;EnodeURL&gt; someFixedNodes, final Collection&lt;EnodeURL&gt; moreFixedNodes) {
<span class="fc" id="L1175">    final Collection&lt;EnodeURL&gt; fixedNodes = new ArrayList&lt;&gt;(someFixedNodes);</span>
<span class="fc" id="L1176">    fixedNodes.addAll(moreFixedNodes);</span>
<span class="fc" id="L1177">    return fixedNodes;</span>
  }

  private Map&lt;String, JsonRpcMethod&gt; jsonRpcMethods(
      final ProtocolSchedule protocolSchedule,
      final ProtocolContext protocolContext,
      final BesuController besuController,
      final P2PNetwork network,
      final BlockchainQueries blockchainQueries,
      final Synchronizer synchronizer,
      final TransactionPool transactionPool,
      final MiningParameters miningParameters,
      final MiningCoordinator miningCoordinator,
      final ObservableMetricsSystem metricsSystem,
      final Set&lt;Capability&gt; supportedCapabilities,
      final Collection&lt;String&gt; jsonRpcApis,
      final FilterManager filterManager,
      final Optional&lt;AccountLocalConfigPermissioningController&gt; accountAllowlistController,
      final Optional&lt;NodeLocalConfigPermissioningController&gt; nodeAllowlistController,
      final PrivacyParameters privacyParameters,
      final JsonRpcConfiguration jsonRpcConfiguration,
      final WebSocketConfiguration webSocketConfiguration,
      final MetricsConfiguration metricsConfiguration,
      final NatService natService,
      final Map&lt;String, BesuPlugin&gt; namedPlugins,
      final Path dataDir,
      final RpcEndpointServiceImpl rpcEndpointServiceImpl) {
    // sync vertx for engine consensus API, to process requests in FIFO order;
<span class="fc" id="L1205">    final Vertx consensusEngineServer = Vertx.vertx(new VertxOptions().setWorkerPoolSize(1));</span>

<span class="fc" id="L1207">    final Map&lt;String, JsonRpcMethod&gt; methods =</span>
        new JsonRpcMethodsFactory()
<span class="fc" id="L1209">            .methods(</span>
<span class="fc" id="L1210">                BesuInfo.nodeName(identityString),</span>
<span class="fc" id="L1211">                ethNetworkConfig.getNetworkId(),</span>
<span class="fc" id="L1212">                besuController.getGenesisConfigOptions(),</span>
                network,
                blockchainQueries,
                synchronizer,
                protocolSchedule,
                protocolContext,
                filterManager,
                transactionPool,
                miningParameters,
                miningCoordinator,
                metricsSystem,
                supportedCapabilities,
                accountAllowlistController,
                nodeAllowlistController,
                jsonRpcApis,
                privacyParameters,
                jsonRpcConfiguration,
                webSocketConfiguration,
                metricsConfiguration,
                natService,
                namedPlugins,
                dataDir,
<span class="fc" id="L1234">                besuController.getProtocolManager().ethContext().getEthPeers(),</span>
                consensusEngineServer,
                apiConfiguration,
                enodeDnsConfiguration);
<span class="fc" id="L1238">    methods.putAll(besuController.getAdditionalJsonRpcMethods(jsonRpcApis));</span>

<span class="fc" id="L1240">    final var pluginMethods =</span>
<span class="fc" id="L1241">        rpcEndpointServiceImpl.getPluginMethods(jsonRpcConfiguration.getRpcApis());</span>

<span class="fc" id="L1243">    final var overriddenMethods =</span>
<span class="fc" id="L1244">        methods.keySet().stream().filter(pluginMethods::containsKey).collect(Collectors.toList());</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">    if (overriddenMethods.size() &gt; 0) {</span>
<span class="nc" id="L1246">      throw new RuntimeException(&quot;You can not override built in methods &quot; + overriddenMethods);</span>
    }

<span class="fc" id="L1249">    methods.putAll(pluginMethods);</span>
<span class="fc" id="L1250">    return methods;</span>
  }

  private SubscriptionManager createSubscriptionManager(
      final Vertx vertx,
      final TransactionPool transactionPool,
      final BlockchainQueries blockchainQueries) {
<span class="fc" id="L1257">    final SubscriptionManager subscriptionManager =</span>
<span class="fc" id="L1258">        new SubscriptionManager(metricsSystem, blockchainQueries.getBlockchain());</span>
<span class="fc" id="L1259">    final PendingTransactionSubscriptionService pendingTransactions =</span>
        new PendingTransactionSubscriptionService(subscriptionManager);
<span class="fc" id="L1261">    final PendingTransactionDroppedSubscriptionService pendingTransactionsRemoved =</span>
        new PendingTransactionDroppedSubscriptionService(subscriptionManager);
<span class="fc" id="L1263">    transactionPool.subscribePendingTransactions(pendingTransactions);</span>
<span class="fc" id="L1264">    transactionPool.subscribeDroppedTransactions(pendingTransactionsRemoved);</span>
<span class="fc" id="L1265">    vertx.deployVerticle(subscriptionManager);</span>

<span class="fc" id="L1267">    return subscriptionManager;</span>
  }

  private void createLogsSubscriptionService(
      final Blockchain blockchain,
      final WorldStateArchive worldStateArchive,
      final SubscriptionManager subscriptionManager,
      final PrivacyParameters privacyParameters) {

<span class="fc" id="L1276">    Optional&lt;PrivacyQueries&gt; privacyQueries = Optional.empty();</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">    if (privacyParameters.isEnabled()) {</span>
<span class="nc" id="L1278">      final BlockchainQueries blockchainQueries =</span>
          new BlockchainQueries(
<span class="nc" id="L1280">              blockchain, worldStateArchive, Optional.empty(), Optional.empty(), apiConfiguration);</span>
<span class="nc" id="L1281">      privacyQueries =</span>
<span class="nc" id="L1282">          Optional.of(</span>
              new PrivacyQueries(
<span class="nc" id="L1284">                  blockchainQueries, privacyParameters.getPrivateWorldStateReader()));</span>
    }

<span class="fc" id="L1287">    final LogsSubscriptionService logsSubscriptionService =</span>
        new LogsSubscriptionService(subscriptionManager, privacyQueries);

    // monitoring public logs
<span class="fc" id="L1291">    blockchain.observeLogs(logsSubscriptionService);</span>

    // monitoring private logs
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">    if (privacyParameters.isEnabled()) {</span>
<span class="nc" id="L1295">      blockchain.observeBlockAdded(logsSubscriptionService::checkPrivateLogs);</span>
    }
<span class="fc" id="L1297">  }</span>

  private void createPrivateTransactionObserver(
      final PrivateTransactionObserver privateTransactionObserver,
      final PrivacyParameters privacyParameters,
      final BlockHeader genesisBlockHeader) {
    // register privateTransactionObserver as observer of events fired by the flexible precompile.
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">    if (privacyParameters.isFlexiblePrivacyGroupsEnabled()</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        &amp;&amp; privacyParameters.isMultiTenancyEnabled()) {</span>
<span class="nc" id="L1306">      final FlexiblePrivacyPrecompiledContract flexiblePrivacyPrecompiledContract =</span>
          (FlexiblePrivacyPrecompiledContract)
              besuController
<span class="nc" id="L1309">                  .getProtocolSchedule()</span>
<span class="nc" id="L1310">                  .getByBlockHeader(genesisBlockHeader)</span>
<span class="nc" id="L1311">                  .getPrecompileContractRegistry()</span>
<span class="nc" id="L1312">                  .get(FLEXIBLE_PRIVACY);</span>

<span class="nc" id="L1314">      flexiblePrivacyPrecompiledContract.addPrivateTransactionObserver(privateTransactionObserver);</span>
    }
<span class="fc" id="L1316">  }</span>

  private void createSyncingSubscriptionService(
      final Synchronizer synchronizer, final SubscriptionManager subscriptionManager) {
<span class="fc" id="L1320">    new SyncingSubscriptionService(subscriptionManager, synchronizer);</span>
<span class="fc" id="L1321">  }</span>

  private void createNewBlockHeadersSubscriptionService(
      final Blockchain blockchain,
      final BlockchainQueries blockchainQueries,
      final SubscriptionManager subscriptionManager) {
<span class="fc" id="L1327">    final NewBlockHeadersSubscriptionService newBlockHeadersSubscriptionService =</span>
        new NewBlockHeadersSubscriptionService(subscriptionManager, blockchainQueries);

<span class="fc" id="L1330">    blockchain.observeBlockAdded(newBlockHeadersSubscriptionService);</span>
<span class="fc" id="L1331">  }</span>

  private WebSocketService createWebsocketService(
      final Vertx vertx,
      final WebSocketConfiguration configuration,
      final SubscriptionManager subscriptionManager,
      final Map&lt;String, JsonRpcMethod&gt; jsonRpcMethods,
      final PrivacyParameters privacyParameters,
      final ProtocolSchedule protocolSchedule,
      final BlockchainQueries blockchainQueries,
      final Optional&lt;AuthenticationService&gt; authenticationService,
      final ObservableMetricsSystem metricsSystem) {

<span class="fc" id="L1344">    final WebSocketMethodsFactory websocketMethodsFactory =</span>
        new WebSocketMethodsFactory(subscriptionManager, jsonRpcMethods);

<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">    if (privacyParameters.isEnabled()) {</span>
<span class="nc" id="L1348">      final PrivateWebSocketMethodsFactory privateWebSocketMethodsFactory =</span>
          new PrivateWebSocketMethodsFactory(
              privacyParameters, subscriptionManager, protocolSchedule, blockchainQueries);

<span class="nc" id="L1352">      privateWebSocketMethodsFactory.methods().forEach(websocketMethodsFactory::addMethods);</span>
    }

<span class="fc" id="L1355">    rpcEndpointServiceImpl</span>
<span class="fc" id="L1356">        .getPluginMethods(configuration.getRpcApis())</span>
<span class="fc" id="L1357">        .values()</span>
<span class="pc" id="L1358">        .forEach(websocketMethodsFactory::addMethods);</span>

    final JsonRpcProcessor jsonRpcProcessor;
<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">    if (authenticationService.isPresent()) {</span>
<span class="nc" id="L1362">      jsonRpcProcessor =</span>
          new AuthenticatedJsonRpcProcessor(
              new BaseJsonRpcProcessor(),
<span class="nc" id="L1365">              authenticationService.get(),</span>
<span class="nc" id="L1366">              configuration.getRpcApisNoAuth());</span>
    } else {
<span class="fc" id="L1368">      jsonRpcProcessor = new BaseJsonRpcProcessor();</span>
    }
<span class="fc" id="L1370">    final JsonRpcExecutor jsonRpcExecutor =</span>
<span class="fc" id="L1371">        new JsonRpcExecutor(jsonRpcProcessor, websocketMethodsFactory.methods());</span>
<span class="fc" id="L1372">    final WebSocketMessageHandler websocketMessageHandler =</span>
        new WebSocketMessageHandler(
            vertx,
            jsonRpcExecutor,
<span class="fc" id="L1376">            besuController.getProtocolManager().ethContext().getScheduler(),</span>
<span class="fc" id="L1377">            webSocketConfiguration.getTimeoutSec());</span>

<span class="fc" id="L1379">    return new WebSocketService(</span>
        vertx, configuration, websocketMessageHandler, authenticationService, metricsSystem);
  }

  private Optional&lt;MetricsService&gt; createMetricsService(
      final Vertx vertx, final MetricsConfiguration configuration) {
<span class="fc" id="L1385">    return MetricsService.create(vertx, configuration, metricsSystem);</span>
  }

  /**
   * Add Legacy fork id.
   *
   * @param legacyEth64ForkIdEnabled the legacy eth64 fork id enabled
   * @return the runner builder
   */
  public RunnerBuilder legacyForkId(final boolean legacyEth64ForkIdEnabled) {
<span class="nc" id="L1395">    this.legacyForkIdEnabled = legacyEth64ForkIdEnabled;</span>
<span class="nc" id="L1396">    return this;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>