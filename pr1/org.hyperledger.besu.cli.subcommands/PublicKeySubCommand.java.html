<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PublicKeySubCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.cli.subcommands</a> &gt; <span class="el_source">PublicKeySubCommand.java</span></div><h1>PublicKeySubCommand.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.cli.subcommands;

import static com.google.common.base.Preconditions.checkNotNull;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.hyperledger.besu.cli.subcommands.PublicKeySubCommand.COMMAND_NAME;

import org.hyperledger.besu.cli.BesuCommand;
import org.hyperledger.besu.cli.DefaultCommandValues;
import org.hyperledger.besu.cli.options.stable.NodePrivateKeyFileOption;
import org.hyperledger.besu.cli.subcommands.PublicKeySubCommand.AddressSubCommand;
import org.hyperledger.besu.cli.subcommands.PublicKeySubCommand.ExportSubCommand;
import org.hyperledger.besu.cli.util.VersionProvider;
import org.hyperledger.besu.crypto.KeyPair;
import org.hyperledger.besu.crypto.SignatureAlgorithmFactory;
import org.hyperledger.besu.crypto.SignatureAlgorithmType;
import org.hyperledger.besu.ethereum.core.Util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Mixin;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.Option;
import picocli.CommandLine.ParentCommand;
import picocli.CommandLine.Spec;

/** Node's public key related sub-command */
@Command(
    name = COMMAND_NAME,
    description = &quot;This command provides node public key related actions.&quot;,
    mixinStandardHelpOptions = true,
    versionProvider = VersionProvider.class,
    subcommands = {ExportSubCommand.class, AddressSubCommand.class})
public class PublicKeySubCommand implements Runnable {
<span class="fc" id="L58">  private static final Logger LOG = LoggerFactory.getLogger(PublicKeySubCommand.class);</span>

  /** The constant COMMAND_NAME. */
  public static final String COMMAND_NAME = &quot;public-key&quot;;

  @SuppressWarnings(&quot;unused&quot;)
  @ParentCommand
  private BesuCommand parentCommand; // Picocli injects reference to parent command

  @SuppressWarnings(&quot;unused&quot;)
  @Spec
  private CommandSpec spec; // Picocli injects reference to command spec

  private final PrintWriter out;

  /**
   * Instantiates a new Public key sub command.
   *
   * @param out the out
   */
<span class="fc" id="L78">  public PublicKeySubCommand(final PrintWriter out) {</span>
<span class="fc" id="L79">    this.out = out;</span>
<span class="fc" id="L80">  }</span>

  @Override
  public void run() {
<span class="fc" id="L84">    spec.commandLine().usage(out);</span>
<span class="fc" id="L85">  }</span>

  /**
   * Public key export sub-command
   *
   * &lt;p&gt;Export of the public key is writing the key to the standard output by default. An option
   * enables to write it in a file. Indeed, a direct output of the value to standard out is not
   * always recommended as reading can be made difficult as the value can be mixed with other
   * information like logs that are in KeyPairUtil that is inevitable.
   */
  @Command(
      name = &quot;export&quot;,
      description = &quot;This command outputs the node public key. Default output is standard output.&quot;,
      mixinStandardHelpOptions = true,
      versionProvider = VersionProvider.class)
<span class="fc" id="L100">  static class ExportSubCommand extends KeyPairSubcommand implements Runnable {</span>

<span class="fc" id="L102">    @Option(</span>
        names = &quot;--to&quot;,
        paramLabel = DefaultCommandValues.MANDATORY_FILE_FORMAT_HELP,
        description = &quot;File to write public key to instead of standard output&quot;,
        arity = &quot;1..1&quot;)
    private final File publicKeyExportFile = null;

    @Override
    public void run() {
<span class="fc" id="L111">      configureEcCurve(ecCurve, parentCommand.spec.commandLine());</span>
<span class="fc" id="L112">      run(publicKeyExportFile, keyPair -&gt; keyPair.getPublicKey().toString());</span>
<span class="fc" id="L113">    }</span>
  }

  /**
   * Account address export sub-command
   *
   * &lt;p&gt;Export of the account address is writing the address to the standard output by default. An
   * option enables to write it in a file. Indeed, a direct output of the value to standard out is
   * not always recommended as reading can be made difficult as the value can be mixed with other
   * information like logs that are in KeyPairUtil that is inevitable.
   */
  @Command(
      name = &quot;export-address&quot;,
      description =
          &quot;This command outputs the node's account address. &quot;
              + &quot;Default output is standard output.&quot;,
      mixinStandardHelpOptions = true,
      versionProvider = VersionProvider.class)
<span class="fc" id="L131">  static class AddressSubCommand extends KeyPairSubcommand implements Runnable {</span>

<span class="fc" id="L133">    @Option(</span>
        names = &quot;--to&quot;,
        paramLabel = DefaultCommandValues.MANDATORY_FILE_FORMAT_HELP,
        description = &quot;File to write address to instead of standard output&quot;,
        arity = &quot;1..1&quot;)
    private final File addressExportFile = null;

    @Override
    public void run() {
<span class="fc" id="L142">      configureEcCurve(ecCurve, parentCommand.spec.commandLine());</span>
<span class="fc" id="L143">      run(addressExportFile, keyPair -&gt; Util.publicKeyToAddress(keyPair.getPublicKey()).toString());</span>
<span class="fc" id="L144">    }</span>
  }

<span class="fc" id="L147">  private static class KeyPairSubcommand {</span>

    /** The Parent command. */
    @SuppressWarnings(&quot;unused&quot;)
    @ParentCommand
    protected PublicKeySubCommand parentCommand; // Picocli injects reference to parent command

<span class="fc" id="L154">    @Mixin private final NodePrivateKeyFileOption nodePrivateKeyFileOption = null;</span>

    /** The Ec curve. */
<span class="fc" id="L157">    @Option(</span>
        names = &quot;--ec-curve&quot;,
        paramLabel = &quot;&lt;NAME&gt;&quot;,
        description =
            &quot;Elliptic curve to use when creating a new key (default: &quot;
                + SignatureAlgorithmType.DEFAULT_EC_CURVE_NAME
                + &quot;)&quot;,
        arity = &quot;0..1&quot;)
    @SuppressWarnings(&quot;FieldCanBeFinal&quot;)
    protected String ecCurve = null;

<span class="fc" id="L168">    @Spec private final CommandSpec spec = null;</span>

    /**
     * Run.
     *
     * @param exportFile the export file
     * @param outputFunction the output function
     */
    protected final void run(
        final File exportFile, final Function&lt;KeyPair, String&gt; outputFunction) {
<span class="fc" id="L178">      checkNotNull(parentCommand);</span>
<span class="fc" id="L179">      final BesuCommand besuCommand = parentCommand.parentCommand;</span>
<span class="fc" id="L180">      checkNotNull(besuCommand);</span>

<span class="fc" id="L182">      final File nodePrivateKeyFile = nodePrivateKeyFileOption.getNodePrivateKeyFile();</span>
<span class="fc bfc" id="L183" title="All 4 branches covered.">      if (nodePrivateKeyFile != null &amp;&amp; !nodePrivateKeyFile.exists()) {</span>
<span class="fc" id="L184">        throw new CommandLine.ParameterException(</span>
<span class="fc" id="L185">            spec.commandLine(), &quot;Private key file doesn't exist&quot;);</span>
      }

      final KeyPair keyPair;
      try {
<span class="fc" id="L190">        keyPair = besuCommand.loadKeyPair(nodePrivateKeyFileOption.getNodePrivateKeyFile());</span>
<span class="fc" id="L191">      } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L192">        throw new CommandLine.ParameterException(</span>
<span class="fc" id="L193">            spec.commandLine(), &quot;Private key cannot be loaded from file&quot;, e);</span>
<span class="fc" id="L194">      }</span>
<span class="fc" id="L195">      final String output = outputFunction.apply(keyPair);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">      if (exportFile != null) {</span>
<span class="fc" id="L197">        final Path path = exportFile.toPath();</span>

<span class="fc" id="L199">        try (final BufferedWriter fileWriter = Files.newBufferedWriter(path, UTF_8)) {</span>
<span class="fc" id="L200">          fileWriter.write(output);</span>
<span class="nc" id="L201">        } catch (final IOException e) {</span>
<span class="nc" id="L202">          LOG.error(&quot;An error occurred while trying to write to output file&quot;, e);</span>
<span class="fc" id="L203">        }</span>
<span class="fc" id="L204">      } else {</span>
<span class="fc" id="L205">        parentCommand.out.println(output);</span>
      }
<span class="fc" id="L207">    }</span>

    /**
     * Configure ec curve.
     *
     * @param ecCurve the ec curve
     * @param commandLine the command line
     */
    protected static void configureEcCurve(final String ecCurve, final CommandLine commandLine) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (ecCurve != null) {</span>
        try {
<span class="fc" id="L218">          SignatureAlgorithmFactory.setInstance(SignatureAlgorithmType.create(ecCurve));</span>
<span class="fc" id="L219">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L220">          throw new CommandLine.ParameterException(commandLine, e.getMessage(), e);</span>
<span class="fc" id="L221">        }</span>
      }
<span class="fc" id="L223">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>