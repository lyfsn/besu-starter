<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkRunner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.p2p.network</a> &gt; <span class="el_source">NetworkRunner.java</span></div><h1>NetworkRunner.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.p2p.network;

import org.hyperledger.besu.ethereum.p2p.rlpx.RlpxAgent;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.SubProtocol;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.messages.DisconnectMessage.DisconnectReason;
import org.hyperledger.besu.metrics.BesuMetricCategory;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.metrics.Counter;
import org.hyperledger.besu.plugin.services.metrics.LabelledMetric;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NetworkRunner implements AutoCloseable {
<span class="fc" id="L40">  private static final Logger LOG = LoggerFactory.getLogger(NetworkRunner.class);</span>

<span class="fc" id="L42">  private final CountDownLatch shutdown = new CountDownLatch(1);</span>
<span class="fc" id="L43">  private final AtomicBoolean started = new AtomicBoolean(false);</span>
<span class="fc" id="L44">  private final AtomicBoolean stopped = new AtomicBoolean(false);</span>

  private final P2PNetwork network;
  private final Map&lt;String, SubProtocol&gt; subProtocols;
  private final List&lt;ProtocolManager&gt; protocolManagers;
  private final LabelledMetric&lt;Counter&gt; inboundMessageCounter;

  private NetworkRunner(
      final P2PNetwork network,
      final Map&lt;String, SubProtocol&gt; subProtocols,
      final List&lt;ProtocolManager&gt; protocolManagers,
<span class="fc" id="L55">      final MetricsSystem metricsSystem) {</span>
<span class="fc" id="L56">    this.network = network;</span>
<span class="fc" id="L57">    this.protocolManagers = protocolManagers;</span>
<span class="fc" id="L58">    this.subProtocols = subProtocols;</span>
<span class="fc" id="L59">    inboundMessageCounter =</span>
<span class="fc" id="L60">        metricsSystem.createLabelledCounter(</span>
            BesuMetricCategory.NETWORK,
            &quot;p2p_messages_inbound&quot;,
            &quot;Count of each P2P message received inbound.&quot;,
            &quot;protocol&quot;,
            &quot;name&quot;,
            &quot;code&quot;);
<span class="fc" id="L67">  }</span>

  public P2PNetwork getNetwork() {
<span class="fc" id="L70">    return network;</span>
  }

  public static Builder builder() {
<span class="fc" id="L74">    return new Builder();</span>
  }

  public void start() {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">    if (started.compareAndSet(false, true)) {</span>
<span class="fc" id="L79">      LOG.info(&quot;Starting Network.&quot;);</span>
<span class="fc" id="L80">      setupHandlers();</span>
<span class="fc" id="L81">      network.start();</span>

<span class="fc" id="L83">      LOG.info(</span>
          &quot;Supported capabilities: {}&quot;,
<span class="fc" id="L85">          protocolManagers.stream()</span>
<span class="fc" id="L86">              .map(q -&gt; String.format(&quot;%s&quot;, q.getSupportedCapabilities()))</span>
<span class="fc" id="L87">              .collect(Collectors.joining(&quot;, &quot;)));</span>
    } else {
<span class="nc" id="L89">      LOG.error(&quot;Attempted to start already running network.&quot;);</span>
    }
<span class="fc" id="L91">  }</span>

  public void stop() {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    if (stopped.compareAndSet(false, true)) {</span>
<span class="fc" id="L95">      LOG.info(&quot;Stopping Network.&quot;);</span>
<span class="fc" id="L96">      network.stop();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">      for (final ProtocolManager protocolManager : protocolManagers) {</span>
<span class="fc" id="L98">        protocolManager.stop();</span>
<span class="fc" id="L99">      }</span>
<span class="fc" id="L100">      shutdown.countDown();</span>
    } else {
<span class="nc" id="L102">      LOG.error(&quot;Attempted to stop already stopped network.&quot;);</span>
    }
<span class="fc" id="L104">  }</span>

  public void awaitStop() throws InterruptedException {
<span class="fc" id="L107">    shutdown.await();</span>
<span class="fc" id="L108">    network.awaitStop();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    for (final ProtocolManager protocolManager : protocolManagers) {</span>
<span class="fc" id="L110">      protocolManager.awaitStop();</span>
<span class="fc" id="L111">    }</span>
<span class="fc" id="L112">    LOG.info(&quot;Network stopped.&quot;);</span>
<span class="fc" id="L113">  }</span>

  private void setupHandlers() {
    // Setup message handlers
<span class="fc bfc" id="L117" title="All 2 branches covered.">    for (final ProtocolManager protocolManager : protocolManagers) {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">      for (final Capability supportedCapability : protocolManager.getSupportedCapabilities()) {</span>
<span class="fc" id="L119">        final SubProtocol protocol = subProtocols.get(supportedCapability.getName());</span>
<span class="fc" id="L120">        network.subscribe(</span>
            supportedCapability,
            (cap, message) -&gt; {
<span class="fc" id="L123">              final int code = message.getData().getCode();</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">              if (!protocol.isValidMessageCode(cap.getVersion(), code)) {</span>
<span class="nc" id="L125">                inboundMessageCounter.labels(cap.toString(), &quot;Invalid&quot;, &quot;&quot;).inc();</span>
                // Handle invalid messages by disconnecting
<span class="nc" id="L127">                LOG.debug(</span>
                    &quot;Invalid message code ({}-{}, {}) received from peer, disconnecting from: {}&quot;,
<span class="nc" id="L129">                    cap.getName(),</span>
<span class="nc" id="L130">                    cap.getVersion(),</span>
<span class="nc" id="L131">                    code,</span>
<span class="nc" id="L132">                    message.getConnection().getPeerInfo().getNodeId());</span>
<span class="nc" id="L133">                message.getConnection().disconnect(DisconnectReason.BREACH_OF_PROTOCOL);</span>
<span class="nc" id="L134">                return;</span>
              }
<span class="fc" id="L136">              inboundMessageCounter</span>
<span class="fc" id="L137">                  .labels(</span>
<span class="fc" id="L138">                      cap.toString(),</span>
<span class="fc" id="L139">                      protocol.messageName(cap.getVersion(), code),</span>
<span class="fc" id="L140">                      Integer.toString(code))</span>
<span class="fc" id="L141">                  .inc();</span>
<span class="fc" id="L142">              protocolManager.processMessage(cap, message);</span>
<span class="fc" id="L143">            });</span>
<span class="fc" id="L144">      }</span>
<span class="fc" id="L145">    }</span>

    // Setup (dis)connect handlers
<span class="fc bfc" id="L148" title="All 2 branches covered.">    for (final ProtocolManager protocolManager : protocolManagers) {</span>
<span class="fc" id="L149">      network.subscribeConnect(</span>
          (connection) -&gt; {
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (Collections.disjoint(</span>
<span class="fc" id="L152">                connection.getAgreedCapabilities(), protocolManager.getSupportedCapabilities())) {</span>
<span class="nc" id="L153">              return;</span>
            }
<span class="fc" id="L155">            protocolManager.handleNewConnection(connection);</span>
<span class="fc" id="L156">          });</span>

<span class="fc" id="L158">      network.subscribeConnectRequest(</span>
<span class="fc" id="L159">          (peer, incoming) -&gt; protocolManager.shouldConnect(peer, incoming));</span>

<span class="fc" id="L161">      network.subscribeDisconnect(</span>
          (connection, disconnectReason, initiatedByPeer) -&gt; {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (Collections.disjoint(</span>
<span class="fc" id="L164">                connection.getAgreedCapabilities(), protocolManager.getSupportedCapabilities())) {</span>
<span class="nc" id="L165">              return;</span>
            }
<span class="fc" id="L167">            protocolManager.handleDisconnect(connection, disconnectReason, initiatedByPeer);</span>
<span class="fc" id="L168">          });</span>
<span class="fc" id="L169">    }</span>
<span class="fc" id="L170">  }</span>

  @Override
  public void close() {
<span class="nc" id="L174">    stop();</span>
<span class="nc" id="L175">  }</span>

  public RlpxAgent getRlpxAgent() {
<span class="fc" id="L178">    return network.getRlpxAgent();</span>
  }

<span class="fc" id="L181">  public static class Builder {</span>
    private NetworkBuilder networkProvider;
<span class="fc" id="L183">    List&lt;ProtocolManager&gt; protocolManagers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L184">    List&lt;SubProtocol&gt; subProtocols = new ArrayList&lt;&gt;();</span>
    MetricsSystem metricsSystem;

    public NetworkRunner build() {
<span class="fc" id="L188">      final Map&lt;String, SubProtocol&gt; subProtocolMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">      for (final SubProtocol subProtocol : subProtocols) {</span>
<span class="fc" id="L190">        subProtocolMap.put(subProtocol.getName(), subProtocol);</span>
<span class="fc" id="L191">      }</span>
<span class="fc" id="L192">      final List&lt;Capability&gt; caps =</span>
<span class="fc" id="L193">          protocolManagers.stream()</span>
<span class="fc" id="L194">              .flatMap(p -&gt; p.getSupportedCapabilities().stream())</span>
<span class="fc" id="L195">              .collect(Collectors.toList());</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">      for (final Capability cap : caps) {</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (!subProtocolMap.containsKey(cap.getName())) {</span>
<span class="nc" id="L198">          throw new IllegalStateException(</span>
              &quot;No sub-protocol found corresponding to supported capability: &quot; + cap);
        }
<span class="fc" id="L201">      }</span>
<span class="fc" id="L202">      final P2PNetwork network = networkProvider.build(caps);</span>
<span class="fc" id="L203">      return new NetworkRunner(network, subProtocolMap, protocolManagers, metricsSystem);</span>
    }

    public Builder protocolManagers(final List&lt;ProtocolManager&gt; protocolManagers) {
<span class="fc" id="L207">      this.protocolManagers = protocolManagers;</span>
<span class="fc" id="L208">      return this;</span>
    }

    public Builder network(final NetworkBuilder networkProvider) {
<span class="fc" id="L212">      this.networkProvider = networkProvider;</span>
<span class="fc" id="L213">      return this;</span>
    }

    public Builder subProtocols(final SubProtocol... subProtocols) {
<span class="fc" id="L217">      this.subProtocols.addAll(Arrays.asList(subProtocols));</span>
<span class="fc" id="L218">      return this;</span>
    }

    public Builder subProtocols(final List&lt;SubProtocol&gt; subProtocols) {
<span class="fc" id="L222">      this.subProtocols.addAll(subProtocols);</span>
<span class="fc" id="L223">      return this;</span>
    }

    public Builder metricsSystem(final MetricsSystem metricsSystem) {
<span class="fc" id="L227">      this.metricsSystem = metricsSystem;</span>
<span class="fc" id="L228">      return this;</span>
    }
  }

  @FunctionalInterface
  public interface NetworkBuilder {
    P2PNetwork build(List&lt;Capability&gt; caps);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>