<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CachedWorldStorageManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.trie.bonsai.cache</a> &gt; <span class="el_source">CachedWorldStorageManager.java</span></div><h1>CachedWorldStorageManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.trie.bonsai.cache;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.trie.bonsai.BonsaiWorldStateProvider;
import org.hyperledger.besu.ethereum.trie.bonsai.storage.BonsaiSnapshotWorldStateKeyValueStorage;
import org.hyperledger.besu.ethereum.trie.bonsai.storage.BonsaiWorldStateKeyValueStorage;
import org.hyperledger.besu.ethereum.trie.bonsai.storage.BonsaiWorldStateLayerStorage;
import org.hyperledger.besu.ethereum.trie.bonsai.worldview.BonsaiWorldState;
import org.hyperledger.besu.evm.internal.EvmConfiguration;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

import org.apache.tuweni.bytes.Bytes32;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CachedWorldStorageManager
    implements BonsaiWorldStateKeyValueStorage.BonsaiStorageSubscriber {
  public static final long RETAINED_LAYERS = 512; // at least 256 + typical rollbacks
<span class="fc" id="L41">  private static final Logger LOG = LoggerFactory.getLogger(CachedWorldStorageManager.class);</span>
  private final BonsaiWorldStateProvider archive;
  private final EvmConfiguration evmConfiguration;

  private final BonsaiWorldStateKeyValueStorage rootWorldStateStorage;
  private final Map&lt;Bytes32, CachedBonsaiWorldView&gt; cachedWorldStatesByHash;

  private CachedWorldStorageManager(
      final BonsaiWorldStateProvider archive,
      final BonsaiWorldStateKeyValueStorage worldStateKeyValueStorage,
      final Map&lt;Bytes32, CachedBonsaiWorldView&gt; cachedWorldStatesByHash,
<span class="fc" id="L52">      final EvmConfiguration evmConfiguration) {</span>
<span class="fc" id="L53">    worldStateKeyValueStorage.subscribe(this);</span>
<span class="fc" id="L54">    this.rootWorldStateStorage = worldStateKeyValueStorage;</span>
<span class="fc" id="L55">    this.cachedWorldStatesByHash = cachedWorldStatesByHash;</span>
<span class="fc" id="L56">    this.archive = archive;</span>
<span class="fc" id="L57">    this.evmConfiguration = evmConfiguration;</span>
<span class="fc" id="L58">  }</span>

  public CachedWorldStorageManager(
      final BonsaiWorldStateProvider archive,
      final BonsaiWorldStateKeyValueStorage worldStateKeyValueStorage) {
<span class="fc" id="L63">    this(archive, worldStateKeyValueStorage, new ConcurrentHashMap&lt;&gt;(), EvmConfiguration.DEFAULT);</span>
<span class="fc" id="L64">  }</span>

  public synchronized void addCachedLayer(
      final BlockHeader blockHeader,
      final Hash worldStateRootHash,
      final BonsaiWorldState forWorldState) {
<span class="fc" id="L70">    final Optional&lt;CachedBonsaiWorldView&gt; cachedBonsaiWorldView =</span>
<span class="fc" id="L71">        Optional.ofNullable(this.cachedWorldStatesByHash.get(blockHeader.getBlockHash()));</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">    if (cachedBonsaiWorldView.isPresent()) {</span>
      // only replace if it is a layered storage
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">      if (forWorldState.isPersisted()</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">          &amp;&amp; cachedBonsaiWorldView.get().getWorldStateStorage()</span>
              instanceof BonsaiWorldStateLayerStorage) {
<span class="nc" id="L77">        LOG.atDebug()</span>
<span class="nc" id="L78">            .setMessage(&quot;updating layered world state for block {}, state root hash {}&quot;)</span>
<span class="nc" id="L79">            .addArgument(blockHeader::toLogString)</span>
<span class="nc" id="L80">            .addArgument(worldStateRootHash::toShortHexString)</span>
<span class="nc" id="L81">            .log();</span>
<span class="nc" id="L82">        cachedBonsaiWorldView</span>
<span class="nc" id="L83">            .get()</span>
<span class="nc" id="L84">            .updateWorldStateStorage(</span>
<span class="nc" id="L85">                new BonsaiSnapshotWorldStateKeyValueStorage(forWorldState.getWorldStateStorage()));</span>
      }
    } else {
<span class="fc" id="L88">      LOG.atDebug()</span>
<span class="fc" id="L89">          .setMessage(&quot;adding layered world state for block {}, state root hash {}&quot;)</span>
<span class="fc" id="L90">          .addArgument(blockHeader::toLogString)</span>
<span class="fc" id="L91">          .addArgument(worldStateRootHash::toShortHexString)</span>
<span class="fc" id="L92">          .log();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">      if (forWorldState.isPersisted()) {</span>
<span class="fc" id="L94">        cachedWorldStatesByHash.put(</span>
<span class="fc" id="L95">            blockHeader.getHash(),</span>
            new CachedBonsaiWorldView(
                blockHeader,
<span class="fc" id="L98">                new BonsaiSnapshotWorldStateKeyValueStorage(forWorldState.getWorldStateStorage())));</span>
      } else {
        // otherwise, add the layer to the cache
<span class="nc" id="L101">        cachedWorldStatesByHash.put(</span>
<span class="nc" id="L102">            blockHeader.getHash(),</span>
            new CachedBonsaiWorldView(
                blockHeader,
<span class="nc" id="L105">                ((BonsaiWorldStateLayerStorage) forWorldState.getWorldStateStorage()).clone()));</span>
      }
    }
<span class="fc" id="L108">    scrubCachedLayers(blockHeader.getNumber());</span>
<span class="fc" id="L109">  }</span>

  private synchronized void scrubCachedLayers(final long newMaxHeight) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (cachedWorldStatesByHash.size() &gt; RETAINED_LAYERS) {</span>
<span class="fc" id="L113">      final long waterline = newMaxHeight - RETAINED_LAYERS;</span>
<span class="fc" id="L114">      cachedWorldStatesByHash.values().stream()</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">          .filter(layer -&gt; layer.getBlockNumber() &lt; waterline)</span>
<span class="fc" id="L116">          .toList()</span>
<span class="fc" id="L117">          .forEach(</span>
              layer -&gt; {
<span class="fc" id="L119">                cachedWorldStatesByHash.remove(layer.getBlockHash());</span>
<span class="fc" id="L120">                layer.close();</span>
<span class="fc" id="L121">              });</span>
    }
<span class="fc" id="L123">  }</span>

  public Optional&lt;BonsaiWorldState&gt; getWorldState(final Hash blockHash) {
<span class="fc bfc" id="L126" title="All 2 branches covered.">    if (cachedWorldStatesByHash.containsKey(blockHash)) {</span>
      // return a new worldstate using worldstate storage and an isolated copy of the updater
<span class="fc" id="L128">      return Optional.ofNullable(cachedWorldStatesByHash.get(blockHash))</span>
<span class="fc" id="L129">          .map(</span>
              cached -&gt;
<span class="fc" id="L131">                  new BonsaiWorldState(</span>
                      archive,
<span class="fc" id="L133">                      new BonsaiWorldStateLayerStorage(cached.getWorldStateStorage()),</span>
                      evmConfiguration));
    }
<span class="fc" id="L136">    LOG.atDebug()</span>
<span class="fc" id="L137">        .setMessage(&quot;did not find worldstate in cache for {}&quot;)</span>
<span class="fc" id="L138">        .addArgument(blockHash.toShortHexString())</span>
<span class="fc" id="L139">        .log();</span>

<span class="fc" id="L141">    return Optional.empty();</span>
  }

  public Optional&lt;BonsaiWorldState&gt; getNearestWorldState(final BlockHeader blockHeader) {
<span class="fc" id="L145">    LOG.atDebug()</span>
<span class="fc" id="L146">        .setMessage(&quot;getting nearest worldstate for {}&quot;)</span>
<span class="fc" id="L147">        .addArgument(blockHeader.toLogString())</span>
<span class="fc" id="L148">        .log();</span>

<span class="fc" id="L150">    return Optional.ofNullable(</span>
<span class="fc" id="L151">            cachedWorldStatesByHash.get(blockHeader.getParentHash())) // search parent block</span>
<span class="fc" id="L152">        .map(CachedBonsaiWorldView::getWorldStateStorage)</span>
<span class="fc" id="L153">        .or(</span>
            () -&gt; {
              // or else search the nearest state in the cache
<span class="fc" id="L156">              LOG.atDebug()</span>
<span class="fc" id="L157">                  .setMessage(&quot;searching cache for nearest worldstate for {}&quot;)</span>
<span class="fc" id="L158">                  .addArgument(blockHeader.toLogString())</span>
<span class="fc" id="L159">                  .log();</span>

<span class="fc" id="L161">              final List&lt;CachedBonsaiWorldView&gt; cachedBonsaiWorldViews =</span>
<span class="fc" id="L162">                  new ArrayList&lt;&gt;(cachedWorldStatesByHash.values());</span>
<span class="fc" id="L163">              return cachedBonsaiWorldViews.stream()</span>
<span class="fc" id="L164">                  .sorted(</span>
<span class="fc" id="L165">                      Comparator.comparingLong(</span>
<span class="nc" id="L166">                          view -&gt; Math.abs(blockHeader.getNumber() - view.getBlockNumber())))</span>
<span class="fc" id="L167">                  .map(CachedBonsaiWorldView::getWorldStateStorage)</span>
<span class="fc" id="L168">                  .findFirst();</span>
            })
<span class="fc" id="L170">        .map(</span>
            storage -&gt;
<span class="nc" id="L172">                new BonsaiWorldState( // wrap the state in a layered worldstate</span>
                    archive, new BonsaiWorldStateLayerStorage(storage), evmConfiguration));
  }

  public Optional&lt;BonsaiWorldState&gt; getHeadWorldState(
      final Function&lt;Hash, Optional&lt;BlockHeader&gt;&gt; hashBlockHeaderFunction) {

<span class="fc" id="L179">    LOG.atDebug().setMessage(&quot;getting head worldstate&quot;).log();</span>

<span class="fc" id="L181">    return rootWorldStateStorage</span>
<span class="fc" id="L182">        .getWorldStateBlockHash()</span>
<span class="fc" id="L183">        .flatMap(hashBlockHeaderFunction)</span>
<span class="fc" id="L184">        .flatMap(</span>
            blockHeader -&gt; {
              // add the head to the cache
<span class="nc" id="L187">              addCachedLayer(</span>
                  blockHeader,
<span class="nc" id="L189">                  blockHeader.getStateRoot(),</span>
                  new BonsaiWorldState(archive, rootWorldStateStorage, evmConfiguration));
<span class="nc" id="L191">              return getWorldState(blockHeader.getHash());</span>
            });
  }

  public boolean containWorldStateStorage(final Hash blockHash) {
<span class="fc" id="L196">    return cachedWorldStatesByHash.containsKey(blockHash);</span>
  }

  public void reset() {
<span class="nc" id="L200">    this.cachedWorldStatesByHash.clear();</span>
<span class="nc" id="L201">  }</span>

  @Override
  public void onClearStorage() {
<span class="fc" id="L205">    this.cachedWorldStatesByHash.clear();</span>
<span class="fc" id="L206">  }</span>

  @Override
  public void onClearFlatDatabaseStorage() {
<span class="nc" id="L210">    this.cachedWorldStatesByHash.clear();</span>
<span class="nc" id="L211">  }</span>

  @Override
  public void onClearTrieLog() {
<span class="nc" id="L215">    this.cachedWorldStatesByHash.clear();</span>
<span class="nc" id="L216">  }</span>

  @Override
  public void onCloseStorage() {
<span class="nc" id="L220">    this.cachedWorldStatesByHash.clear();</span>
<span class="nc" id="L221">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>