<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SoftwareKeyStoreWrapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.pki.keystore</a> &gt; <span class="el_source">SoftwareKeyStoreWrapper.java</span></div><h1>SoftwareKeyStoreWrapper.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.pki.keystore;

import org.hyperledger.besu.pki.PkiException;

import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.file.Path;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.X509CRL;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Software key store wrapper. */
public class SoftwareKeyStoreWrapper extends AbstractKeyStoreWrapper {

<span class="fc" id="L40">  private static final Logger LOG = LoggerFactory.getLogger(SoftwareKeyStoreWrapper.class);</span>

  private final KeyStore keystore;
  private final transient char[] keystorePassword;
  private KeyStore truststore;
  private transient char[] truststorePassword;

<span class="fc" id="L47">  private final Map&lt;String, PrivateKey&gt; cachedPrivateKeys = new HashMap&lt;&gt;();</span>
<span class="fc" id="L48">  private final Map&lt;String, PublicKey&gt; cachedPublicKeys = new HashMap&lt;&gt;();</span>
<span class="fc" id="L49">  private final Map&lt;String, Certificate&gt; cachedCertificates = new HashMap&lt;&gt;();</span>

  /**
   * Instantiates a new Software key store wrapper.
   *
   * @param keystoreType the keystore type
   * @param keystoreLocation the keystore location
   * @param keystorePassword the keystore password
   * @param crlLocation the crl location
   */
  public SoftwareKeyStoreWrapper(
      final String keystoreType,
      final Path keystoreLocation,
      final String keystorePassword,
      final Path crlLocation) {
<span class="fc" id="L64">    this(keystoreType, keystoreLocation, keystorePassword, null, null, null, crlLocation);</span>
<span class="fc" id="L65">  }</span>

  /**
   * Instantiates a new Software key store wrapper.
   *
   * @param keystoreType the keystore type
   * @param keystoreLocation the keystore location
   * @param keystorePassword the keystore password
   * @param truststoreType the truststore type
   * @param truststoreLocation the truststore location
   * @param truststorePassword the truststore password
   * @param crlLocation the crl location
   */
  public SoftwareKeyStoreWrapper(
      final String keystoreType,
      final Path keystoreLocation,
      final String keystorePassword,
      final String truststoreType,
      final Path truststoreLocation,
      final String truststorePassword,
      final Path crlLocation) {
<span class="fc" id="L86">    super(crlLocation);</span>

<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    if (keystorePassword == null) {</span>
<span class="nc" id="L89">      throw new IllegalArgumentException(&quot;Keystore password is null&quot;);</span>
    }
<span class="fc" id="L91">    this.keystorePassword = keystorePassword.toCharArray();</span>
<span class="fc" id="L92">    try (InputStream stream = new FileInputStream(keystoreLocation.toFile())) {</span>
<span class="fc" id="L93">      keystore = KeyStore.getInstance(keystoreType);</span>
<span class="fc" id="L94">      keystore.load(stream, this.keystorePassword);</span>

<span class="nc" id="L96">    } catch (final Exception e) {</span>
<span class="nc" id="L97">      throw new PkiException(&quot;Failed to initialize software keystore: &quot; + keystoreLocation, e);</span>
<span class="fc" id="L98">    }</span>

<span class="pc bpc" id="L100" title="1 of 4 branches missed.">    if (truststoreType != null &amp;&amp; truststoreLocation != null) {</span>
<span class="fc" id="L101">      this.truststorePassword =</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">          (truststorePassword != null) ? truststorePassword.toCharArray() : null;</span>
<span class="fc" id="L103">      try (InputStream stream = new FileInputStream(truststoreLocation.toFile())) {</span>
<span class="fc" id="L104">        truststore = KeyStore.getInstance(truststoreType);</span>
<span class="fc" id="L105">        truststore.load(stream, this.truststorePassword);</span>

<span class="nc" id="L107">      } catch (final Exception e) {</span>
<span class="nc" id="L108">        throw new PkiException(</span>
            &quot;Failed to initialize software truststore: &quot; + truststoreLocation, e);
<span class="fc" id="L110">      }</span>
    }
<span class="fc" id="L112">  }</span>

  /**
   * Instantiates a new Software key store wrapper.
   *
   * @param keystore the keystore
   * @param keystorePassword the keystore password
   * @param truststore the truststore
   * @param truststorePassword the truststore password
   */
  @VisibleForTesting
  public SoftwareKeyStoreWrapper(
      final KeyStore keystore,
      final String keystorePassword,
      final KeyStore truststore,
      final String truststorePassword) {
<span class="fc" id="L128">    super((Path) null);</span>
<span class="fc" id="L129">    this.keystore = keystore;</span>
<span class="fc" id="L130">    this.keystorePassword = keystorePassword.toCharArray();</span>
<span class="fc" id="L131">    this.truststore = truststore;</span>
<span class="fc" id="L132">    this.truststorePassword = truststorePassword.toCharArray();</span>
<span class="fc" id="L133">  }</span>

  /**
   * Instantiates a new Software key store wrapper.
   *
   * @param crls the collection of X509CRL crls
   * @param keystore the keystore
   * @param keystorePassword the keystore password
   */
  @VisibleForTesting
  public SoftwareKeyStoreWrapper(
      final Collection&lt;X509CRL&gt; crls, final KeyStore keystore, final String keystorePassword) {
<span class="fc" id="L145">    super(crls);</span>
<span class="fc" id="L146">    this.keystore = keystore;</span>
<span class="fc" id="L147">    this.keystorePassword = keystorePassword.toCharArray();</span>
<span class="fc" id="L148">    this.truststore = null;</span>
<span class="fc" id="L149">    this.truststorePassword = null;</span>
<span class="fc" id="L150">  }</span>

  @Override
  public PrivateKey getPrivateKey(final String keyAlias) {
<span class="fc" id="L154">    LOG.debug(&quot;Retrieving private key for alias: {}&quot;, keyAlias);</span>
<span class="fc" id="L155">    return (PrivateKey) getKey(keyAlias, PrivateKey.class, cachedPrivateKeys);</span>
  }

  @Override
  public PublicKey getPublicKey(final String keyAlias) {
<span class="fc" id="L160">    LOG.debug(&quot;Retrieving public key for alias: {}&quot;, keyAlias);</span>
<span class="fc" id="L161">    return (PublicKey) getKey(keyAlias, PublicKey.class, cachedPublicKeys);</span>
  }

  @Override
  public Certificate getCertificate(final String certificateAlias) {
    try {
<span class="fc" id="L167">      LOG.debug(&quot;Retrieving certificate for alias: {}&quot;, certificateAlias);</span>
<span class="fc" id="L168">      Certificate certificate = cachedCertificates.get(certificateAlias);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      if (certificate == null) {</span>
<span class="fc" id="L170">        LOG.debug(&quot;Certificate alias: {} not cached&quot;, certificateAlias);</span>

<span class="fc" id="L172">        certificate = keystore.getCertificate(certificateAlias);</span>
<span class="fc bfc" id="L173" title="All 4 branches covered.">        if (certificate == null &amp;&amp; truststore != null) {</span>
<span class="fc" id="L174">          certificate = truststore.getCertificate(certificateAlias);</span>
        }
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (certificate != null) {</span>
<span class="fc" id="L177">          LOG.debug(&quot;Certificate alias: {} found in keystore/truststore&quot;, certificateAlias);</span>
<span class="fc" id="L178">          cachedCertificates.put(certificateAlias, certificate);</span>
<span class="fc" id="L179">          cachedPublicKeys.put(certificateAlias, certificate.getPublicKey());</span>
<span class="fc" id="L180">          return certificate;</span>
        } else {
<span class="fc" id="L182">          LOG.warn(&quot;Certificate alias: {} not found in keystore/truststore&quot;, certificateAlias);</span>
        }
      }
<span class="fc" id="L185">      return certificate;</span>

<span class="nc" id="L187">    } catch (final Exception e) {</span>
<span class="nc" id="L188">      throw new PkiException(&quot;Failed to get certificate: &quot; + certificateAlias, e);</span>
    }
  }

  @Override
  public Certificate[] getCertificateChain(final String certificateAlias) {
    try {
<span class="fc" id="L195">      LOG.debug(&quot;Retrieving certificate chain for alias: {}&quot;, certificateAlias);</span>

<span class="fc" id="L197">      Certificate[] certificateChain = keystore.getCertificateChain(certificateAlias);</span>
<span class="fc bfc" id="L198" title="All 4 branches covered.">      if (certificateChain == null &amp;&amp; truststore != null) {</span>
<span class="fc" id="L199">        certificateChain = truststore.getCertificateChain(certificateAlias);</span>
      }
<span class="fc" id="L201">      return certificateChain;</span>
<span class="nc" id="L202">    } catch (final Exception e) {</span>
<span class="nc" id="L203">      throw new PkiException(</span>
          &quot;Failed to retrieve certificate chain for alias: &quot; + certificateAlias, e);
    }
  }

  private Key getKey(
      final String keyAlias,
      final Class&lt;? extends Key&gt; keyTypeClass,
      final Map&lt;String, ? extends Key&gt; keyCache) {
<span class="fc" id="L212">    Key cachedKey = keyCache.get(keyAlias);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">    if (cachedKey == null) {</span>
<span class="fc" id="L214">      LOG.debug(&quot;Key alias: {} not cached&quot;, keyAlias);</span>
      try {
<span class="fc" id="L216">        cachedKey = loadAndCacheKey(this.keystore, this.keystorePassword, keyAlias, keyTypeClass);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (cachedKey == null) {</span>
<span class="fc" id="L218">          cachedKey =</span>
<span class="fc" id="L219">              loadAndCacheKey(this.truststore, this.truststorePassword, keyAlias, keyTypeClass);</span>
        }
<span class="nc" id="L221">      } catch (final Exception e) {</span>
<span class="nc" id="L222">        throw new PkiException(&quot;Failed to get key: &quot; + keyAlias, e);</span>
<span class="fc" id="L223">      }</span>
    }
<span class="fc" id="L225">    return cachedKey;</span>
  }

  @Override
  public KeyStore getKeyStore() {
<span class="fc" id="L230">    return keystore;</span>
  }

  @Override
  public KeyStore getTrustStore() {
<span class="fc" id="L235">    return truststore;</span>
  }

  private Key loadAndCacheKey(
      final KeyStore keystore,
      final char[] keystorePassword,
      final String keyAlias,
      final Class&lt;? extends Key&gt; keyTypeClass)
      throws GeneralSecurityException {
<span class="fc bfc" id="L244" title="All 4 branches covered.">    if (keystore != null &amp;&amp; keystore.containsAlias(keyAlias)) {</span>

<span class="fc" id="L246">      final Key key = keystore.getKey(keyAlias, keystorePassword);</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">      if (key != null) {</span>
<span class="fc" id="L248">        LOG.debug(&quot;Key alias: {} found in keystore/truststore&quot;, keyAlias);</span>
<span class="fc bfc" id="L249" title="All 4 branches covered.">        if (key instanceof PrivateKey &amp;&amp; PrivateKey.class.isAssignableFrom(keyTypeClass)) {</span>
<span class="fc" id="L250">          cachedPrivateKeys.put(keyAlias, (PrivateKey) key);</span>
<span class="fc" id="L251">          return key;</span>
<span class="pc bpc" id="L252" title="1 of 4 branches missed.">        } else if (key instanceof PublicKey &amp;&amp; PublicKey.class.isAssignableFrom(keyTypeClass)) {</span>
<span class="fc" id="L253">          cachedPublicKeys.put(keyAlias, (PublicKey) key);</span>
<span class="fc" id="L254">          return key;</span>
        }
      }

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">      if (PublicKey.class.isAssignableFrom(keyTypeClass)) {</span>
<span class="fc" id="L259">        final Certificate certificate = getCertificate(keyAlias);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (certificate != null) {</span>
<span class="fc" id="L261">          return certificate.getPublicKey();</span>
        }
      }
    }

<span class="fc" id="L266">    LOG.warn(&quot;Key alias: {} not found in keystore/truststore&quot;, keyAlias);</span>
<span class="fc" id="L267">    return null;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>