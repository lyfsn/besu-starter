<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GetBlockHeadersMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.eth.messages</a> &gt; <span class="el_source">GetBlockHeadersMessage.java</span></div><h1>GetBlockHeadersMessage.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.eth.messages;

import static com.google.common.base.Preconditions.checkArgument;

import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.AbstractMessageData;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.MessageData;
import org.hyperledger.besu.ethereum.rlp.BytesValueRLPOutput;
import org.hyperledger.besu.ethereum.rlp.RLP;
import org.hyperledger.besu.ethereum.rlp.RLPInput;
import org.hyperledger.besu.ethereum.rlp.RLPOutput;

import java.util.Optional;
import java.util.OptionalLong;

import org.apache.tuweni.bytes.Bytes;

/** PV62 GetBlockHeaders Message. */
public final class GetBlockHeadersMessage extends AbstractMessageData {

<span class="fc" id="L35">  private GetBlockHeadersData getBlockHeadersData = null;</span>

  public static GetBlockHeadersMessage readFrom(final MessageData message) {
<span class="fc bfc" id="L38" title="All 2 branches covered.">    if (message instanceof GetBlockHeadersMessage) {</span>
<span class="fc" id="L39">      return (GetBlockHeadersMessage) message;</span>
    }
<span class="fc" id="L41">    final int code = message.getCode();</span>
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">    if (code != EthPV62.GET_BLOCK_HEADERS) {</span>
<span class="nc" id="L43">      throw new IllegalArgumentException(</span>
<span class="nc" id="L44">          String.format(&quot;Message has code %d and thus is not a GetBlockHeadersMessage.&quot;, code));</span>
    }
<span class="fc" id="L46">    return new GetBlockHeadersMessage(message.getData());</span>
  }

  public static GetBlockHeadersMessage create(
      final long blockNum, final int maxHeaders, final int skip, final boolean reverse) {
<span class="fc" id="L51">    final GetBlockHeadersData getBlockHeadersData =</span>
<span class="fc" id="L52">        GetBlockHeadersData.create(blockNum, maxHeaders, skip, reverse);</span>
<span class="fc" id="L53">    final BytesValueRLPOutput tmp = new BytesValueRLPOutput();</span>
<span class="fc" id="L54">    getBlockHeadersData.writeTo(tmp);</span>
<span class="fc" id="L55">    return new GetBlockHeadersMessage(tmp.encoded());</span>
  }

  public static GetBlockHeadersMessage create(
      final Hash hash, final int maxHeaders, final int skip, final boolean reverse) {
<span class="fc" id="L60">    final GetBlockHeadersData getBlockHeadersData =</span>
<span class="fc" id="L61">        GetBlockHeadersData.create(hash, maxHeaders, skip, reverse);</span>
<span class="fc" id="L62">    final BytesValueRLPOutput tmp = new BytesValueRLPOutput();</span>
<span class="fc" id="L63">    getBlockHeadersData.writeTo(tmp);</span>
<span class="fc" id="L64">    return new GetBlockHeadersMessage(tmp.encoded());</span>
  }

  private GetBlockHeadersMessage(final Bytes data) {
<span class="fc" id="L68">    super(data);</span>
<span class="fc" id="L69">  }</span>

  @Override
  public int getCode() {
<span class="fc" id="L73">    return EthPV62.GET_BLOCK_HEADERS;</span>
  }

  /**
   * Returns the block number that the message requests or {@link OptionalLong#empty()} if the
   * request specifies a block hash.
   *
   * @return Block Number Requested or {@link OptionalLong#empty()}
   */
  public OptionalLong blockNumber() {
<span class="fc" id="L83">    return getBlockHeadersData().blockNumber;</span>
  }

  /**
   * Returns the block hash that the message requests or {@link Optional#empty()} if the request
   * specifies a block number.
   *
   * @return Block Hash Requested or {@link Optional#empty()}
   */
  public Optional&lt;Hash&gt; hash() {
<span class="fc" id="L93">    return getBlockHeadersData().blockHash;</span>
  }

  public int maxHeaders() {
<span class="fc" id="L97">    return getBlockHeadersData().maxHeaders;</span>
  }

  public int skip() {
<span class="fc" id="L101">    return getBlockHeadersData().skip;</span>
  }

  public boolean reverse() {
<span class="fc" id="L105">    return getBlockHeadersData().reverse;</span>
  }

  private GetBlockHeadersData getBlockHeadersData() {
<span class="fc bfc" id="L109" title="All 2 branches covered.">    if (getBlockHeadersData == null) {</span>
<span class="fc" id="L110">      getBlockHeadersData = GetBlockHeadersData.readFrom(RLP.input(data));</span>
    }
<span class="fc" id="L112">    return getBlockHeadersData;</span>
  }

  private static class GetBlockHeadersData {
    private final Optional&lt;Hash&gt; blockHash;
    private final OptionalLong blockNumber;
    private final int maxHeaders;
    private final int skip;
    private final boolean reverse;

    private GetBlockHeadersData(
        final Optional&lt;Hash&gt; blockHash,
        final OptionalLong blockNumber,
        final int maxHeaders,
        final int skip,
<span class="fc" id="L127">        final boolean reverse) {</span>
<span class="fc" id="L128">      checkArgument(</span>
<span class="fc" id="L129">          validateBlockHashAndNumber(blockHash, blockNumber),</span>
          &quot;Either blockHash or blockNumber should be non-empty&quot;);
<span class="fc" id="L131">      this.blockHash = blockHash;</span>
<span class="fc" id="L132">      this.blockNumber = blockNumber;</span>
<span class="fc" id="L133">      this.maxHeaders = maxHeaders;</span>
<span class="fc" id="L134">      this.skip = skip;</span>
<span class="fc" id="L135">      this.reverse = reverse;</span>
<span class="fc" id="L136">    }</span>

    private static boolean validateBlockHashAndNumber(
        final Optional&lt;Hash&gt; blockHash, final OptionalLong blockNumber) {
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">      return (blockHash.isPresent() || blockNumber.isPresent())</span>
<span class="pc bpc" id="L141" title="1 of 4 branches missed.">          &amp;&amp; !(blockHash.isPresent() &amp;&amp; blockNumber.isPresent());</span>
    }

    public static GetBlockHeadersData readFrom(final RLPInput input) {
<span class="fc" id="L145">      input.enterList();</span>

      final Optional&lt;Hash&gt; blockHash;
      final OptionalLong blockNumber;
<span class="fc bfc" id="L149" title="All 2 branches covered.">      if (input.nextSize() == Hash.SIZE) {</span>
<span class="fc" id="L150">        blockHash = Optional.of(Hash.wrap(input.readBytes32()));</span>
<span class="fc" id="L151">        blockNumber = OptionalLong.empty();</span>
      } else {
<span class="fc" id="L153">        blockHash = Optional.empty();</span>
<span class="fc" id="L154">        blockNumber = OptionalLong.of(input.readLongScalar());</span>
      }

<span class="fc" id="L157">      final int maxHeaders = input.readIntScalar();</span>
<span class="fc" id="L158">      final int skip = input.readIntScalar();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      final boolean reverse = input.readIntScalar() != 0;</span>

<span class="fc" id="L161">      input.leaveList();</span>

<span class="fc" id="L163">      return new GetBlockHeadersData(blockHash, blockNumber, maxHeaders, skip, reverse);</span>
    }

    public static GetBlockHeadersData create(
        final long blockNum, final int maxHeaders, final int skip, final boolean reverse) {
<span class="fc" id="L168">      return new GetBlockHeadersData(</span>
<span class="fc" id="L169">          Optional.empty(), OptionalLong.of(blockNum), maxHeaders, skip, reverse);</span>
    }

    public static GetBlockHeadersData create(
        final Hash hash, final int maxHeaders, final int skip, final boolean reverse) {
<span class="fc" id="L174">      return new GetBlockHeadersData(</span>
<span class="fc" id="L175">          Optional.of(hash), OptionalLong.empty(), maxHeaders, skip, reverse);</span>
    }

    /**
     * Write an RLP representation.
     *
     * @param out The RLP output to write to
     */
    public void writeTo(final RLPOutput out) {
<span class="fc" id="L184">      out.startList();</span>

<span class="fc bfc" id="L186" title="All 2 branches covered.">      if (blockHash.isPresent()) {</span>
<span class="fc" id="L187">        out.writeBytes(blockHash.get());</span>
      } else {
<span class="fc" id="L189">        out.writeLongScalar(blockNumber.getAsLong());</span>
      }
<span class="fc" id="L191">      out.writeIntScalar(maxHeaders);</span>
<span class="fc" id="L192">      out.writeIntScalar(skip);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">      out.writeIntScalar(reverse ? 1 : 0);</span>

<span class="fc" id="L195">      out.endList();</span>
<span class="fc" id="L196">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>