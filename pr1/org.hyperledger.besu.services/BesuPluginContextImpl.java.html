<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BesuPluginContextImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.services</a> &gt; <span class="el_source">BesuPluginContextImpl.java</span></div><h1>BesuPluginContextImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.services;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;

import org.hyperledger.besu.plugin.BesuContext;
import org.hyperledger.besu.plugin.BesuPlugin;
import org.hyperledger.besu.plugin.services.BesuService;
import org.hyperledger.besu.plugin.services.PluginVersionsProvider;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.ServiceLoader;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Besu plugin context implementation. */
<span class="fc" id="L49">public class BesuPluginContextImpl implements BesuContext, PluginVersionsProvider {</span>

<span class="fc" id="L51">  private static final Logger LOG = LoggerFactory.getLogger(BesuPluginContextImpl.class);</span>

<span class="fc" id="L53">  private enum Lifecycle {</span>
    /** Uninitialized lifecycle. */
<span class="fc" id="L55">    UNINITIALIZED,</span>
    /** Registering lifecycle. */
<span class="fc" id="L57">    REGISTERING,</span>
    /** Registered lifecycle. */
<span class="fc" id="L59">    REGISTERED,</span>
    /** Before external services started lifecycle. */
<span class="fc" id="L61">    BEFORE_EXTERNAL_SERVICES_STARTED,</span>
    /** Before external services finished lifecycle. */
<span class="fc" id="L63">    BEFORE_EXTERNAL_SERVICES_FINISHED,</span>
    /** Before main loop started lifecycle. */
<span class="fc" id="L65">    BEFORE_MAIN_LOOP_STARTED,</span>
    /** Before main loop finished lifecycle. */
<span class="fc" id="L67">    BEFORE_MAIN_LOOP_FINISHED,</span>
    /** Stopping lifecycle. */
<span class="fc" id="L69">    STOPPING,</span>
    /** Stopped lifecycle. */
<span class="fc" id="L71">    STOPPED</span>
  }

<span class="fc" id="L74">  private Lifecycle state = Lifecycle.UNINITIALIZED;</span>
<span class="fc" id="L75">  private final Map&lt;Class&lt;?&gt;, ? super BesuService&gt; serviceRegistry = new HashMap&lt;&gt;();</span>
<span class="fc" id="L76">  private final List&lt;BesuPlugin&gt; plugins = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L77">  private final List&lt;String&gt; pluginVersions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L78">  final List&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>

  /**
   * Add service.
   *
   * @param &lt;T&gt; the type parameter
   * @param serviceType the service type
   * @param service the service
   */
  @Override
  public &lt;T extends BesuService&gt; void addService(final Class&lt;T&gt; serviceType, final T service) {
<span class="fc" id="L89">    checkArgument(serviceType.isInterface(), &quot;Services must be Java interfaces.&quot;);</span>
<span class="fc" id="L90">    checkArgument(</span>
<span class="fc" id="L91">        serviceType.isInstance(service),</span>
        &quot;The service registered with a type must implement that type&quot;);
<span class="fc" id="L93">    serviceRegistry.put(serviceType, service);</span>
<span class="fc" id="L94">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public &lt;T extends BesuService&gt; Optional&lt;T&gt; getService(final Class&lt;T&gt; serviceType) {
<span class="fc" id="L99">    return Optional.ofNullable((T) serviceRegistry.get(serviceType));</span>
  }

  /**
   * Register plugins.
   *
   * @param pluginsDir the plugins dir
   */
  public void registerPlugins(final Path pluginsDir) {
<span class="fc" id="L108">    lines.add(&quot;Plugins:&quot;);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    checkState(</span>
        state == Lifecycle.UNINITIALIZED,
        &quot;Besu plugins have already been registered.  Cannot register additional plugins.&quot;);

<span class="fc" id="L113">    final ClassLoader pluginLoader =</span>
<span class="fc" id="L114">        pluginDirectoryLoader(pluginsDir).orElse(this.getClass().getClassLoader());</span>

<span class="fc" id="L116">    state = Lifecycle.REGISTERING;</span>

<span class="fc" id="L118">    final ServiceLoader&lt;BesuPlugin&gt; serviceLoader =</span>
<span class="fc" id="L119">        ServiceLoader.load(BesuPlugin.class, pluginLoader);</span>

<span class="fc" id="L121">    int pluginsCount = 0;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">    for (final BesuPlugin plugin : serviceLoader) {</span>
<span class="fc" id="L123">      pluginsCount++;</span>
      try {
<span class="fc" id="L125">        plugin.register(this);</span>
<span class="fc" id="L126">        LOG.info(&quot;Registered plugin of type {}.&quot;, plugin.getClass().getName());</span>
<span class="fc" id="L127">        String pluginVersion = getPluginVersion(plugin);</span>
<span class="fc" id="L128">        pluginVersions.add(pluginVersion);</span>
<span class="fc" id="L129">        lines.add(String.format(&quot;%s (%s)&quot;, plugin.getClass().getSimpleName(), pluginVersion));</span>
<span class="fc" id="L130">      } catch (final Exception e) {</span>
<span class="fc" id="L131">        LOG.error(</span>
            &quot;Error registering plugin of type &quot;
<span class="fc" id="L133">                + plugin.getClass().getName()</span>
                + &quot;, start and stop will not be called.&quot;,
            e);
<span class="fc" id="L136">        lines.add(String.format(&quot;ERROR %s&quot;, plugin.getClass().getSimpleName()));</span>
<span class="fc" id="L137">        continue;</span>
<span class="fc" id="L138">      }</span>
<span class="fc" id="L139">      plugins.add(plugin);</span>
<span class="fc" id="L140">    }</span>

<span class="fc" id="L142">    LOG.debug(&quot;Plugin registration complete.&quot;);</span>
<span class="fc" id="L143">    lines.add(</span>
<span class="fc" id="L144">        String.format(</span>
<span class="fc" id="L145">            &quot;TOTAL = %d of %d plugins successfully loaded&quot;, plugins.size(), pluginsCount));</span>
<span class="fc" id="L146">    lines.add(String.format(&quot;from %s&quot;, pluginsDir.toAbsolutePath()));</span>

<span class="fc" id="L148">    state = Lifecycle.REGISTERED;</span>
<span class="fc" id="L149">  }</span>

  /**
   * get the summary log, as a list of string lines
   *
   * @return the summary
   */
  public List&lt;String&gt; getPluginsSummaryLog() {
<span class="nc" id="L157">    return lines;</span>
  }

  private String getPluginVersion(final BesuPlugin plugin) {
<span class="fc" id="L161">    final Package pluginPackage = plugin.getClass().getPackage();</span>
<span class="fc" id="L162">    final String implTitle =</span>
<span class="fc" id="L163">        Optional.ofNullable(pluginPackage.getImplementationTitle())</span>
<span class="fc" id="L164">            .filter(Predicate.not(String::isBlank))</span>
<span class="fc" id="L165">            .orElse(plugin.getClass().getSimpleName());</span>
<span class="fc" id="L166">    final String implVersion =</span>
<span class="fc" id="L167">        Optional.ofNullable(pluginPackage.getImplementationVersion())</span>
<span class="fc" id="L168">            .filter(Predicate.not(String::isBlank))</span>
<span class="fc" id="L169">            .orElse(&quot;&lt;Unknown Version&gt;&quot;);</span>
<span class="fc" id="L170">    return implTitle + &quot;/v&quot; + implVersion;</span>
  }

  /** Before external services. */
  public void beforeExternalServices() {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">    checkState(</span>
        state == Lifecycle.REGISTERED,
        &quot;BesuContext should be in state %s but it was in %s&quot;,
        Lifecycle.REGISTERED,
        state);
<span class="fc" id="L180">    state = Lifecycle.BEFORE_EXTERNAL_SERVICES_STARTED;</span>
<span class="fc" id="L181">    final Iterator&lt;BesuPlugin&gt; pluginsIterator = plugins.iterator();</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">    while (pluginsIterator.hasNext()) {</span>
<span class="fc" id="L184">      final BesuPlugin plugin = pluginsIterator.next();</span>

      try {
<span class="fc" id="L187">        plugin.beforeExternalServices();</span>
<span class="fc" id="L188">        LOG.debug(</span>
<span class="fc" id="L189">            &quot;beforeExternalServices called on plugin of type {}.&quot;, plugin.getClass().getName());</span>
<span class="nc" id="L190">      } catch (final Exception e) {</span>
<span class="nc" id="L191">        LOG.error(</span>
            &quot;Error calling `beforeExternalServices` on plugin of type &quot;
<span class="nc" id="L193">                + plugin.getClass().getName()</span>
                + &quot;, stop will not be called.&quot;,
            e);
<span class="nc" id="L196">        pluginsIterator.remove();</span>
<span class="fc" id="L197">      }</span>
<span class="fc" id="L198">    }</span>

<span class="fc" id="L200">    LOG.debug(&quot;Plugin startup complete.&quot;);</span>
<span class="fc" id="L201">    state = Lifecycle.BEFORE_EXTERNAL_SERVICES_FINISHED;</span>
<span class="fc" id="L202">  }</span>

  /** Start plugins. */
  public void startPlugins() {
<span class="fc bfc" id="L206" title="All 2 branches covered.">    checkState(</span>
        state == Lifecycle.BEFORE_EXTERNAL_SERVICES_FINISHED,
        &quot;BesuContext should be in state %s but it was in %s&quot;,
        Lifecycle.BEFORE_EXTERNAL_SERVICES_FINISHED,
        state);
<span class="fc" id="L211">    state = Lifecycle.BEFORE_MAIN_LOOP_STARTED;</span>
<span class="fc" id="L212">    final Iterator&lt;BesuPlugin&gt; pluginsIterator = plugins.iterator();</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">    while (pluginsIterator.hasNext()) {</span>
<span class="fc" id="L215">      final BesuPlugin plugin = pluginsIterator.next();</span>

      try {
<span class="fc" id="L218">        plugin.start();</span>
<span class="fc" id="L219">        LOG.debug(&quot;Started plugin of type {}.&quot;, plugin.getClass().getName());</span>
<span class="fc" id="L220">      } catch (final Exception e) {</span>
<span class="fc" id="L221">        LOG.error(</span>
            &quot;Error starting plugin of type &quot;
<span class="fc" id="L223">                + plugin.getClass().getName()</span>
                + &quot;, stop will not be called.&quot;,
            e);
<span class="fc" id="L226">        pluginsIterator.remove();</span>
<span class="fc" id="L227">      }</span>
<span class="fc" id="L228">    }</span>

<span class="fc" id="L230">    LOG.debug(&quot;Plugin startup complete.&quot;);</span>
<span class="fc" id="L231">    state = Lifecycle.BEFORE_MAIN_LOOP_FINISHED;</span>
<span class="fc" id="L232">  }</span>

  /** Stop plugins. */
  public void stopPlugins() {
<span class="fc bfc" id="L236" title="All 2 branches covered.">    checkState(</span>
        state == Lifecycle.BEFORE_MAIN_LOOP_FINISHED,
        &quot;BesuContext should be in state %s but it was in %s&quot;,
        Lifecycle.BEFORE_MAIN_LOOP_FINISHED,
        state);
<span class="fc" id="L241">    state = Lifecycle.STOPPING;</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">    for (final BesuPlugin plugin : plugins) {</span>
      try {
<span class="fc" id="L245">        plugin.stop();</span>
<span class="fc" id="L246">        LOG.debug(&quot;Stopped plugin of type {}.&quot;, plugin.getClass().getName());</span>
<span class="fc" id="L247">      } catch (final Exception e) {</span>
<span class="fc" id="L248">        LOG.error(&quot;Error stopping plugin of type &quot; + plugin.getClass().getName(), e);</span>
<span class="fc" id="L249">      }</span>
<span class="fc" id="L250">    }</span>

<span class="fc" id="L252">    LOG.debug(&quot;Plugin shutdown complete.&quot;);</span>
<span class="fc" id="L253">    state = Lifecycle.STOPPED;</span>
<span class="fc" id="L254">  }</span>

  @Override
  public Collection&lt;String&gt; getPluginVersions() {
<span class="nc" id="L258">    return Collections.unmodifiableList(pluginVersions);</span>
  }

  private static URL pathToURIOrNull(final Path p) {
    try {
<span class="nc" id="L263">      return p.toUri().toURL();</span>
<span class="nc" id="L264">    } catch (final MalformedURLException e) {</span>
<span class="nc" id="L265">      return null;</span>
    }
  }

  /**
   * Gets plugins.
   *
   * @return the plugins
   */
  @VisibleForTesting
  List&lt;BesuPlugin&gt; getPlugins() {
<span class="fc" id="L276">    return Collections.unmodifiableList(plugins);</span>
  }

  private Optional&lt;ClassLoader&gt; pluginDirectoryLoader(final Path pluginsDir) {
<span class="pc bpc" id="L280" title="2 of 4 branches missed.">    if (pluginsDir != null &amp;&amp; pluginsDir.toFile().isDirectory()) {</span>
<span class="fc" id="L281">      LOG.debug(&quot;Searching for plugins in {}&quot;, pluginsDir.toAbsolutePath());</span>

<span class="fc" id="L283">      try (final Stream&lt;Path&gt; pluginFilesList = Files.list(pluginsDir)) {</span>
<span class="fc" id="L284">        final URL[] pluginJarURLs =</span>
            pluginFilesList
<span class="fc" id="L286">                .filter(p -&gt; p.getFileName().toString().endsWith(&quot;.jar&quot;))</span>
<span class="fc" id="L287">                .map(BesuPluginContextImpl::pathToURIOrNull)</span>
<span class="fc" id="L288">                .toArray(URL[]::new);</span>
<span class="fc" id="L289">        return Optional.of(new URLClassLoader(pluginJarURLs, this.getClass().getClassLoader()));</span>
<span class="nc" id="L290">      } catch (final MalformedURLException e) {</span>
<span class="nc" id="L291">        LOG.error(&quot;Error converting files to URLs, could not load plugins&quot;, e);</span>
<span class="nc" id="L292">      } catch (final IOException e) {</span>
<span class="nc" id="L293">        LOG.error(&quot;Error enumerating plugins, could not load plugins&quot;, e);</span>
<span class="nc" id="L294">      }</span>
    } else {
<span class="nc" id="L296">      LOG.debug(&quot;Plugin directory does not exist, skipping registration. - {}&quot;, pluginsDir);</span>
    }

<span class="nc" id="L299">    return Optional.empty();</span>
  }

  /**
   * Gets named plugins.
   *
   * @return the named plugins
   */
  public Map&lt;String, BesuPlugin&gt; getNamedPlugins() {
<span class="fc" id="L308">    return plugins.stream()</span>
<span class="fc" id="L309">        .filter(plugin -&gt; plugin.getName().isPresent())</span>
<span class="pc" id="L310">        .collect(Collectors.toMap(plugin -&gt; plugin.getName().get(), plugin -&gt; plugin, (a, b) -&gt; b));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>