<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NodeLocalConfigPermissioningController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.permissioning</a> &gt; <span class="el_source">NodeLocalConfigPermissioningController.java</span></div><h1>NodeLocalConfigPermissioningController.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.permissioning;

import org.hyperledger.besu.ethereum.p2p.peers.EnodeURLImpl;
import org.hyperledger.besu.ethereum.permissioning.AllowlistPersistor.ALLOWLIST_TYPE;
import org.hyperledger.besu.ethereum.permissioning.node.NodeAllowlistUpdatedEvent;
import org.hyperledger.besu.metrics.BesuMetricCategory;
import org.hyperledger.besu.plugin.data.EnodeURL;
import org.hyperledger.besu.plugin.services.MetricsSystem;
import org.hyperledger.besu.plugin.services.metrics.Counter;
import org.hyperledger.besu.plugin.services.permissioning.NodeConnectionPermissioningProvider;
import org.hyperledger.besu.util.Subscribers;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import com.google.common.annotations.VisibleForTesting;
import org.apache.tuweni.bytes.Bytes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NodeLocalConfigPermissioningController implements NodeConnectionPermissioningProvider {

<span class="fc" id="L45">  private static final Logger LOG =</span>
<span class="fc" id="L46">      LoggerFactory.getLogger(NodeLocalConfigPermissioningController.class);</span>

  private LocalPermissioningConfiguration configuration;
  private final List&lt;EnodeURL&gt; fixedNodes;
  private final Bytes localNodeId;
<span class="fc" id="L51">  private final List&lt;EnodeURL&gt; nodesAllowlist = new ArrayList&lt;&gt;();</span>
  private final AllowlistPersistor allowlistPersistor;
<span class="fc" id="L53">  private final Subscribers&lt;Consumer&lt;NodeAllowlistUpdatedEvent&gt;&gt; nodeAllowlistUpdatedObservers =</span>
<span class="fc" id="L54">      Subscribers.create();</span>

  private final Counter checkCounter;
  private final Counter checkCounterPermitted;
  private final Counter checkCounterUnpermitted;

  public NodeLocalConfigPermissioningController(
      final LocalPermissioningConfiguration permissioningConfiguration,
      final List&lt;EnodeURL&gt; fixedNodes,
      final Bytes localNodeId,
      final MetricsSystem metricsSystem) {
<span class="fc" id="L65">    this(</span>
        permissioningConfiguration,
        fixedNodes,
        localNodeId,
<span class="fc" id="L69">        new AllowlistPersistor(permissioningConfiguration.getNodePermissioningConfigFilePath()),</span>
        metricsSystem);
<span class="fc" id="L71">  }</span>

  public NodeLocalConfigPermissioningController(
      final LocalPermissioningConfiguration configuration,
      final List&lt;EnodeURL&gt; fixedNodes,
      final Bytes localNodeId,
      final AllowlistPersistor allowlistPersistor,
<span class="fc" id="L78">      final MetricsSystem metricsSystem) {</span>
<span class="fc" id="L79">    this.configuration = configuration;</span>
<span class="fc" id="L80">    this.fixedNodes = fixedNodes;</span>
<span class="fc" id="L81">    this.localNodeId = localNodeId;</span>
<span class="fc" id="L82">    this.allowlistPersistor = allowlistPersistor;</span>
<span class="fc" id="L83">    readNodesFromConfig(configuration);</span>

<span class="fc" id="L85">    this.checkCounter =</span>
<span class="fc" id="L86">        metricsSystem.createCounter(</span>
            BesuMetricCategory.PERMISSIONING,
            &quot;node_local_check_count&quot;,
            &quot;Number of times the node local permissioning provider has been checked&quot;);
<span class="fc" id="L90">    this.checkCounterPermitted =</span>
<span class="fc" id="L91">        metricsSystem.createCounter(</span>
            BesuMetricCategory.PERMISSIONING,
            &quot;node_local_check_count_permitted&quot;,
            &quot;Number of times the node local permissioning provider has been checked and returned permitted&quot;);
<span class="fc" id="L95">    this.checkCounterUnpermitted =</span>
<span class="fc" id="L96">        metricsSystem.createCounter(</span>
            BesuMetricCategory.PERMISSIONING,
            &quot;node_local_check_count_unpermitted&quot;,
            &quot;Number of times the node local permissioning provider has been checked and returned unpermitted&quot;);
<span class="fc" id="L100">  }</span>

  private void readNodesFromConfig(final LocalPermissioningConfiguration configuration) {
<span class="pc bpc" id="L103" title="1 of 4 branches missed.">    if (configuration.isNodeAllowlistEnabled() &amp;&amp; configuration.getNodeAllowlist() != null) {</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">      for (EnodeURL enodeURL : configuration.getNodeAllowlist()) {</span>
<span class="fc" id="L105">        addNode(enodeURL);</span>
<span class="fc" id="L106">      }</span>
    }
<span class="fc" id="L108">  }</span>

  public NodesAllowlistResult addNodes(final List&lt;String&gt; enodeURLs) {
<span class="fc" id="L111">    final NodesAllowlistResult inputValidationResult = validInput(enodeURLs);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (inputValidationResult.result() != AllowlistOperationResult.SUCCESS) {</span>
<span class="fc" id="L113">      return inputValidationResult;</span>
    }
<span class="fc" id="L115">    final List&lt;EnodeURL&gt; peers =</span>
<span class="fc" id="L116">        enodeURLs.stream()</span>
<span class="fc" id="L117">            .map(url -&gt; EnodeURLImpl.fromString(url, configuration.getEnodeDnsConfiguration()))</span>
<span class="fc" id="L118">            .collect(Collectors.toList());</span>

<span class="fc bfc" id="L120" title="All 2 branches covered.">    for (EnodeURL peer : peers) {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">      if (nodesAllowlist.contains(peer)) {</span>
<span class="fc" id="L122">        return new NodesAllowlistResult(</span>
            AllowlistOperationResult.ERROR_EXISTING_ENTRY,
<span class="fc" id="L124">            String.format(&quot;Specified peer: %s already exists in allowlist.&quot;, peer.getNodeId()));</span>
      }
<span class="fc" id="L126">    }</span>

<span class="fc" id="L128">    final List&lt;EnodeURL&gt; oldAllowlist = new ArrayList&lt;&gt;(this.nodesAllowlist);</span>
<span class="fc" id="L129">    peers.forEach(this::addNode);</span>
<span class="fc" id="L130">    notifyListUpdatedSubscribers(new NodeAllowlistUpdatedEvent(peers, Collections.emptyList()));</span>

<span class="fc" id="L132">    final NodesAllowlistResult updateConfigFileResult = updateAllowlistInConfigFile(oldAllowlist);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">    if (updateConfigFileResult.result() != AllowlistOperationResult.SUCCESS) {</span>
<span class="fc" id="L134">      return updateConfigFileResult;</span>
    }

<span class="fc" id="L137">    return new NodesAllowlistResult(AllowlistOperationResult.SUCCESS);</span>
  }

  public boolean addNode(final EnodeURL enodeURL) {
<span class="fc" id="L141">    return nodesAllowlist.add(enodeURL);</span>
  }

  public NodesAllowlistResult removeNodes(final List&lt;String&gt; enodeURLs) {
<span class="fc" id="L145">    final NodesAllowlistResult inputValidationResult = validInput(enodeURLs);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (inputValidationResult.result() != AllowlistOperationResult.SUCCESS) {</span>
<span class="fc" id="L147">      return inputValidationResult;</span>
    }
<span class="fc" id="L149">    final List&lt;EnodeURL&gt; peers =</span>
<span class="fc" id="L150">        enodeURLs.stream()</span>
<span class="fc" id="L151">            .map(url -&gt; EnodeURLImpl.fromString(url, configuration.getEnodeDnsConfiguration()))</span>
<span class="fc" id="L152">            .collect(Collectors.toList());</span>

<span class="fc" id="L154">    boolean anyBootnode = peers.stream().anyMatch(fixedNodes::contains);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">    if (anyBootnode) {</span>
<span class="fc" id="L156">      return new NodesAllowlistResult(AllowlistOperationResult.ERROR_FIXED_NODE_CANNOT_BE_REMOVED);</span>
    }

<span class="fc bfc" id="L159" title="All 2 branches covered.">    for (EnodeURL peer : peers) {</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">      if (!(nodesAllowlist.contains(peer))) {</span>
<span class="fc" id="L161">        return new NodesAllowlistResult(</span>
            AllowlistOperationResult.ERROR_ABSENT_ENTRY,
<span class="fc" id="L163">            String.format(&quot;Specified peer: %s does not exist in allowlist.&quot;, peer.getNodeId()));</span>
      }
<span class="fc" id="L165">    }</span>

<span class="fc" id="L167">    final List&lt;EnodeURL&gt; oldAllowlist = new ArrayList&lt;&gt;(this.nodesAllowlist);</span>
<span class="fc" id="L168">    peers.forEach(this::removeNode);</span>
<span class="fc" id="L169">    notifyListUpdatedSubscribers(new NodeAllowlistUpdatedEvent(Collections.emptyList(), peers));</span>

<span class="fc" id="L171">    final NodesAllowlistResult updateConfigFileResult = updateAllowlistInConfigFile(oldAllowlist);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (updateConfigFileResult.result() != AllowlistOperationResult.SUCCESS) {</span>
<span class="nc" id="L173">      return updateConfigFileResult;</span>
    }

<span class="fc" id="L176">    return new NodesAllowlistResult(AllowlistOperationResult.SUCCESS);</span>
  }

  private boolean removeNode(final EnodeURL enodeURL) {
<span class="fc" id="L180">    return nodesAllowlist.remove(enodeURL);</span>
  }

  private NodesAllowlistResult updateAllowlistInConfigFile(final List&lt;EnodeURL&gt; oldAllowlist) {
    try {
<span class="fc" id="L185">      verifyConfigurationFileState(peerToEnodeURI(oldAllowlist));</span>
<span class="fc" id="L186">      updateConfigurationFile(peerToEnodeURI(nodesAllowlist));</span>
<span class="fc" id="L187">      verifyConfigurationFileState(peerToEnodeURI(nodesAllowlist));</span>
<span class="fc" id="L188">    } catch (IOException e) {</span>
<span class="fc" id="L189">      revertState(oldAllowlist);</span>
<span class="fc" id="L190">      return new NodesAllowlistResult(AllowlistOperationResult.ERROR_ALLOWLIST_PERSIST_FAIL);</span>
<span class="nc" id="L191">    } catch (AllowlistFileSyncException e) {</span>
<span class="nc" id="L192">      return new NodesAllowlistResult(AllowlistOperationResult.ERROR_ALLOWLIST_FILE_SYNC);</span>
<span class="fc" id="L193">    }</span>

<span class="fc" id="L195">    return new NodesAllowlistResult(AllowlistOperationResult.SUCCESS);</span>
  }

  private NodesAllowlistResult validInput(final List&lt;String&gt; peers) {
<span class="fc bfc" id="L199" title="All 4 branches covered.">    if (peers == null || peers.isEmpty()) {</span>
<span class="fc" id="L200">      return new NodesAllowlistResult(</span>
<span class="fc" id="L201">          AllowlistOperationResult.ERROR_EMPTY_ENTRY, String.format(&quot;Null/empty peers list&quot;));</span>
    }

<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (peerListHasDuplicates(peers)) {</span>
<span class="fc" id="L205">      return new NodesAllowlistResult(</span>
          AllowlistOperationResult.ERROR_DUPLICATED_ENTRY,
<span class="fc" id="L207">          String.format(&quot;Specified peer list contains duplicates&quot;));</span>
    }

<span class="fc" id="L210">    return new NodesAllowlistResult(AllowlistOperationResult.SUCCESS);</span>
  }

  private boolean peerListHasDuplicates(final List&lt;String&gt; peers) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    return !peers.stream().allMatch(new HashSet&lt;&gt;()::add);</span>
  }

  private void verifyConfigurationFileState(final Collection&lt;String&gt; oldNodes)
      throws IOException, AllowlistFileSyncException {
<span class="fc" id="L219">    allowlistPersistor.verifyConfigFileMatchesState(ALLOWLIST_TYPE.NODES, oldNodes);</span>
<span class="fc" id="L220">  }</span>

  private void updateConfigurationFile(final Collection&lt;String&gt; nodes) throws IOException {
<span class="fc" id="L223">    allowlistPersistor.updateConfig(ALLOWLIST_TYPE.NODES, nodes);</span>
<span class="fc" id="L224">  }</span>

  private void revertState(final List&lt;EnodeURL&gt; nodesAllowlist) {
<span class="fc" id="L227">    this.nodesAllowlist.clear();</span>
<span class="fc" id="L228">    this.nodesAllowlist.addAll(nodesAllowlist);</span>
<span class="fc" id="L229">  }</span>

  private Collection&lt;String&gt; peerToEnodeURI(final Collection&lt;EnodeURL&gt; peers) {
<span class="fc" id="L232">    return peers.parallelStream().map(EnodeURL::toString).collect(Collectors.toList());</span>
  }

  public boolean isPermitted(final String enodeURL) {
<span class="fc" id="L236">    return isPermitted(EnodeURLImpl.fromString(enodeURL, configuration.getEnodeDnsConfiguration()));</span>
  }

  public boolean isPermitted(final EnodeURL node) {
<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (Objects.equals(localNodeId, node.getNodeId())) {</span>
<span class="fc" id="L241">      return true;</span>
    }
<span class="fc" id="L243">    return nodesAllowlist.stream().anyMatch(p -&gt; EnodeURLImpl.sameListeningEndpoint(p, node));</span>
  }

  public List&lt;String&gt; getNodesAllowlist() {
<span class="fc" id="L247">    return nodesAllowlist.stream().map(Object::toString).collect(Collectors.toList());</span>
  }

  public synchronized void reload() throws RuntimeException {
<span class="fc" id="L251">    final List&lt;EnodeURL&gt; currentAccountsList = new ArrayList&lt;&gt;(nodesAllowlist);</span>
<span class="fc" id="L252">    nodesAllowlist.clear();</span>

    try {
<span class="fc" id="L255">      final LocalPermissioningConfiguration updatedConfig =</span>
<span class="fc" id="L256">          PermissioningConfigurationBuilder.permissioningConfiguration(</span>
<span class="fc" id="L257">              configuration.isNodeAllowlistEnabled(),</span>
<span class="fc" id="L258">              configuration.getEnodeDnsConfiguration(),</span>
<span class="fc" id="L259">              configuration.getNodePermissioningConfigFilePath(),</span>
<span class="fc" id="L260">              configuration.isAccountAllowlistEnabled(),</span>
<span class="fc" id="L261">              configuration.getAccountPermissioningConfigFilePath());</span>

<span class="fc" id="L263">      readNodesFromConfig(updatedConfig);</span>
<span class="fc" id="L264">      configuration = updatedConfig;</span>

<span class="fc" id="L266">      createNodeAllowlistModifiedEventAfterReload(currentAccountsList, nodesAllowlist);</span>
<span class="fc" id="L267">    } catch (Exception e) {</span>
<span class="fc" id="L268">      nodesAllowlist.clear();</span>
<span class="fc" id="L269">      nodesAllowlist.addAll(currentAccountsList);</span>
<span class="fc" id="L270">      throw new IllegalStateException(</span>
          &quot;Error reloading permissions file. In-memory nodes allowlist will be reverted to previous valid configuration&quot;,
          e);
<span class="fc" id="L273">    }</span>
<span class="fc" id="L274">  }</span>

  private void createNodeAllowlistModifiedEventAfterReload(
      final List&lt;EnodeURL&gt; previousNodeAllowlist, final List&lt;EnodeURL&gt; currentNodesList) {
<span class="fc" id="L278">    final List&lt;EnodeURL&gt; removedNodes =</span>
<span class="fc" id="L279">        previousNodeAllowlist.stream()</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            .filter(n -&gt; !currentNodesList.contains(n))</span>
<span class="fc" id="L281">            .collect(Collectors.toList());</span>

<span class="fc" id="L283">    final List&lt;EnodeURL&gt; addedNodes =</span>
<span class="fc" id="L284">        currentNodesList.stream()</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            .filter(n -&gt; !previousNodeAllowlist.contains(n))</span>
<span class="fc" id="L286">            .collect(Collectors.toList());</span>

<span class="pc bpc" id="L288" title="1 of 4 branches missed.">    if (!removedNodes.isEmpty() || !addedNodes.isEmpty()) {</span>
<span class="fc" id="L289">      notifyListUpdatedSubscribers(new NodeAllowlistUpdatedEvent(addedNodes, removedNodes));</span>
    }
<span class="fc" id="L291">  }</span>

  public long subscribeToListUpdatedEvent(final Consumer&lt;NodeAllowlistUpdatedEvent&gt; subscriber) {
<span class="fc" id="L294">    return nodeAllowlistUpdatedObservers.subscribe(subscriber);</span>
  }

  private void notifyListUpdatedSubscribers(final NodeAllowlistUpdatedEvent event) {
<span class="fc" id="L298">    LOG.trace(</span>
        &quot;Sending NodeAllowlistUpdatedEvent (added: {}, removed {})&quot;,
<span class="fc" id="L300">        event.getAddedNodes().size(),</span>
<span class="fc" id="L301">        event.getRemovedNodes().size());</span>

<span class="fc" id="L303">    nodeAllowlistUpdatedObservers.forEach(c -&gt; c.accept(event));</span>
<span class="fc" id="L304">  }</span>

  public static class NodesAllowlistResult {
    private final AllowlistOperationResult result;
    private final Optional&lt;String&gt; message;

<span class="fc" id="L310">    NodesAllowlistResult(final AllowlistOperationResult result, final String message) {</span>
<span class="fc" id="L311">      this.result = result;</span>
<span class="fc" id="L312">      this.message = Optional.of(message);</span>
<span class="fc" id="L313">    }</span>

    @VisibleForTesting
<span class="fc" id="L316">    public NodesAllowlistResult(final AllowlistOperationResult result) {</span>
<span class="fc" id="L317">      this.result = result;</span>
<span class="fc" id="L318">      this.message = Optional.empty();</span>
<span class="fc" id="L319">    }</span>

    public AllowlistOperationResult result() {
<span class="fc" id="L322">      return result;</span>
    }

    public Optional&lt;String&gt; message() {
<span class="nc" id="L326">      return message;</span>
    }
  }

  @Override
  public boolean isConnectionPermitted(
      final EnodeURL sourceEnode, final EnodeURL destinationEnode) {
<span class="fc" id="L333">    this.checkCounter.inc();</span>
<span class="pc bpc" id="L334" title="1 of 4 branches missed.">    if (isPermitted(sourceEnode) &amp;&amp; isPermitted(destinationEnode)) {</span>
<span class="fc" id="L335">      this.checkCounterPermitted.inc();</span>
<span class="fc" id="L336">      return true;</span>
    } else {
<span class="fc" id="L338">      this.checkCounterUnpermitted.inc();</span>
<span class="fc" id="L339">      return false;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>