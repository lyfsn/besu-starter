<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Framer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.ethereum.p2p.rlpx.framing</a> &gt; <span class="el_source">Framer.java</span></div><h1>Framer.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.ethereum.p2p.rlpx.framing;

import static io.netty.buffer.ByteBufUtil.hexDump;
import static io.netty.buffer.Unpooled.wrappedBuffer;
import static org.hyperledger.besu.ethereum.p2p.rlpx.RlpxFrameConstants.LENGTH_FRAME_SIZE;
import static org.hyperledger.besu.ethereum.p2p.rlpx.RlpxFrameConstants.LENGTH_MAX_MESSAGE_FRAME;

import org.hyperledger.besu.ethereum.p2p.rlpx.handshake.HandshakeSecrets;
import org.hyperledger.besu.ethereum.p2p.rlpx.handshake.Handshaker;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.MessageData;
import org.hyperledger.besu.ethereum.p2p.rlpx.wire.RawMessage;
import org.hyperledger.besu.ethereum.rlp.RLP;

import java.util.Arrays;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.FormatMethod;
import io.netty.buffer.ByteBuf;
import org.apache.tuweni.bytes.Bytes;
import org.apache.tuweni.bytes.MutableBytes;
import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.modes.SICBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This component is responsible for reading and composing RLPx protocol frames, conformant to the
 * schemes defined in the Ethereum protocols.
 *
 * &lt;p&gt;These frames are encrypted and authenticated using the secrets generated during the
 * cryptographic handshake ({@link Handshaker}.
 *
 * &lt;p&gt;This component is well-versed in TCP streaming complexities: it is capable of processing
 * fragmented frames, as well as streams of multiple messages within the same incoming buffer, as
 * long as the order of incoming bytes matches the underlying TCP sequence.
 *
 * @see &lt;a href=&quot;https://github.com/ethereum/devp2p/blob/master/rlpx.md#framing&quot;&gt;RLPx framing&lt;/a&gt;
 */
public class Framer {
<span class="fc" id="L59">  private static final Logger LOG = LoggerFactory.getLogger(Framer.class);</span>

  private static final int LENGTH_HEADER_DATA = 16;
  private static final int LENGTH_MAC = 16;
  private static final int LENGTH_FULL_HEADER = LENGTH_HEADER_DATA + LENGTH_MAC;
  private static final int LENGTH_MESSAGE_ID = 1;

<span class="fc" id="L66">  private static final byte[] IV = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};</span>
<span class="fc" id="L67">  private static final byte[] PROTOCOL_HEADER =</span>
<span class="fc" id="L68">      RLP.encode(</span>
              out -&gt; {
<span class="fc" id="L70">                out.startList();</span>
<span class="fc" id="L71">                out.writeNull();</span>
<span class="fc" id="L72">                out.writeNull();</span>
<span class="fc" id="L73">                out.endList();</span>
<span class="fc" id="L74">              })</span>
<span class="fc" id="L75">          .toArray();</span>

  private final HandshakeSecrets secrets;
<span class="fc" id="L78">  private static final SnappyCompressor compressor = new SnappyCompressor();</span>
  private final StreamCipher encryptor;
  private final StreamCipher decryptor;
  private final BlockCipher macEncryptor;
  private boolean headerProcessed;
  private int frameSize;
<span class="fc" id="L84">  private boolean compressionEnabled = false;</span>
  // have we ever successfully uncompressed a packet?
<span class="fc" id="L86">  private boolean compressionSuccessful = false;</span>

<span class="fc" id="L88">  protected Framer() {</span>
<span class="fc" id="L89">    this.secrets = null;</span>
<span class="fc" id="L90">    this.encryptor = null;</span>
<span class="fc" id="L91">    this.decryptor = null;</span>
<span class="fc" id="L92">    this.macEncryptor = null;</span>
<span class="fc" id="L93">  }</span>

  /**
   * Creates a new framer out of the handshake secrets derived during the cryptographic handshake.
   *
   * @param secrets The handshake secrets.
   */
<span class="fc" id="L100">  public Framer(final HandshakeSecrets secrets) {</span>
<span class="fc" id="L101">    this.secrets = secrets;</span>

<span class="fc" id="L103">    final KeyParameter aesKey = new KeyParameter(secrets.getAesSecret());</span>
<span class="fc" id="L104">    final KeyParameter macKey = new KeyParameter(secrets.getMacSecret());</span>

<span class="fc" id="L106">    encryptor = new SICBlockCipher(new AESEngine());</span>
<span class="fc" id="L107">    encryptor.init(true, new ParametersWithIV(aesKey, IV));</span>

<span class="fc" id="L109">    decryptor = new SICBlockCipher(new AESEngine());</span>
<span class="fc" id="L110">    decryptor.init(false, new ParametersWithIV(aesKey, IV));</span>

<span class="fc" id="L112">    macEncryptor = new AESEngine();</span>
<span class="fc" id="L113">    macEncryptor.init(true, macKey);</span>
<span class="fc" id="L114">  }</span>

  public void enableCompression() {
<span class="fc" id="L117">    this.compressionEnabled = true;</span>
<span class="fc" id="L118">  }</span>

  public void disableCompression() {
<span class="nc" id="L121">    this.compressionEnabled = false;</span>
<span class="nc" id="L122">  }</span>

  boolean isCompressionEnabled() {
<span class="fc" id="L125">    return compressionEnabled;</span>
  }

  boolean isCompressionSuccessful() {
<span class="fc" id="L129">    return compressionSuccessful;</span>
  }

  /**
   * Deframes a full message from the byte buffer, if possible.
   *
   * &lt;p&gt;If the byte buffer contains insufficient bytes to extract a full message, this method
   * returns &lt;code&gt;null&lt;/code&gt;.
   *
   * &lt;p&gt;If the buffer contains at least a header, it offloads it and processes it, setting an
   * internal expectation to subsequently receive as many bytes for the frame as the header
   * specified. In this case, this method also returns &lt;code&gt;null&lt;/code&gt; to inform the caller that
   * it requires more bytes before it can produce an output.
   *
   * &lt;p&gt;This method can be called repetitively whenever new bytes appear in the buffer. It is worthy
   * to note that the byte buffer is not consumed unless the next expected amount of bytes appears.
   *
   * &lt;p&gt;If there is more than one message in the byte buffer, only the first one is returned,
   * consuming it from the byte buffer. The caller should call this method again with the same byte
   * buffer to continue extracting more messages, if possible.
   *
   * &lt;p&gt;When this method throws an exception, it is recommended that the caller scraps away the RLPx
   * connection, as the digests and stream ciphers could have become corrupted.
   *
   * @param buf The buffer containing no messages, partial messages or multiple messages.
   * @return The first fully extracted message from this buffer, or &lt;code&gt;null&lt;/code&gt; if no message
   *     could be extracted yet.
   * @throws FramingException Thrown when a decryption or internal error occurs.
   */
  public synchronized MessageData deframe(final ByteBuf buf) throws FramingException {
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">    if (buf == null || !buf.isReadable()) {</span>
<span class="fc" id="L160">      return null;</span>
    }

<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (!headerProcessed) {</span>
      // We don't have enough bytes to read the header.
<span class="fc bfc" id="L165" title="All 2 branches covered.">      if (buf.readableBytes() &lt; LENGTH_FULL_HEADER) {</span>
<span class="fc" id="L166">        return null;</span>
      }
<span class="fc" id="L168">      frameSize = processHeader(buf.readSlice(LENGTH_FULL_HEADER));</span>
<span class="fc" id="L169">      headerProcessed = true;</span>
<span class="fc" id="L170">      buf.discardReadBytes();</span>
    }

<span class="fc" id="L173">    final int size = frameSize + padding16(frameSize) + LENGTH_MAC;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">    if (buf.readableBytes() &lt; size) {</span>
<span class="fc" id="L175">      return null;</span>
    }

<span class="fc" id="L178">    final MessageData msg = processFrame(buf.readSlice(size), frameSize);</span>
<span class="fc" id="L179">    buf.discardReadBytes();</span>
<span class="fc" id="L180">    headerProcessed = false;</span>
<span class="fc" id="L181">    return msg;</span>
  }

  /**
   * Parses, decrypts and performs MAC verification on a packet header.
   *
   * &lt;p&gt;This method expects a buffer containing the exact number of bytes a well-formed header
   * consists of (32 bytes at this time). Returns the frame size as extracted from the header.
   *
   * @param encryptedHeader The header as seen on the wire.
   * @return The frame size as extracted from the header.
   * @throws FramingException If header parsing or decryption failed.
   */
  private int processHeader(final ByteBuf encryptedHeader) throws FramingException {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">    if (encryptedHeader.readableBytes() != LENGTH_FULL_HEADER) {</span>
<span class="nc" id="L196">      throw error(</span>
          &quot;Expected %s bytes in header, got %s&quot;,
<span class="nc" id="L198">          LENGTH_FULL_HEADER, encryptedHeader.readableBytes());</span>
    }

    // Decrypt the header.
<span class="fc" id="L202">    final byte[] hCipher = new byte[LENGTH_HEADER_DATA];</span>
<span class="fc" id="L203">    final byte[] hMac = new byte[LENGTH_MAC];</span>
<span class="fc" id="L204">    encryptedHeader.readBytes(hCipher).readBytes(hMac);</span>

    // Header MAC validation.
<span class="fc" id="L207">    byte[] expectedMac = new byte[16];</span>
<span class="fc" id="L208">    macEncryptor.processBlock(secrets.getIngressMac(), 0, expectedMac, 0);</span>
<span class="fc" id="L209">    expectedMac = secrets.updateIngress(xor(expectedMac, hCipher)).getIngressMac();</span>
<span class="fc" id="L210">    expectedMac = Arrays.copyOf(expectedMac, LENGTH_MAC);</span>

<span class="fc" id="L212">    validateMac(hMac, expectedMac);</span>

    // Perform the header decryption.
<span class="fc" id="L215">    decryptor.processBytes(hCipher, 0, hCipher.length, hCipher, 0);</span>
<span class="fc" id="L216">    final ByteBuf h = wrappedBuffer(hCipher);</span>

    // Read the frame length.
<span class="fc" id="L219">    final byte[] length = new byte[3];</span>
<span class="fc" id="L220">    h.readBytes(length);</span>
<span class="fc" id="L221">    int frameSize = length[0] &amp; 0xff;</span>
<span class="fc" id="L222">    frameSize = (frameSize &lt;&lt; 8) + (length[1] &amp; 0xff);</span>
<span class="fc" id="L223">    frameSize = (frameSize &lt;&lt; 8) + (length[2] &amp; 0xff);</span>

    // Discard the header data (RLP): being set to fixed value 0xc28080 (list of two null
    // elements) by other clients.
<span class="fc" id="L227">    final int headerDataLength = RLP.calculateSize(Bytes.wrapByteBuffer(h.nioBuffer()));</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (h.readableBytes() &lt; headerDataLength) {</span>
<span class="fc" id="L229">      throw error(</span>
          &quot;Expected at least %d readable bytes while processing header, remaining: %s&quot;,
<span class="fc" id="L231">          headerDataLength, h.readableBytes());</span>
    }
<span class="fc" id="L233">    h.skipBytes(headerDataLength);</span>

    // Discard padding in header (= zero-fill to 16-byte boundary).
<span class="fc" id="L236">    h.skipBytes(padding16(LENGTH_FRAME_SIZE + headerDataLength));</span>

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if (h.readableBytes() != 0) {</span>
<span class="nc" id="L239">      throw error(</span>
          &quot;Expected no more readable bytes while processing header, remaining: %s&quot;,
<span class="nc" id="L241">          h.readableBytes());</span>
    }

<span class="fc" id="L244">    h.discardReadBytes();</span>
<span class="fc" id="L245">    return frameSize;</span>
  }

  /**
   * Parses, decrypts and performs MAC verification on a frame.
   *
   * &lt;p&gt;This method expects a well-formed frame, sized according to the length indicated in this
   * packet's header.
   *
   * @param f The buffer containing
   * @param frameSize The expected
   */
  private MessageData processFrame(final ByteBuf f, final int frameSize) {
<span class="fc" id="L258">    final int pad = padding16(frameSize);</span>
<span class="fc" id="L259">    final int expectedSize = frameSize + pad + LENGTH_MAC;</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">    if (f.readableBytes() != expectedSize) {</span>
<span class="nc" id="L261">      throw error(&quot;Expected %s bytes in header, got %s&quot;, expectedSize, f.readableBytes());</span>
    }

<span class="fc" id="L264">    final byte[] frameData = new byte[frameSize + pad];</span>
<span class="fc" id="L265">    final byte[] fMac = new byte[LENGTH_MAC];</span>
<span class="fc" id="L266">    f.readBytes(frameData).readBytes(fMac);</span>

    // Validate the frame's MAC.
<span class="fc" id="L269">    final byte[] fMacSeed = secrets.updateIngress(frameData).getIngressMac();</span>
<span class="fc" id="L270">    final byte[] fMacSeedEnc = new byte[16];</span>
<span class="fc" id="L271">    macEncryptor.processBlock(fMacSeed, 0, fMacSeedEnc, 0);</span>
<span class="fc" id="L272">    byte[] expectedMac = secrets.updateIngress(xor(fMacSeedEnc, fMacSeed)).getIngressMac();</span>
<span class="fc" id="L273">    expectedMac = Arrays.copyOf(expectedMac, LENGTH_MAC);</span>

<span class="fc" id="L275">    validateMac(fMac, expectedMac);</span>

    // Decrypt frame data.
<span class="fc" id="L278">    decryptor.processBytes(frameData, 0, frameData.length, frameData, 0);</span>

    // Read the id.
<span class="fc" id="L281">    final Bytes idbv = RLP.decodeOne(Bytes.of(frameData[0]));</span>
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">    final int id = idbv.isZero() || idbv.size() == 0 ? 0 : idbv.get(0);</span>

    // Write message data to ByteBuf, decompressing as necessary
    final Bytes data;
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (compressionEnabled) {</span>
<span class="fc" id="L287">      final byte[] compressedMessageData = Arrays.copyOfRange(frameData, 1, frameData.length - pad);</span>
<span class="fc" id="L288">      final int uncompressedLength = compressor.uncompressedLength(compressedMessageData);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">      if (uncompressedLength &gt;= LENGTH_MAX_MESSAGE_FRAME) {</span>
<span class="fc" id="L290">        throw error(&quot;Message size %s in excess of maximum length.&quot;, uncompressedLength);</span>
      }
      Bytes _data;
      try {
<span class="fc" id="L294">        final byte[] decompressedMessageData = compressor.decompress(compressedMessageData);</span>
<span class="fc" id="L295">        _data = Bytes.wrap(decompressedMessageData);</span>
<span class="fc" id="L296">        compressionSuccessful = true;</span>
<span class="fc" id="L297">      } catch (final FramingException fe) {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (compressionSuccessful) {</span>
<span class="nc" id="L299">          throw fe;</span>
        } else {
          // OpenEthereum/Parity does not implement EIP-706
          // If failing on the first packet downgrade to uncompressed
<span class="fc" id="L303">          compressionEnabled = false;</span>
<span class="fc" id="L304">          LOG.debug(&quot;Snappy decompression failed: downgrading to uncompressed&quot;);</span>
<span class="fc" id="L305">          final int messageLength = frameSize - LENGTH_MESSAGE_ID;</span>
<span class="fc" id="L306">          _data = Bytes.wrap(frameData, 1, messageLength);</span>
        }
<span class="fc" id="L308">      }</span>
<span class="fc" id="L309">      data = _data;</span>
<span class="fc" id="L310">    } else {</span>
      // Move data to a ByteBuf
<span class="fc" id="L312">      final int messageLength = frameSize - LENGTH_MESSAGE_ID;</span>
<span class="fc" id="L313">      data = Bytes.wrap(frameData, 1, messageLength);</span>
    }

<span class="fc" id="L316">    return new RawMessage(id, data);</span>
  }

  private void validateMac(final byte[] candidateMac, final byte[] expectedMac) {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (!Arrays.equals(expectedMac, candidateMac)) {</span>
<span class="nc" id="L321">      throw error(</span>
          &quot;Frame MAC did not match expected MAC; expected: %s, received: %s&quot;,
<span class="nc" id="L323">          hexDump(expectedMac), hexDump(candidateMac));</span>
    }
<span class="fc" id="L325">  }</span>

  /**
   * Frames a message for sending to an RLPx peer, encrypting it and calculating the appropriate
   * MACs.
   *
   * @param message The message to frame.
   * @param output The {@link ByteBuf} to write framed data to.
   */
  public synchronized void frame(final MessageData message, final ByteBuf output) {
<span class="fc" id="L335">    Preconditions.checkArgument(</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        message.getSize() &lt; LENGTH_MAX_MESSAGE_FRAME, &quot;Message size in excess of maximum length.&quot;);</span>
    // Compress message
<span class="fc bfc" id="L338" title="All 2 branches covered.">    if (compressionEnabled) {</span>
      // Extract data from message
      // Compress data
<span class="fc" id="L341">      final byte[] compressed = compressor.compress(message.getData().toArrayUnsafe());</span>
      // Construct new, compressed message
<span class="fc" id="L343">      frameMessage(new RawMessage(message.getCode(), Bytes.wrap(compressed)), output);</span>
<span class="fc" id="L344">    } else {</span>
<span class="fc" id="L345">      frameMessage(message, output);</span>
    }
<span class="fc" id="L347">  }</span>

  @VisibleForTesting
  void frameMessage(final MessageData message, final ByteBuf buf) {
<span class="fc" id="L351">    final int frameSize = message.getSize() + LENGTH_MESSAGE_ID;</span>
<span class="fc" id="L352">    final int pad = padding16(frameSize);</span>

<span class="fc" id="L354">    final byte id = (byte) message.getCode();</span>

    // Generate the header data.
<span class="fc" id="L357">    final byte[] h = new byte[LENGTH_HEADER_DATA];</span>
<span class="fc" id="L358">    h[0] = (byte) ((frameSize &gt;&gt; 16) &amp; 0xff);</span>
<span class="fc" id="L359">    h[1] = (byte) ((frameSize &gt;&gt; 8) &amp; 0xff);</span>
<span class="fc" id="L360">    h[2] = (byte) (frameSize &amp; 0xff);</span>
<span class="fc" id="L361">    System.arraycopy(PROTOCOL_HEADER, 0, h, LENGTH_FRAME_SIZE, PROTOCOL_HEADER.length);</span>
<span class="fc" id="L362">    Arrays.fill(h, LENGTH_FRAME_SIZE + PROTOCOL_HEADER.length, h.length - 1, (byte) 0x00);</span>
<span class="fc" id="L363">    encryptor.processBytes(h, 0, LENGTH_HEADER_DATA, h, 0);</span>

    // Generate the header MAC.
<span class="fc" id="L366">    byte[] hMac = Arrays.copyOf(secrets.getEgressMac(), LENGTH_MAC);</span>
<span class="fc" id="L367">    macEncryptor.processBlock(hMac, 0, hMac, 0);</span>
<span class="fc" id="L368">    hMac = secrets.updateEgress(xor(h, hMac)).getEgressMac();</span>
<span class="fc" id="L369">    hMac = Arrays.copyOf(hMac, LENGTH_MAC);</span>
<span class="fc" id="L370">    buf.writeBytes(h).writeBytes(hMac);</span>

    // Encrypt payload.
<span class="fc" id="L373">    final MutableBytes f = MutableBytes.create(frameSize + pad);</span>

<span class="fc bfc" id="L375" title="All 2 branches covered.">    final Bytes bv = id == 0 ? RLP.NULL : RLP.encodeOne(Bytes.of(id));</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">    assert bv.size() == 1;</span>
<span class="fc" id="L377">    f.set(0, bv.get(0));</span>

    // Zero-padded to 16-byte boundary.
<span class="fc" id="L380">    message.getData().copyTo(f, 1);</span>
<span class="fc" id="L381">    encryptor.processBytes(f.toArrayUnsafe(), 0, f.size(), f.toArrayUnsafe(), 0);</span>

    // Calculate the frame MAC.
<span class="fc" id="L384">    final byte[] fMacSeed =</span>
<span class="fc" id="L385">        Arrays.copyOf(secrets.updateEgress(f.toArrayUnsafe()).getEgressMac(), LENGTH_MAC);</span>
<span class="fc" id="L386">    byte[] fMac = new byte[16];</span>
<span class="fc" id="L387">    macEncryptor.processBlock(fMacSeed, 0, fMac, 0);</span>
<span class="fc" id="L388">    fMac = Arrays.copyOf(secrets.updateEgress(xor(fMac, fMacSeed)).getEgressMac(), LENGTH_MAC);</span>

<span class="fc" id="L390">    buf.writeBytes(f.toArrayUnsafe()).writeBytes(fMac);</span>
<span class="fc" id="L391">  }</span>

  private static int padding16(final int size) {
<span class="fc" id="L394">    final int pad = size % 16;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">    return pad == 0 ? 0 : 16 - pad;</span>
  }

  /**
   * Compute the bitwise XOR of two arrays of bytes. The arrays have to be of same length. No length
   * checking is performed.
   *
   * @param x1 the first array
   * @param x2 the second array
   * @return x1 XOR x2
   */
  private static byte[] xor(final byte[] x1, final byte[] x2) {
<span class="fc" id="L407">    byte[] out = new byte[x1.length];</span>

<span class="fc bfc" id="L409" title="All 2 branches covered.">    for (int i = x1.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L410">      out[i] = (byte) (x1[i] ^ x2[i]);</span>
    }
<span class="fc" id="L412">    return out;</span>
  }

  @FormatMethod
  private static FramingException error(final String s, final Object... params) {
<span class="fc" id="L417">    return new FramingException(String.format(s, params));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>