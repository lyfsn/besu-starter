<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QbftRound.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.qbft.statemachine</a> &gt; <span class="el_source">QbftRound.java</span></div><h1>QbftRound.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.qbft.statemachine;

import static java.util.Collections.emptyList;

import org.hyperledger.besu.consensus.common.bft.BftBlockHashing;
import org.hyperledger.besu.consensus.common.bft.BftBlockHeaderFunctions;
import org.hyperledger.besu.consensus.common.bft.BftBlockInterface;
import org.hyperledger.besu.consensus.common.bft.BftContext;
import org.hyperledger.besu.consensus.common.bft.BftExtraData;
import org.hyperledger.besu.consensus.common.bft.BftExtraDataCodec;
import org.hyperledger.besu.consensus.common.bft.BftHelpers;
import org.hyperledger.besu.consensus.common.bft.ConsensusRoundIdentifier;
import org.hyperledger.besu.consensus.common.bft.RoundTimer;
import org.hyperledger.besu.consensus.common.bft.payload.SignedData;
import org.hyperledger.besu.consensus.qbft.messagewrappers.Commit;
import org.hyperledger.besu.consensus.qbft.messagewrappers.Prepare;
import org.hyperledger.besu.consensus.qbft.messagewrappers.Proposal;
import org.hyperledger.besu.consensus.qbft.network.QbftMessageTransmitter;
import org.hyperledger.besu.consensus.qbft.payload.MessageFactory;
import org.hyperledger.besu.consensus.qbft.payload.PreparePayload;
import org.hyperledger.besu.consensus.qbft.payload.RoundChangePayload;
import org.hyperledger.besu.crypto.SECPSignature;
import org.hyperledger.besu.cryptoservices.NodeKey;
import org.hyperledger.besu.datatypes.Hash;
import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.blockcreation.BlockCreator;
import org.hyperledger.besu.ethereum.chain.MinedBlockObserver;
import org.hyperledger.besu.ethereum.core.Block;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.BlockImporter;
import org.hyperledger.besu.ethereum.mainnet.BlockImportResult;
import org.hyperledger.besu.ethereum.mainnet.HeaderValidationMode;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.plugin.services.securitymodule.SecurityModuleException;
import org.hyperledger.besu.util.Subscribers;

import java.util.List;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Qbft round. */
public class QbftRound {

<span class="fc" id="L60">  private static final Logger LOG = LoggerFactory.getLogger(QbftRound.class);</span>

  private final Subscribers&lt;MinedBlockObserver&gt; observers;
  /** The Round state. */
  protected final RoundState roundState;
  /** The Block creator. */
  protected final BlockCreator blockCreator;
  /** The Protocol context. */
  protected final ProtocolContext protocolContext;
  /** The Protocol schedule. */
  protected final ProtocolSchedule protocolSchedule;

  private final NodeKey nodeKey;
  private final MessageFactory messageFactory; // used only to create stored local msgs
  private final QbftMessageTransmitter transmitter;
  /** The Bft extra data codec. */
  protected final BftExtraDataCodec bftExtraDataCodec;

  /**
   * Instantiates a new Qbft round.
   *
   * @param roundState the round state
   * @param blockCreator the block creator
   * @param protocolContext the protocol context
   * @param protocolSchedule the protocol schedule
   * @param observers the observers
   * @param nodeKey the node key
   * @param messageFactory the message factory
   * @param transmitter the transmitter
   * @param roundTimer the round timer
   * @param bftExtraDataCodec the bft extra data codec
   */
  public QbftRound(
      final RoundState roundState,
      final BlockCreator blockCreator,
      final ProtocolContext protocolContext,
      final ProtocolSchedule protocolSchedule,
      final Subscribers&lt;MinedBlockObserver&gt; observers,
      final NodeKey nodeKey,
      final MessageFactory messageFactory,
      final QbftMessageTransmitter transmitter,
      final RoundTimer roundTimer,
<span class="fc" id="L102">      final BftExtraDataCodec bftExtraDataCodec) {</span>
<span class="fc" id="L103">    this.roundState = roundState;</span>
<span class="fc" id="L104">    this.blockCreator = blockCreator;</span>
<span class="fc" id="L105">    this.protocolContext = protocolContext;</span>
<span class="fc" id="L106">    this.protocolSchedule = protocolSchedule;</span>
<span class="fc" id="L107">    this.observers = observers;</span>
<span class="fc" id="L108">    this.nodeKey = nodeKey;</span>
<span class="fc" id="L109">    this.messageFactory = messageFactory;</span>
<span class="fc" id="L110">    this.transmitter = transmitter;</span>
<span class="fc" id="L111">    this.bftExtraDataCodec = bftExtraDataCodec;</span>

<span class="fc" id="L113">    roundTimer.startTimer(getRoundIdentifier());</span>
<span class="fc" id="L114">  }</span>

  /**
   * Gets round identifier.
   *
   * @return the round identifier
   */
  public ConsensusRoundIdentifier getRoundIdentifier() {
<span class="fc" id="L122">    return roundState.getRoundIdentifier();</span>
  }

  /**
   * Create and send proposal message.
   *
   * @param headerTimeStampSeconds the header time stamp seconds
   */
  public void createAndSendProposalMessage(final long headerTimeStampSeconds) {
<span class="fc" id="L131">    LOG.debug(&quot;Creating proposed block. round={}&quot;, roundState.getRoundIdentifier());</span>
<span class="fc" id="L132">    final Block block = blockCreator.createBlock(headerTimeStampSeconds).getBlock();</span>

<span class="fc" id="L134">    LOG.trace(&quot;Creating proposed block blockHeader={}&quot;, block.getHeader());</span>
<span class="fc" id="L135">    updateStateWithProposalAndTransmit(block, emptyList(), emptyList());</span>
<span class="fc" id="L136">  }</span>

  /**
   * Start round with.
   *
   * @param roundChangeArtifacts the round change artifacts
   * @param headerTimestamp the header timestamp
   */
  public void startRoundWith(
      final RoundChangeArtifacts roundChangeArtifacts, final long headerTimestamp) {
<span class="fc" id="L146">    final Optional&lt;PreparedCertificate&gt; bestPreparedCertificate =</span>
<span class="fc" id="L147">        roundChangeArtifacts.getBestPreparedPeer();</span>

    final Block blockToPublish;
<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (bestPreparedCertificate.isEmpty()) {</span>
<span class="fc" id="L151">      LOG.debug(&quot;Sending proposal with new block. round={}&quot;, roundState.getRoundIdentifier());</span>
<span class="fc" id="L152">      blockToPublish = blockCreator.createBlock(headerTimestamp).getBlock();</span>
    } else {
<span class="fc" id="L154">      LOG.debug(</span>
<span class="fc" id="L155">          &quot;Sending proposal from PreparedCertificate. round={}&quot;, roundState.getRoundIdentifier());</span>
<span class="fc" id="L156">      blockToPublish = bestPreparedCertificate.get().getBlock();</span>
    }

<span class="fc" id="L159">    updateStateWithProposalAndTransmit(</span>
        blockToPublish,
<span class="fc" id="L161">        roundChangeArtifacts.getRoundChanges(),</span>
<span class="fc" id="L162">        bestPreparedCertificate.map(PreparedCertificate::getPrepares).orElse(emptyList()));</span>
<span class="fc" id="L163">  }</span>

  /**
   * Update state with proposal and transmit.
   *
   * @param block the block
   * @param roundChanges the round changes
   * @param prepares the prepares
   */
  protected void updateStateWithProposalAndTransmit(
      final Block block,
      final List&lt;SignedData&lt;RoundChangePayload&gt;&gt; roundChanges,
      final List&lt;SignedData&lt;PreparePayload&gt;&gt; prepares) {
    final Proposal proposal;
    try {
<span class="fc" id="L178">      proposal = messageFactory.createProposal(getRoundIdentifier(), block, roundChanges, prepares);</span>
<span class="nc" id="L179">    } catch (final SecurityModuleException e) {</span>
<span class="nc" id="L180">      LOG.warn(&quot;Failed to create a signed Proposal, waiting for next round.&quot;, e);</span>
<span class="nc" id="L181">      return;</span>
<span class="fc" id="L182">    }</span>

<span class="fc" id="L184">    transmitter.multicastProposal(</span>
<span class="fc" id="L185">        proposal.getRoundIdentifier(),</span>
<span class="fc" id="L186">        proposal.getSignedPayload().getPayload().getProposedBlock(),</span>
        roundChanges,
        prepares);
<span class="fc" id="L189">    updateStateWithProposedBlock(proposal);</span>
<span class="fc" id="L190">    sendPrepare(block);</span>
<span class="fc" id="L191">  }</span>

  /**
   * Handle proposal message.
   *
   * @param msg the msg
   */
  public void handleProposalMessage(final Proposal msg) {
<span class="fc" id="L199">    LOG.debug(</span>
        &quot;Received a proposal message. round={}. author={}&quot;,
<span class="fc" id="L201">        roundState.getRoundIdentifier(),</span>
<span class="fc" id="L202">        msg.getAuthor());</span>
<span class="fc" id="L203">    final Block block = msg.getSignedPayload().getPayload().getProposedBlock();</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (updateStateWithProposedBlock(msg)) {</span>
<span class="fc" id="L205">      sendPrepare(block);</span>
    }
<span class="fc" id="L207">  }</span>

  private void sendPrepare(final Block block) {
<span class="fc" id="L210">    LOG.debug(&quot;Sending prepare message. round={}&quot;, roundState.getRoundIdentifier());</span>
    try {
<span class="fc" id="L212">      final Prepare localPrepareMessage =</span>
<span class="fc" id="L213">          messageFactory.createPrepare(getRoundIdentifier(), block.getHash());</span>
<span class="fc" id="L214">      peerIsPrepared(localPrepareMessage);</span>
<span class="fc" id="L215">      transmitter.multicastPrepare(</span>
<span class="fc" id="L216">          localPrepareMessage.getRoundIdentifier(), localPrepareMessage.getDigest());</span>
<span class="fc" id="L217">    } catch (final SecurityModuleException e) {</span>
<span class="fc" id="L218">      LOG.warn(&quot;Failed to create a signed Prepare; {}&quot;, e.getMessage());</span>
<span class="fc" id="L219">    }</span>
<span class="fc" id="L220">  }</span>

  /**
   * Handle prepare message.
   *
   * @param msg the msg
   */
  public void handlePrepareMessage(final Prepare msg) {
<span class="fc" id="L228">    LOG.debug(</span>
        &quot;Received a prepare message. round={}. author={}&quot;,
<span class="fc" id="L230">        roundState.getRoundIdentifier(),</span>
<span class="fc" id="L231">        msg.getAuthor());</span>
<span class="fc" id="L232">    peerIsPrepared(msg);</span>
<span class="fc" id="L233">  }</span>

  /**
   * Handle commit message.
   *
   * @param msg the msg
   */
  public void handleCommitMessage(final Commit msg) {
<span class="fc" id="L241">    LOG.debug(</span>
        &quot;Received a commit message. round={}. author={}&quot;,
<span class="fc" id="L243">        roundState.getRoundIdentifier(),</span>
<span class="fc" id="L244">        msg.getAuthor());</span>
<span class="fc" id="L245">    peerIsCommitted(msg);</span>
<span class="fc" id="L246">  }</span>

  /**
   * Construct prepared certificate.
   *
   * @return the optional PreparedCertificate
   */
  public Optional&lt;PreparedCertificate&gt; constructPreparedCertificate() {
<span class="fc" id="L254">    return roundState.constructPreparedCertificate();</span>
  }

  private boolean updateStateWithProposedBlock(final Proposal msg) {
<span class="fc" id="L258">    final boolean wasPrepared = roundState.isPrepared();</span>
<span class="fc" id="L259">    final boolean wasCommitted = roundState.isCommitted();</span>
<span class="fc" id="L260">    final boolean blockAccepted = roundState.setProposedBlock(msg);</span>

<span class="pc bpc" id="L262" title="1 of 2 branches missed.">    if (blockAccepted) {</span>
<span class="fc" id="L263">      final Block block = roundState.getProposedBlock().get();</span>
      final SECPSignature commitSeal;
      try {
<span class="fc" id="L266">        commitSeal = createCommitSeal(block);</span>
<span class="fc" id="L267">      } catch (final SecurityModuleException e) {</span>
<span class="fc" id="L268">        LOG.warn(&quot;Failed to construct commit seal; {}&quot;, e.getMessage());</span>
<span class="fc" id="L269">        return true;</span>
<span class="fc" id="L270">      }</span>

      // There are times handling a proposed block is enough to enter prepared.
<span class="fc bfc" id="L273" title="All 2 branches covered.">      if (wasPrepared != roundState.isPrepared()) {</span>
<span class="fc" id="L274">        LOG.debug(&quot;Sending commit message. round={}&quot;, roundState.getRoundIdentifier());</span>
<span class="fc" id="L275">        transmitter.multicastCommit(getRoundIdentifier(), block.getHash(), commitSeal);</span>
      }

      // can automatically add _our_ commit message to the roundState
      // cannot create a prepare message here, as it may be _our_ proposal, and thus we cannot also
      // prepare
      try {
<span class="fc" id="L282">        final Commit localCommitMessage =</span>
<span class="fc" id="L283">            messageFactory.createCommit(</span>
<span class="fc" id="L284">                roundState.getRoundIdentifier(), msg.getBlock().getHash(), commitSeal);</span>
<span class="fc" id="L285">        roundState.addCommitMessage(localCommitMessage);</span>
<span class="nc" id="L286">      } catch (final SecurityModuleException e) {</span>
<span class="nc" id="L287">        LOG.warn(&quot;Failed to create signed Commit message; {}&quot;, e.getMessage());</span>
<span class="nc" id="L288">        return true;</span>
<span class="fc" id="L289">      }</span>

      // It is possible sufficient commit seals are now available and the block should be imported
<span class="fc bfc" id="L292" title="All 2 branches covered.">      if (wasCommitted != roundState.isCommitted()) {</span>
<span class="fc" id="L293">        importBlockToChain();</span>
      }
    }

<span class="fc" id="L297">    return blockAccepted;</span>
  }

  private void peerIsPrepared(final Prepare msg) {
<span class="fc" id="L301">    final boolean wasPrepared = roundState.isPrepared();</span>
<span class="fc" id="L302">    roundState.addPrepareMessage(msg);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (wasPrepared != roundState.isPrepared()) {</span>
<span class="fc" id="L304">      LOG.debug(&quot;Sending commit message. round={}&quot;, roundState.getRoundIdentifier());</span>
<span class="fc" id="L305">      final Block block = roundState.getProposedBlock().get();</span>
      try {
<span class="fc" id="L307">        transmitter.multicastCommit(getRoundIdentifier(), block.getHash(), createCommitSeal(block));</span>
        // Note: the local-node's commit message was added to RoundState on block acceptance
        // and thus does not need to be done again here.
<span class="nc" id="L310">      } catch (final SecurityModuleException e) {</span>
<span class="nc" id="L311">        LOG.warn(&quot;Failed to construct a commit seal: {}&quot;, e.getMessage());</span>
<span class="fc" id="L312">      }</span>
    }
<span class="fc" id="L314">  }</span>

  private void peerIsCommitted(final Commit msg) {
<span class="fc" id="L317">    final boolean wasCommitted = roundState.isCommitted();</span>
<span class="fc" id="L318">    roundState.addCommitMessage(msg);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">    if (wasCommitted != roundState.isCommitted()) {</span>
<span class="fc" id="L320">      importBlockToChain();</span>
    }
<span class="fc" id="L322">  }</span>

  private void importBlockToChain() {

<span class="fc" id="L326">    final Block blockToImport =</span>
<span class="fc" id="L327">        BftHelpers.createSealedBlock(</span>
            bftExtraDataCodec,
<span class="fc" id="L329">            roundState.getProposedBlock().get(),</span>
<span class="fc" id="L330">            roundState.getRoundIdentifier().getRoundNumber(),</span>
<span class="fc" id="L331">            roundState.getCommitSeals());</span>

<span class="fc" id="L333">    final long blockNumber = blockToImport.getHeader().getNumber();</span>
<span class="fc" id="L334">    final BftExtraData extraData = bftExtraDataCodec.decode(blockToImport.getHeader());</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">    if (getRoundIdentifier().getRoundNumber() &gt; 0) {</span>
<span class="fc" id="L336">      LOG.info(</span>
          &quot;Importing proposed block to chain. round={}, hash={}&quot;,
<span class="fc" id="L338">          getRoundIdentifier(),</span>
<span class="fc" id="L339">          blockToImport.getHash());</span>
    } else {
<span class="fc" id="L341">      LOG.debug(</span>
          &quot;Importing proposed block to chain. round={}, hash={}&quot;,
<span class="fc" id="L343">          getRoundIdentifier(),</span>
<span class="fc" id="L344">          blockToImport.getHash());</span>
    }

<span class="fc" id="L347">    LOG.trace(&quot;Importing proposed block with extraData={}&quot;, extraData);</span>
<span class="fc" id="L348">    final BlockImporter blockImporter =</span>
<span class="fc" id="L349">        protocolSchedule.getByBlockHeader(blockToImport.getHeader()).getBlockImporter();</span>
<span class="fc" id="L350">    final BlockImportResult result =</span>
<span class="fc" id="L351">        blockImporter.importBlock(protocolContext, blockToImport, HeaderValidationMode.FULL);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">    if (!result.isImported()) {</span>
<span class="fc" id="L353">      LOG.error(</span>
          &quot;Failed to import proposed block to chain. block={} extraData={} blockHeader={}&quot;,
<span class="fc" id="L355">          blockNumber,</span>
          extraData,
<span class="fc" id="L357">          blockToImport.getHeader());</span>
    } else {
<span class="fc" id="L359">      notifyNewBlockListeners(blockToImport);</span>
    }
<span class="fc" id="L361">  }</span>

  private SECPSignature createCommitSeal(final Block block) {
<span class="fc" id="L364">    final Block commitBlock = createCommitBlock(block);</span>
<span class="fc" id="L365">    final BlockHeader proposedHeader = commitBlock.getHeader();</span>
<span class="fc" id="L366">    final BftExtraData extraData = bftExtraDataCodec.decode(proposedHeader);</span>
<span class="fc" id="L367">    final Hash commitHash =</span>
        new BftBlockHashing(bftExtraDataCodec)
<span class="fc" id="L369">            .calculateDataHashForCommittedSeal(proposedHeader, extraData);</span>
<span class="fc" id="L370">    return nodeKey.sign(commitHash);</span>
  }

  private Block createCommitBlock(final Block block) {
<span class="fc" id="L374">    final BftBlockInterface bftBlockInterface =</span>
<span class="fc" id="L375">        protocolContext.getConsensusContext(BftContext.class).getBlockInterface();</span>
<span class="fc" id="L376">    return bftBlockInterface.replaceRoundInBlock(</span>
        block,
<span class="fc" id="L378">        getRoundIdentifier().getRoundNumber(),</span>
<span class="fc" id="L379">        BftBlockHeaderFunctions.forCommittedSeal(bftExtraDataCodec));</span>
  }

  private void notifyNewBlockListeners(final Block block) {
<span class="fc" id="L383">    observers.forEach(obs -&gt; obs.blockMined(block));</span>
<span class="fc" id="L384">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>