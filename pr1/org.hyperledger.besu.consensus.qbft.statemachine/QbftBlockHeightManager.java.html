<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QbftBlockHeightManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.qbft.statemachine</a> &gt; <span class="el_source">QbftBlockHeightManager.java</span></div><h1>QbftBlockHeightManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright ConsenSys AG.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.qbft.statemachine;

import org.hyperledger.besu.consensus.common.bft.ConsensusRoundIdentifier;
import org.hyperledger.besu.consensus.common.bft.events.RoundExpiry;
import org.hyperledger.besu.consensus.common.bft.messagewrappers.BftMessage;
import org.hyperledger.besu.consensus.common.bft.payload.Payload;
import org.hyperledger.besu.consensus.common.bft.statemachine.BftFinalState;
import org.hyperledger.besu.consensus.qbft.messagewrappers.Commit;
import org.hyperledger.besu.consensus.qbft.messagewrappers.Prepare;
import org.hyperledger.besu.consensus.qbft.messagewrappers.Proposal;
import org.hyperledger.besu.consensus.qbft.messagewrappers.RoundChange;
import org.hyperledger.besu.consensus.qbft.network.QbftMessageTransmitter;
import org.hyperledger.besu.consensus.qbft.payload.MessageFactory;
import org.hyperledger.besu.consensus.qbft.validation.FutureRoundProposalMessageValidator;
import org.hyperledger.besu.consensus.qbft.validation.MessageValidatorFactory;
import org.hyperledger.besu.datatypes.Address;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.plugin.services.securitymodule.SecurityModuleException;

import java.time.Clock;
import java.util.Collection;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

import com.google.common.collect.Maps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Responsible for starting/clearing Consensus rounds at a given block height. One of these is
 * created when a new block is imported to the chain. It immediately then creates a Round-0 object,
 * and sends a Proposal message. If the round times out prior to importing a block, this class is
 * responsible for creating a RoundChange message and transmitting it.
 */
public class QbftBlockHeightManager implements BaseQbftBlockHeightManager {

<span class="fc" id="L55">  private static final Logger LOG = LoggerFactory.getLogger(QbftBlockHeightManager.class);</span>

  private final QbftRoundFactory roundFactory;
  private final RoundChangeManager roundChangeManager;
  private final BlockHeader parentHeader;
  private final QbftMessageTransmitter transmitter;
  private final MessageFactory messageFactory;
<span class="fc" id="L62">  private final Map&lt;Integer, RoundState&gt; futureRoundStateBuffer = Maps.newHashMap();</span>
  private final FutureRoundProposalMessageValidator futureRoundProposalMessageValidator;
  private final Clock clock;
  private final Function&lt;ConsensusRoundIdentifier, RoundState&gt; roundStateCreator;
  private final BftFinalState finalState;

<span class="fc" id="L68">  private Optional&lt;PreparedCertificate&gt; latestPreparedCertificate = Optional.empty();</span>
<span class="fc" id="L69">  private Optional&lt;QbftRound&gt; currentRound = Optional.empty();</span>

  /**
   * Instantiates a new Qbft block height manager.
   *
   * @param parentHeader the parent header
   * @param finalState the final state
   * @param roundChangeManager the round change manager
   * @param qbftRoundFactory the qbft round factory
   * @param clock the clock
   * @param messageValidatorFactory the message validator factory
   * @param messageFactory the message factory
   */
  public QbftBlockHeightManager(
      final BlockHeader parentHeader,
      final BftFinalState finalState,
      final RoundChangeManager roundChangeManager,
      final QbftRoundFactory qbftRoundFactory,
      final Clock clock,
      final MessageValidatorFactory messageValidatorFactory,
<span class="fc" id="L89">      final MessageFactory messageFactory) {</span>
<span class="fc" id="L90">    this.parentHeader = parentHeader;</span>
<span class="fc" id="L91">    this.roundFactory = qbftRoundFactory;</span>
<span class="fc" id="L92">    this.transmitter =</span>
<span class="fc" id="L93">        new QbftMessageTransmitter(messageFactory, finalState.getValidatorMulticaster());</span>
<span class="fc" id="L94">    this.messageFactory = messageFactory;</span>
<span class="fc" id="L95">    this.clock = clock;</span>
<span class="fc" id="L96">    this.roundChangeManager = roundChangeManager;</span>
<span class="fc" id="L97">    this.finalState = finalState;</span>

<span class="fc" id="L99">    futureRoundProposalMessageValidator =</span>
<span class="fc" id="L100">        messageValidatorFactory.createFutureRoundProposalMessageValidator(</span>
<span class="fc" id="L101">            getChainHeight(), parentHeader);</span>

<span class="fc" id="L103">    roundStateCreator =</span>
        (roundIdentifier) -&gt;
<span class="fc" id="L105">            new RoundState(</span>
                roundIdentifier,
<span class="fc" id="L107">                finalState.getQuorum(),</span>
<span class="fc" id="L108">                messageValidatorFactory.createMessageValidator(roundIdentifier, parentHeader));</span>

<span class="fc" id="L110">    final long nextBlockHeight = parentHeader.getNumber() + 1;</span>
<span class="fc" id="L111">    final ConsensusRoundIdentifier roundIdentifier =</span>
        new ConsensusRoundIdentifier(nextBlockHeight, 0);

<span class="fc" id="L114">    finalState.getBlockTimer().startTimer(roundIdentifier, parentHeader);</span>
<span class="fc" id="L115">  }</span>

  @Override
  public void handleBlockTimerExpiry(final ConsensusRoundIdentifier roundIdentifier) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (currentRound.isPresent()) {</span>
      // It is possible for the block timer to take longer than it should due to the precision of
      // the timer in Java and the OS. This means occasionally the proposal can arrive before the
      // block timer expiry and hence the round has already been set. There is no negative impact
      // on the protocol in this case.
<span class="fc" id="L124">      return;</span>
    }

<span class="fc" id="L127">    startNewRound(0);</span>

<span class="fc" id="L129">    final QbftRound qbftRound = currentRound.get();</span>

<span class="fc" id="L131">    logValidatorChanges(qbftRound);</span>

    // mining will be checked against round 0 as the current round is initialised to 0 above
<span class="fc" id="L134">    final boolean isProposer =</span>
<span class="fc" id="L135">        finalState.isLocalNodeProposerForRound(qbftRound.getRoundIdentifier());</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (isProposer) {</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">      if (roundIdentifier.equals(qbftRound.getRoundIdentifier())) {</span>
<span class="fc" id="L139">        final long headerTimeStampSeconds = Math.round(clock.millis() / 1000D);</span>
<span class="fc" id="L140">        qbftRound.createAndSendProposalMessage(headerTimeStampSeconds);</span>
<span class="fc" id="L141">      } else {</span>
<span class="nc" id="L142">        LOG.trace(</span>
            &quot;Block timer expired for a round ({}) other than current ({})&quot;,
            roundIdentifier,
<span class="nc" id="L145">            qbftRound.getRoundIdentifier());</span>
      }
    }
<span class="fc" id="L148">  }</span>

  /**
   * If the list of validators for the next block to be proposed/imported has changed from the
   * previous block, log the change. Only log for round 0 (i.e. once per block).
   *
   * @param qbftRound The current round
   */
  private void logValidatorChanges(final QbftRound qbftRound) {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">    if (qbftRound.getRoundIdentifier().getRoundNumber() == 0) {</span>
<span class="fc" id="L158">      final Collection&lt;Address&gt; previousValidators =</span>
<span class="fc" id="L159">          MessageValidatorFactory.getValidatorsForBlock(qbftRound.protocolContext, parentHeader);</span>
<span class="fc" id="L160">      final Collection&lt;Address&gt; validatorsForHeight =</span>
<span class="fc" id="L161">          MessageValidatorFactory.getValidatorsAfterBlock(qbftRound.protocolContext, parentHeader);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">      if (!(validatorsForHeight.containsAll(previousValidators))</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">          || !(previousValidators.containsAll(validatorsForHeight))) {</span>
<span class="fc" id="L164">        LOG.info(</span>
            &quot;Validator list change. Previous chain height {}: {}. Current chain height {}: {}.&quot;,
<span class="fc" id="L166">            parentHeader.getNumber(),</span>
            previousValidators,
<span class="fc" id="L168">            parentHeader.getNumber() + 1,</span>
            validatorsForHeight);
      }
    }
<span class="fc" id="L172">  }</span>

  @Override
  public void roundExpired(final RoundExpiry expire) {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">    if (currentRound.isEmpty()) {</span>
<span class="nc" id="L177">      LOG.error(</span>
<span class="nc" id="L178">          &quot;Received Round timer expiry before round is created timerRound={}&quot;, expire.getView());</span>
<span class="nc" id="L179">      return;</span>
    }

<span class="fc" id="L182">    QbftRound qbftRound = currentRound.get();</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">    if (!expire.getView().equals(qbftRound.getRoundIdentifier())) {</span>
<span class="nc" id="L184">      LOG.trace(</span>
          &quot;Ignoring Round timer expired which does not match current round. round={}, timerRound={}&quot;,
<span class="nc" id="L186">          qbftRound.getRoundIdentifier(),</span>
<span class="nc" id="L187">          expire.getView());</span>
<span class="nc" id="L188">      return;</span>
    }

<span class="fc" id="L191">    LOG.debug(</span>
        &quot;Round has expired, creating PreparedCertificate and notifying peers. round={}&quot;,
<span class="fc" id="L193">        qbftRound.getRoundIdentifier());</span>
<span class="fc" id="L194">    final Optional&lt;PreparedCertificate&gt; preparedCertificate =</span>
<span class="fc" id="L195">        qbftRound.constructPreparedCertificate();</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (preparedCertificate.isPresent()) {</span>
<span class="fc" id="L198">      latestPreparedCertificate = preparedCertificate;</span>
    }

<span class="fc" id="L201">    startNewRound(qbftRound.getRoundIdentifier().getRoundNumber() + 1);</span>
<span class="fc" id="L202">    qbftRound = currentRound.get();</span>

    try {
<span class="fc" id="L205">      final RoundChange localRoundChange =</span>
<span class="fc" id="L206">          messageFactory.createRoundChange(</span>
<span class="fc" id="L207">              qbftRound.getRoundIdentifier(), latestPreparedCertificate);</span>

      // Its possible the locally created RoundChange triggers the transmission of a NewRound
      // message - so it must be handled accordingly.
<span class="fc" id="L211">      handleRoundChangePayload(localRoundChange);</span>
<span class="nc" id="L212">    } catch (final SecurityModuleException e) {</span>
<span class="nc" id="L213">      LOG.warn(&quot;Failed to create signed RoundChange message.&quot;, e);</span>
<span class="fc" id="L214">    }</span>

<span class="fc" id="L216">    transmitter.multicastRoundChange(qbftRound.getRoundIdentifier(), latestPreparedCertificate);</span>
<span class="fc" id="L217">  }</span>

  @Override
  public void handleProposalPayload(final Proposal proposal) {
<span class="fc" id="L221">    LOG.trace(&quot;Received a Proposal Payload.&quot;);</span>
<span class="fc" id="L222">    final MessageAge messageAge =</span>
<span class="fc" id="L223">        determineAgeOfPayload(proposal.getRoundIdentifier().getRoundNumber());</span>

<span class="pc bpc" id="L225" title="1 of 2 branches missed.">    if (messageAge == MessageAge.PRIOR_ROUND) {</span>
<span class="nc" id="L226">      LOG.trace(&quot;Received Proposal Payload for a prior round={}&quot;, proposal.getRoundIdentifier());</span>
    } else {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">      if (messageAge == MessageAge.FUTURE_ROUND) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (!futureRoundProposalMessageValidator.validateProposalMessage(proposal)) {</span>
<span class="fc" id="L230">          LOG.info(&quot;Received future Proposal which is illegal, no round change triggered.&quot;);</span>
<span class="fc" id="L231">          return;</span>
        }
<span class="fc" id="L233">        startNewRound(proposal.getRoundIdentifier().getRoundNumber());</span>
      }
<span class="fc" id="L235">      currentRound.ifPresent(r -&gt; r.handleProposalMessage(proposal));</span>
    }
<span class="fc" id="L237">  }</span>

  @Override
  public void handlePreparePayload(final Prepare prepare) {
<span class="fc" id="L241">    LOG.trace(&quot;Received a Prepare Payload.&quot;);</span>
<span class="fc" id="L242">    actionOrBufferMessage(</span>
        prepare,
<span class="pc bfc" id="L244" title="All 2 branches covered.">        currentRound.isPresent() ? currentRound.get()::handlePrepareMessage : (ignore) -&gt; {},</span>
        RoundState::addPrepareMessage);
<span class="fc" id="L246">  }</span>

  @Override
  public void handleCommitPayload(final Commit commit) {
<span class="fc" id="L250">    LOG.trace(&quot;Received a Commit Payload.&quot;);</span>
<span class="fc" id="L251">    actionOrBufferMessage(</span>
        commit,
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        currentRound.isPresent() ? currentRound.get()::handleCommitMessage : (ignore) -&gt; {},</span>
        RoundState::addCommitMessage);
<span class="fc" id="L255">  }</span>

  private &lt;P extends Payload, M extends BftMessage&lt;P&gt;&gt; void actionOrBufferMessage(
      final M qbftMessage,
      final Consumer&lt;M&gt; inRoundHandler,
      final BiConsumer&lt;RoundState, M&gt; buffer) {
<span class="fc" id="L261">    final MessageAge messageAge =</span>
<span class="fc" id="L262">        determineAgeOfPayload(qbftMessage.getRoundIdentifier().getRoundNumber());</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (messageAge == MessageAge.CURRENT_ROUND) {</span>
<span class="fc" id="L264">      inRoundHandler.accept(qbftMessage);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    } else if (messageAge == MessageAge.FUTURE_ROUND) {</span>
<span class="fc" id="L266">      final ConsensusRoundIdentifier msgRoundId = qbftMessage.getRoundIdentifier();</span>
<span class="fc" id="L267">      final RoundState roundstate =</span>
<span class="fc" id="L268">          futureRoundStateBuffer.computeIfAbsent(</span>
<span class="fc" id="L269">              msgRoundId.getRoundNumber(), k -&gt; roundStateCreator.apply(msgRoundId));</span>
<span class="fc" id="L270">      buffer.accept(roundstate, qbftMessage);</span>
    }
<span class="fc" id="L272">  }</span>

  @Override
  public void handleRoundChangePayload(final RoundChange message) {
<span class="fc" id="L276">    final ConsensusRoundIdentifier targetRound = message.getRoundIdentifier();</span>
<span class="fc" id="L277">    LOG.trace(&quot;Received a RoundChange Payload for {}&quot;, targetRound);</span>

<span class="fc" id="L279">    final MessageAge messageAge =</span>
<span class="fc" id="L280">        determineAgeOfPayload(message.getRoundIdentifier().getRoundNumber());</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">    if (messageAge == MessageAge.PRIOR_ROUND) {</span>
<span class="nc" id="L282">      LOG.trace(&quot;Received RoundChange Payload for a prior round. targetRound={}&quot;, targetRound);</span>
<span class="nc" id="L283">      return;</span>
    }

<span class="fc" id="L286">    final Optional&lt;Collection&lt;RoundChange&gt;&gt; result =</span>
<span class="fc" id="L287">        roundChangeManager.appendRoundChangeMessage(message);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">    if (result.isPresent()) {</span>
<span class="fc" id="L289">      LOG.debug(</span>
          &quot;Received sufficient RoundChange messages to change round to targetRound={}&quot;,
          targetRound);
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">      if (messageAge == MessageAge.FUTURE_ROUND) {</span>
<span class="fc" id="L293">        startNewRound(targetRound.getRoundNumber());</span>
      }

<span class="fc" id="L296">      final RoundChangeArtifacts roundChangeMetadata = RoundChangeArtifacts.create(result.get());</span>

<span class="fc bfc" id="L298" title="All 2 branches covered.">      if (finalState.isLocalNodeProposerForRound(targetRound)) {</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (currentRound.isEmpty()) {</span>
<span class="nc" id="L300">          startNewRound(0);</span>
        }
<span class="fc" id="L302">        currentRound</span>
<span class="fc" id="L303">            .get()</span>
<span class="fc" id="L304">            .startRoundWith(roundChangeMetadata, TimeUnit.MILLISECONDS.toSeconds(clock.millis()));</span>
      }
    }
<span class="fc" id="L307">  }</span>

  private void startNewRound(final int roundNumber) {
<span class="fc" id="L310">    LOG.debug(&quot;Starting new round {}&quot;, roundNumber);</span>
    // validate the current round
<span class="fc bfc" id="L312" title="All 2 branches covered.">    if (futureRoundStateBuffer.containsKey(roundNumber)) {</span>
<span class="fc" id="L313">      currentRound =</span>
<span class="fc" id="L314">          Optional.of(</span>
<span class="fc" id="L315">              roundFactory.createNewRoundWithState(</span>
<span class="fc" id="L316">                  parentHeader, futureRoundStateBuffer.get(roundNumber)));</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">      futureRoundStateBuffer.keySet().removeIf(k -&gt; k &lt;= roundNumber);</span>
    } else {
<span class="fc" id="L319">      currentRound = Optional.of(roundFactory.createNewRound(parentHeader, roundNumber));</span>
    }
    // discard roundChange messages from the current and previous rounds
<span class="fc" id="L322">    roundChangeManager.discardRoundsPriorTo(currentRound.get().getRoundIdentifier());</span>
<span class="fc" id="L323">  }</span>

  @Override
  public long getChainHeight() {
<span class="fc" id="L327">    return parentHeader.getNumber() + 1;</span>
  }

  @Override
  public BlockHeader getParentBlockHeader() {
<span class="nc" id="L332">    return parentHeader;</span>
  }

  private MessageAge determineAgeOfPayload(final int messageRoundNumber) {
<span class="fc" id="L336">    final int currentRoundNumber =</span>
<span class="fc" id="L337">        currentRound.map(r -&gt; r.getRoundIdentifier().getRoundNumber()).orElse(-1);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">    if (messageRoundNumber &gt; currentRoundNumber) {</span>
<span class="fc" id="L339">      return MessageAge.FUTURE_ROUND;</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    } else if (messageRoundNumber == currentRoundNumber) {</span>
<span class="fc" id="L341">      return MessageAge.CURRENT_ROUND;</span>
    }
<span class="nc" id="L343">    return MessageAge.PRIOR_ROUND;</span>
  }

  /** The enum Message age. */
<span class="fc" id="L347">  public enum MessageAge {</span>
    /** Prior round message age. */
<span class="fc" id="L349">    PRIOR_ROUND,</span>
    /** Current round message age. */
<span class="fc" id="L351">    CURRENT_ROUND,</span>
    /** Future round message age. */
<span class="fc" id="L353">    FUTURE_ROUND</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>