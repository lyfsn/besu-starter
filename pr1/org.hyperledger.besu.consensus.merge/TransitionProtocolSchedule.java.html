<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransitionProtocolSchedule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">besu</a> &gt; <a href="index.source.html" class="el_package">org.hyperledger.besu.consensus.merge</a> &gt; <span class="el_source">TransitionProtocolSchedule.java</span></div><h1>TransitionProtocolSchedule.java</h1><pre class="source lang-java linenums">/*
 * Copyright Hyperledger Besu Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
package org.hyperledger.besu.consensus.merge;

import org.hyperledger.besu.config.GenesisConfigOptions;
import org.hyperledger.besu.ethereum.ProtocolContext;
import org.hyperledger.besu.ethereum.chain.BadBlockManager;
import org.hyperledger.besu.ethereum.core.BlockHeader;
import org.hyperledger.besu.ethereum.core.Difficulty;
import org.hyperledger.besu.ethereum.core.MiningParameters;
import org.hyperledger.besu.ethereum.core.PermissionTransactionFilter;
import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;
import org.hyperledger.besu.ethereum.mainnet.MainnetProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;
import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;
import org.hyperledger.besu.ethereum.mainnet.ScheduledProtocolSpec;
import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;

import java.math.BigInteger;
import java.util.Optional;
import java.util.function.Predicate;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** The Transition protocol schedule. */
public class TransitionProtocolSchedule implements ProtocolSchedule {
  private final TransitionUtils&lt;ProtocolSchedule&gt; transitionUtils;
<span class="fc" id="L41">  private static final Logger LOG = LoggerFactory.getLogger(TransitionProtocolSchedule.class);</span>
  private final MergeContext mergeContext;
  private ProtocolContext protocolContext;

  /**
   * Instantiates a new Transition protocol schedule.
   *
   * @param preMergeProtocolSchedule the pre merge protocol schedule
   * @param postMergeProtocolSchedule the post merge protocol schedule
   * @param mergeContext the merge context
   */
  public TransitionProtocolSchedule(
      final ProtocolSchedule preMergeProtocolSchedule,
      final ProtocolSchedule postMergeProtocolSchedule,
<span class="fc" id="L55">      final MergeContext mergeContext) {</span>
<span class="fc" id="L56">    this.mergeContext = mergeContext;</span>
<span class="fc" id="L57">    transitionUtils =</span>
        new TransitionUtils&lt;&gt;(preMergeProtocolSchedule, postMergeProtocolSchedule, mergeContext);
<span class="fc" id="L59">  }</span>

  /**
   * Create a Proof-of-Stake protocol schedule from a config object
   *
   * @param genesisConfigOptions {@link GenesisConfigOptions} containing the config options for the
   *     milestone starting points
   * @param miningParameters the mining parameters
   * @param badBlockManager the cache to use to keep invalid blocks
   * @return an initialised TransitionProtocolSchedule using post-merge defaults
   */
  public static TransitionProtocolSchedule fromConfig(
      final GenesisConfigOptions genesisConfigOptions,
      final MiningParameters miningParameters,
      final BadBlockManager badBlockManager) {
<span class="nc" id="L74">    ProtocolSchedule preMergeProtocolSchedule =</span>
<span class="nc" id="L75">        MainnetProtocolSchedule.fromConfig(genesisConfigOptions, miningParameters, badBlockManager);</span>
<span class="nc" id="L76">    ProtocolSchedule postMergeProtocolSchedule =</span>
<span class="nc" id="L77">        MergeProtocolSchedule.create(</span>
            genesisConfigOptions, false, miningParameters, badBlockManager);
<span class="nc" id="L79">    return new TransitionProtocolSchedule(</span>
<span class="nc" id="L80">        preMergeProtocolSchedule, postMergeProtocolSchedule, PostMergeContext.get());</span>
  }

  /**
   * Gets pre merge schedule.
   *
   * @return the pre merge schedule
   */
  public ProtocolSchedule getPreMergeSchedule() {
<span class="fc" id="L89">    return transitionUtils.getPreMergeObject();</span>
  }

  /**
   * Gets post merge schedule.
   *
   * @return the post merge schedule
   */
  public ProtocolSchedule getPostMergeSchedule() {
<span class="fc" id="L98">    return transitionUtils.getPostMergeObject();</span>
  }

  /**
   * Gets protocol spec by block header.
   *
   * @param blockHeader the block header
   * @return the ProtocolSpec to be used by the provided block
   */
  @Override
  public ProtocolSpec getByBlockHeader(final ProcessableBlockHeader blockHeader) {
<span class="fc" id="L109">    return this.transitionUtils.dispatchFunctionAccordingToMergeState(</span>
<span class="fc" id="L110">        protocolSchedule -&gt; protocolSchedule.getByBlockHeader(blockHeader));</span>
  }

  /**
   * Gets the protocol spec by block header, with some additional logic used by backwards sync (BWS)
   *
   * @param blockHeader the block header
   * @return the ProtocolSpec to be used by the provided block
   */
  public ProtocolSpec getByBlockHeaderWithTransitionReorgHandling(
      final ProcessableBlockHeader blockHeader) {
    // if we do not have a finalized block we might return pre or post merge protocol schedule:
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (mergeContext.getFinalized().isEmpty()) {</span>

      // if head is not post-merge, return pre-merge schedule:
<span class="fc bfc" id="L125" title="All 2 branches covered.">      if (!mergeContext.isPostMerge()) {</span>
<span class="fc" id="L126">        LOG.atDebug()</span>
<span class="fc" id="L127">            .setMessage(&quot;for {} returning a pre-merge schedule because we are not post-merge&quot;)</span>
<span class="fc" id="L128">            .addArgument(blockHeader::toLogString)</span>
<span class="fc" id="L129">            .log();</span>
<span class="fc" id="L130">        return getPreMergeSchedule().getByBlockHeader(blockHeader);</span>
      }

      // otherwise check to see if this block represents a re-org TTD block:
<span class="fc" id="L134">      Difficulty parentDifficulty =</span>
          protocolContext
<span class="fc" id="L136">              .getBlockchain()</span>
<span class="fc" id="L137">              .getTotalDifficultyByHash(blockHeader.getParentHash())</span>
<span class="fc" id="L138">              .orElse(Difficulty.ZERO);</span>
<span class="fc" id="L139">      Difficulty thisDifficulty = parentDifficulty.add(blockHeader.getDifficulty());</span>
<span class="fc" id="L140">      Difficulty terminalDifficulty = mergeContext.getTerminalTotalDifficulty();</span>
<span class="fc" id="L141">      LOG.atDebug()</span>
<span class="fc" id="L142">          .setMessage(&quot; block {} ttd is: {}, parent total diff is: {}, this total diff is: {}&quot;)</span>
<span class="fc" id="L143">          .addArgument(blockHeader::toLogString)</span>
<span class="fc" id="L144">          .addArgument(terminalDifficulty)</span>
<span class="fc" id="L145">          .addArgument(parentDifficulty)</span>
<span class="fc" id="L146">          .addArgument(thisDifficulty)</span>
<span class="fc" id="L147">          .log();</span>

      // if this block is pre-merge or a TTD block
<span class="fc bfc" id="L150" title="All 2 branches covered.">      if (thisDifficulty.lessThan(terminalDifficulty)</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">          || TransitionUtils.isTerminalProofOfWorkBlock(blockHeader, protocolContext)) {</span>
<span class="fc" id="L152">        LOG.atDebug()</span>
<span class="fc" id="L153">            .setMessage(&quot;returning a pre-merge schedule because block {} is pre-merge or TTD&quot;)</span>
<span class="fc" id="L154">            .addArgument(blockHeader::toLogString)</span>
<span class="fc" id="L155">            .log();</span>
<span class="fc" id="L156">        return getPreMergeSchedule().getByBlockHeader(blockHeader);</span>
      }
    }
    // else return post-merge schedule
<span class="fc" id="L160">    LOG.atDebug()</span>
<span class="fc" id="L161">        .setMessage(&quot; for {} returning a post-merge schedule&quot;)</span>
<span class="fc" id="L162">        .addArgument(blockHeader::toLogString)</span>
<span class="fc" id="L163">        .log();</span>
<span class="fc" id="L164">    return getPostMergeSchedule().getByBlockHeader(blockHeader);</span>
  }

  @Override
  public boolean anyMatch(final Predicate&lt;ScheduledProtocolSpec&gt; predicate) {
<span class="fc" id="L169">    return transitionUtils.dispatchFunctionAccordingToMergeState(</span>
<span class="fc" id="L170">        schedule -&gt; schedule.anyMatch(predicate));</span>
  }

  @Override
  public boolean isOnMilestoneBoundary(final BlockHeader blockHeader) {
<span class="fc" id="L175">    return transitionUtils.dispatchFunctionAccordingToMergeState(</span>
<span class="fc" id="L176">        schedule -&gt; schedule.isOnMilestoneBoundary(blockHeader));</span>
  }

  /**
   * Gets chain id.
   *
   * @return the chain id
   */
  @Override
  public Optional&lt;BigInteger&gt; getChainId() {
<span class="nc" id="L186">    return transitionUtils.dispatchFunctionAccordingToMergeState(ProtocolSchedule::getChainId);</span>
  }

  /**
   * Put blockNumber milestone.
   *
   * @param blockNumber the block or timestamp
   * @param protocolSpec the protocol spec
   */
  @Override
  public void putBlockNumberMilestone(final long blockNumber, final ProtocolSpec protocolSpec) {
<span class="nc" id="L197">    throw new UnsupportedOperationException(</span>
        &quot;Should not use TransitionProtocolSchedule wrapper class to create milestones&quot;);
  }

  /**
   * Put timestamp milestone.
   *
   * @param timestamp the block or timestamp
   * @param protocolSpec the protocol spec
   */
  @Override
  public void putTimestampMilestone(final long timestamp, final ProtocolSpec protocolSpec) {
<span class="nc" id="L209">    throw new UnsupportedOperationException(</span>
        &quot;Should not use TransitionProtocolSchedule wrapper class to create milestones&quot;);
  }

  @Override
  public Optional&lt;ScheduledProtocolSpec.Hardfork&gt; hardforkFor(
      final Predicate&lt;ScheduledProtocolSpec&gt; predicate) {
<span class="nc" id="L216">    return this.transitionUtils.dispatchFunctionAccordingToMergeState(</span>
<span class="nc" id="L217">        schedule -&gt; schedule.hardforkFor(predicate));</span>
  }

  /**
   * List milestones.
   *
   * @return the string
   */
  @Override
  public String listMilestones() {
<span class="nc" id="L227">    return transitionUtils.dispatchFunctionAccordingToMergeState(ProtocolSchedule::listMilestones);</span>
  }

  /**
   * Sets transaction filter.
   *
   * @param permissionTransactionFilter the transaction filter
   */
  @Override
  public void setPermissionTransactionFilter(
      final PermissionTransactionFilter permissionTransactionFilter) {
<span class="nc" id="L238">    transitionUtils.dispatchConsumerAccordingToMergeState(</span>
        protocolSchedule -&gt;
<span class="nc" id="L240">            protocolSchedule.setPermissionTransactionFilter(permissionTransactionFilter));</span>
<span class="nc" id="L241">  }</span>

  /**
   * Sets public world state archive for privacy block processor.
   *
   * @param publicWorldStateArchive the public world state archive
   */
  @Override
  public void setPublicWorldStateArchiveForPrivacyBlockProcessor(
      final WorldStateArchive publicWorldStateArchive) {
<span class="fc" id="L251">    transitionUtils.dispatchConsumerAccordingToMergeState(</span>
        protocolSchedule -&gt;
<span class="fc" id="L253">            protocolSchedule.setPublicWorldStateArchiveForPrivacyBlockProcessor(</span>
                publicWorldStateArchive));
<span class="fc" id="L255">  }</span>

  /**
   * Sets protocol context.
   *
   * @param protocolContext the protocol context
   */
  public void setProtocolContext(final ProtocolContext protocolContext) {
<span class="fc" id="L263">    this.protocolContext = protocolContext;</span>
<span class="fc" id="L264">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>